# Hello-Agents ç¬¬å…­ç« ä¹ é¢˜è§£ç­”

> æœ¬æ–‡æ¡£æä¾›ç¬¬å…­ç« ã€Šæ¡†æ¶å¼€å‘å®è·µã€‹çš„ä¹ é¢˜è§£ç­”

---

## ä¹ é¢˜1: æ¡†æ¶å¯¹æ¯”ä¸è®¾è®¡å“²å­¦

### é¢˜ç›®

æœ¬ç« ä»‹ç»äº†å››ä¸ªå„å…·ç‰¹è‰²çš„æ™ºèƒ½ä½“æ¡†æ¶ï¼š`AutoGen`ã€`AgentScope`ã€`CAMEL` å’Œ `LangGraph`ã€‚è¯·åˆ†æï¼š

- åœ¨6.1.2èŠ‚çš„è¡¨6.1ä¸­,å¯¹æ¯”äº†è¿™å››ä¸ªæ¡†æ¶çš„å¤šä¸ªç»´åº¦ã€‚è¯·é€‰æ‹©å…¶ä¸­ä¸¤ä¸ªä½ æœ€ç†Ÿæ‚‰çš„æ¡†æ¶,ä»"åä½œæ¨¡å¼"ã€"æ§åˆ¶æ–¹å¼"ã€"é€‚ç”¨åœºæ™¯"ä¸‰ä¸ªç»´åº¦è¿›ä¸€æ­¥æ·±å…¥å¯¹æ¯”ã€‚
- æœ¬ç« æåˆ°äº†"æ¶Œç°å¼åä½œ"ä¸"æ˜¾å¼æ§åˆ¶"ä¹‹é—´çš„æƒè¡¡,å¦‚ä½•ç†è§£è¿™ä¸¤ç§è®¾è®¡å“²å­¦çš„å«ä¹‰ã€‚

---

### è§£ç­”1.1: AutoGen vs LangGraph æ·±åº¦å¯¹æ¯”

#### ğŸ¯ åä½œæ¨¡å¼å¯¹æ¯”

**AutoGen - å¯¹è¯é©±åŠ¨çš„ç¾¤èŠæ¨¡å¼**

```
æ ¸å¿ƒç†å¿µ: "æ™ºèƒ½ä½“å°±æ˜¯å‚ä¼šè€…"

ä¼šè®®å®¤åœºæ™¯:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    RoundRobinGroupChat          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ‘¤ äº§å“ç»ç†: "æˆ‘æä¸ªéœ€æ±‚..."    â”‚
â”‚ ğŸ‘¨â€ğŸ’» å·¥ç¨‹å¸ˆ: "æŠ€æœ¯ä¸Šå¯è¡Œ..."       â”‚
â”‚ ğŸ‘ï¸ å®¡æŸ¥å‘˜: "ä»£ç è´¨é‡ä¸é”™..."     â”‚
â”‚ ğŸ™‹ ç”¨æˆ·ä»£ç†: "ç¡®è®¤,ç»§ç»­..."      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

åä½œç‰¹ç‚¹:
âœ… è½®æµå‘è¨€ (RoundRobin)
âœ… è‡ªç„¶è¯­è¨€äº¤æµ
âœ… è§’è‰²åŸºäº System Message å®šä¹‰
âœ… åä½œæµç¨‹"æ¶Œç°"äºå¯¹è¯

ä»£ç ç¤ºä¾‹:
from autogen import AssistantAgent, UserProxyAgent, GroupChat

# å®šä¹‰è§’è‰²
product_manager = AssistantAgent(
    name="PM",
    system_message="ä½ æ˜¯äº§å“ç»ç†,è´Ÿè´£éœ€æ±‚åˆ†æå’Œäº§å“è®¾è®¡"
)

engineer = AssistantAgent(
    name="Engineer",
    system_message="ä½ æ˜¯å·¥ç¨‹å¸ˆ,è´Ÿè´£æŠ€æœ¯å®ç°å’Œä»£ç ç¼–å†™"
)

# åˆ›å»ºç¾¤èŠ
group_chat = GroupChat(
    agents=[product_manager, engineer],
    messages=[],
    max_round=10,
    speaker_selection_method="round_robin"  # è½®è¯¢æ¨¡å¼
)
```

**LangGraph - å›¾ç»“æ„çš„çŠ¶æ€æœºæ¨¡å¼**

```
æ ¸å¿ƒç†å¿µ: "æ™ºèƒ½ä½“å°±æ˜¯èŠ‚ç‚¹"

æµç¨‹å›¾åœºæ™¯:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Start  â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç†è§£ç”¨æˆ·éœ€æ±‚ â”‚ (èŠ‚ç‚¹1)
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æœç´¢çŸ¥è¯†åº“  â”‚ (èŠ‚ç‚¹2)
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â†“ (æ¡ä»¶åˆ¤æ–­)
    /  \
   /    \
è¶³å¤Ÿ?   ä¸å¤Ÿ?
 â†“      â†“
ç”Ÿæˆç­”æ¡ˆ  ç»§ç»­æœç´¢ (å¾ªç¯)

åä½œç‰¹ç‚¹:
âœ… æ˜¾å¼å®šä¹‰æµç¨‹å›¾
âœ… æ¯ä¸ªèŠ‚ç‚¹æ˜¯ç‹¬ç«‹å‡½æ•°
âœ… è¾¹ (Edge) æ§åˆ¶æµè½¬
âœ… æ”¯æŒå¾ªç¯å’Œæ¡ä»¶è·³è½¬

ä»£ç ç¤ºä¾‹:
from langgraph.graph import StateGraph

# å®šä¹‰çŠ¶æ€
class AgentState(TypedDict):
    user_query: str
    search_results: list
    answer: str

# å®šä¹‰èŠ‚ç‚¹
def understand_node(state):
    # ç†è§£ç”¨æˆ·æ„å›¾
    return {"user_query": state["user_query"]}

def search_node(state):
    # æœç´¢çŸ¥è¯†åº“
    results = search_kb(state["user_query"])
    return {"search_results": results}

def answer_node(state):
    # ç”Ÿæˆç­”æ¡ˆ
    answer = generate_answer(state["search_results"])
    return {"answer": answer}

# æ„å»ºå›¾
workflow = StateGraph(AgentState)
workflow.add_node("understand", understand_node)
workflow.add_node("search", search_node)
workflow.add_node("answer", answer_node)

# å®šä¹‰è¾¹
workflow.add_edge("understand", "search")
workflow.add_conditional_edges(
    "search",
    lambda state: "answer" if len(state["search_results"]) > 0 else "search"
)
```

**å¯¹æ¯”æ€»ç»“**:

| ç»´åº¦ | AutoGen | LangGraph |
|------|---------|-----------|
| æµç¨‹æ§åˆ¶ | éšå¼(å¯¹è¯é©±åŠ¨) | æ˜¾å¼(å›¾ç»“æ„) |
| åä½œæ–¹å¼ | è‡ªç„¶è¯­è¨€äº¤äº’ | çŠ¶æ€ä¼ é€’ |
| çµæ´»æ€§ | é«˜(ä¸å¯é¢„æµ‹) | ä¸­(å¯é¢„æµ‹) |
| å¯è°ƒè¯•æ€§ | ä½ | é«˜ |
| é€‚åˆåœºæ™¯ | åˆ›æ„åä½œã€å¤´è„‘é£æš´ | å›ºå®šæµç¨‹ã€å¯é æ‰§è¡Œ |

---

#### ğŸ® æ§åˆ¶æ–¹å¼å¯¹æ¯”

**AutoGen - å¼±æ§åˆ¶,å¼ºæ¶Œç°**

```
æ§åˆ¶ç²’åº¦: ç²—ç²’åº¦

å¼€å‘è€…æ§åˆ¶:
- å®šä¹‰æ™ºèƒ½ä½“è§’è‰² (System Message)
- è®¾ç½®ç»ˆæ­¢æ¡ä»¶ (max_round, termination_msg)
- é€‰æ‹©å‘è¨€é¡ºåº (speaker_selection_method)

è‡ªä¸»æ¶Œç°:
- å¯¹è¯å†…å®¹ç”±æ™ºèƒ½ä½“è‡ªä¸»å†³å®š
- åä½œç­–ç•¥åŠ¨æ€å½¢æˆ
- é—®é¢˜è§£å†³è·¯å¾„ä¸ç¡®å®š

ç¤ºä¾‹:
# ä½ åªèƒ½æ§åˆ¶"è°å‚ä¼š"å’Œ"ä¼šè®®è§„åˆ™"
group_chat = GroupChat(
    agents=[pm, engineer, reviewer],  # æ§åˆ¶: å‚ä¼šè€…
    max_round=20,                     # æ§åˆ¶: ä¼šè®®é•¿åº¦
    speaker_selection_method="auto"   # å¼±æ§åˆ¶: AIè‡ªåŠ¨é€‰æ‹©ä¸‹ä¸€ä¸ªå‘è¨€è€…
)

# ä½†ä½ æ— æ³•æ§åˆ¶:
# - PMå…·ä½“è¯´ä»€ä¹ˆ
# - Engineerå¦‚ä½•å›åº”
# - å¯¹è¯ä½•æ—¶è¾¾æˆå…±è¯†
```

**LangGraph - å¼ºæ§åˆ¶,å¼±æ¶Œç°**

```
æ§åˆ¶ç²’åº¦: ç»†ç²’åº¦

å¼€å‘è€…æ§åˆ¶:
- æ¯ä¸ªèŠ‚ç‚¹çš„ç²¾ç¡®é€»è¾‘
- çŠ¶æ€è½¬æ¢çš„æ¡ä»¶
- æ•°æ®æµåŠ¨çš„è·¯å¾„
- å¾ªç¯çš„ç»ˆæ­¢æ¡ä»¶

ç¤ºä¾‹:
# ä½ ç²¾ç¡®æ§åˆ¶æ¯ä¸€æ­¥
workflow = StateGraph(AgentState)

# æ§åˆ¶: èŠ‚ç‚¹1çš„è¾“å…¥è¾“å‡º
workflow.add_node("parse", lambda state: {
    "parsed_query": extract_keywords(state["user_input"])
})

# æ§åˆ¶: ä½•æ—¶è·³è½¬åˆ°èŠ‚ç‚¹2
workflow.add_conditional_edges(
    "parse",
    lambda state: "search" if state["parsed_query"] else "fallback"
)

# æ§åˆ¶: å¾ªç¯æ¡ä»¶
def should_continue(state):
    if state["attempts"] > 3:
        return "end"
    elif state["quality_score"] > 0.8:
        return "end"
    else:
        return "retry"

workflow.add_conditional_edges("generate", should_continue)
```

**å®é™…æ¡ˆä¾‹å¯¹æ¯”**:

```
ä»»åŠ¡: "ç”Ÿæˆä¸€ä»½äº§å“PRDæ–‡æ¡£"

AutoGenå®ç°:
1. å®šä¹‰3ä¸ªæ™ºèƒ½ä½“: PMã€å·¥ç¨‹å¸ˆã€è®¾è®¡å¸ˆ
2. å¯åŠ¨ç¾¤èŠ,è¾“å…¥: "è¯·åä½œå®ŒæˆPRD"
3. ç­‰å¾…...
   - PM: "æˆ‘å…ˆå†™éœ€æ±‚èƒŒæ™¯..."
   - å·¥ç¨‹å¸ˆ: "æˆ‘è¡¥å……æŠ€æœ¯çº¦æŸ..."
   - è®¾è®¡å¸ˆ: "æˆ‘å»ºè®®åŠ å…¥äº¤äº’è®¾è®¡..."
   - PM: "å¥½çš„,æˆ‘æ•´åˆä¸€ä¸‹..."
4. å¯¹è¯ç»“æŸ (å¯èƒ½ç¬¬15è½®,ä¹Ÿå¯èƒ½ç¬¬50è½®)

ä¼˜ç‚¹: äº§å‡ºå¯èƒ½è¶…å‡ºé¢„æœŸ (æ¶Œç°)
ç¼ºç‚¹: æ—¶é—´ä¸å¯æ§,å¯èƒ½åç¦»ä¸»é¢˜

LangGraphå®ç°:
1. å®šä¹‰6ä¸ªèŠ‚ç‚¹:
   - æ”¶é›†éœ€æ±‚
   - æŠ€æœ¯è¯„ä¼°
   - è®¾è®¡å»ºè®®
   - æ•´åˆæ–‡æ¡£
   - è´¨é‡æ£€æŸ¥
   - è¾“å‡ºPRD
2. å®šä¹‰ç²¾ç¡®æµç¨‹: èŠ‚ç‚¹1â†’èŠ‚ç‚¹2â†’...â†’èŠ‚ç‚¹6
3. è®¾ç½®è´¨é‡æ£€æŸ¥: å¦‚æœåˆ†æ•°<0.8,å¾ªç¯å›èŠ‚ç‚¹4
4. æ‰§è¡Œå®Œæˆ (æ€»æ˜¯6æ­¥,é™¤éå¾ªç¯)

ä¼˜ç‚¹: æ—¶é—´å¯æ§,æµç¨‹æ¸…æ™°
ç¼ºç‚¹: ç¼ºå°‘"æƒŠå–œ",åˆ›é€ æ€§å—é™
```

---

#### ğŸ¯ é€‚ç”¨åœºæ™¯å¯¹æ¯”

**AutoGené€‚ç”¨åœºæ™¯**

```
âœ… åˆ›æ„å‹ä»»åŠ¡
åœºæ™¯: å¤´è„‘é£æš´ä¼šè®®
ç¤ºä¾‹: "è®¾è®¡ä¸€ä¸ªåˆ›æ–°çš„AIäº§å“"
ç†ç”±: å¤šè§’è‰²è‡ªç”±è®¨è®ºèƒ½æ¿€å‘åˆ›æ„

âœ… å¤æ‚é—®é¢˜æ±‚è§£
åœºæ™¯: ç–‘éš¾Bugè°ƒè¯•
ç¤ºä¾‹: "è¿™ä¸ªæ€§èƒ½é—®é¢˜çš„æ ¹å› æ˜¯ä»€ä¹ˆ?"
ç†ç”±: å¤šä¸ªä¸“å®¶ä»ä¸åŒè§’åº¦åˆ†æ

âœ… çŸ¥è¯†æ¢ç´¢
åœºæ™¯: å­¦æœ¯ç ”ç©¶
ç¤ºä¾‹: "åˆ†æè¿™ç¯‡è®ºæ–‡çš„åˆ›æ–°ç‚¹"
ç†ç”±: å¯¹è¯å¼æ¢ç´¢èƒ½æ·±å…¥æŒ–æ˜

âœ… æ•™è‚²è¾…å¯¼
åœºæ™¯: è‹æ ¼æ‹‰åº•å¼æ•™å­¦
ç¤ºä¾‹: "å¼•å¯¼å­¦ç”Ÿç†è§£ç®—æ³•åŸç†"
ç†ç”±: é€šè¿‡å¯¹è¯å¯å‘æ€è€ƒ

âŒ ä¸é€‚ç”¨åœºæ™¯:
- é‡‘èäº¤æ˜“ç³»ç»Ÿ (éœ€è¦100%å¯é¢„æµ‹)
- åŒ»ç–—è¯Šæ–­ç³»ç»Ÿ (ä¸èƒ½æœ‰æ„å¤–)
- ç”Ÿäº§æµæ°´çº¿ (å¿…é¡»æ ‡å‡†åŒ–)
```

**LangGraphé€‚ç”¨åœºæ™¯**

```
âœ… å›ºå®šæµç¨‹ä»»åŠ¡
åœºæ™¯: å®¢æˆ·æœåŠ¡å·¥å•å¤„ç†
ç¤ºä¾‹: æ¥å•â†’åˆ†ç±»â†’åˆ†é…â†’å¤„ç†â†’å…³å•
ç†ç”±: æµç¨‹æ˜ç¡®,ä¸éœ€è¦"æ¶Œç°"

âœ… éœ€è¦å¾ªç¯ä¼˜åŒ–çš„ä»»åŠ¡
åœºæ™¯: ä»£ç ç”Ÿæˆ-æµ‹è¯•-ä¿®å¤å¾ªç¯
ç¤ºä¾‹:
  ç”Ÿæˆä»£ç  â†’ è¿è¡Œæµ‹è¯•
       â†“ å¤±è´¥       â†‘
    ä¿®å¤Bug â†-------â”˜
ç†ç”±: LangGraphåŸç”Ÿæ”¯æŒå¾ªç¯

âœ… äººæœºåä½œä»»åŠ¡
åœºæ™¯: å®¡æ‰¹æµç¨‹
ç¤ºä¾‹: AIå®¡æ ¸ â†’ äººå·¥å¤æ ¸ â†’ æ‰§è¡Œ
ç†ç”±: å¯åœ¨å›¾ä¸­æ’å…¥"ç­‰å¾…äººç±»"èŠ‚ç‚¹

âœ… é«˜å¯é æ€§ç³»ç»Ÿ
åœºæ™¯: é‡‘èé£æ§
ç¤ºä¾‹:
  æ•°æ®éªŒè¯ â†’ é£é™©è¯„ä¼° â†’ åˆè§„æ£€æŸ¥ â†’ äººå·¥å®¡æ‰¹
ç†ç”±: æ¯ä¸€æ­¥éƒ½å¯å®¡è®¡,å¯è¿½æº¯

âŒ ä¸é€‚ç”¨åœºæ™¯:
- åˆ›æ„å†™ä½œ (å¤ªæœºæ¢°)
- å¼€æ”¾å¼å¯¹è¯ (è¿‡äºåƒµåŒ–)
- æ¢ç´¢æ€§ç ”ç©¶ (é™åˆ¶è‡ªç”±åº¦)
```

**æ··åˆä½¿ç”¨å»ºè®®**:

```
åœºæ™¯: æ™ºèƒ½ç ”å‘åŠ©æ‰‹

é˜¶æ®µ1: éœ€æ±‚åˆ†æ (ä½¿ç”¨AutoGen)
- PMã€å·¥ç¨‹å¸ˆã€è®¾è®¡å¸ˆç¾¤èŠ
- è‡ªç”±è®¨è®º,ç¢°æ’æƒ³æ³•
- è¾“å‡º: éœ€æ±‚æ–‡æ¡£v1.0

é˜¶æ®µ2: ä»»åŠ¡æ‰§è¡Œ (ä½¿ç”¨LangGraph)
- å›ºå®šæµç¨‹: å¼€å‘â†’æµ‹è¯•â†’éƒ¨ç½²
- æ¯ä¸ªç¯èŠ‚ç²¾ç¡®æ§åˆ¶
- è¾“å‡º: å¯äº¤ä»˜ä»£ç 

ä¼˜åŠ¿: åˆ›æ„é˜¶æ®µç”¨AutoGen,æ‰§è¡Œé˜¶æ®µç”¨LangGraph
```

---

### è§£ç­”1.2: "æ¶Œç°å¼åä½œ" vs "æ˜¾å¼æ§åˆ¶" å“²å­¦è§£è¯»

#### ğŸŒŠ æ¶Œç°å¼åä½œ (Emergence)

**æ ¸å¿ƒæ€æƒ³**:

```
"æ•´ä½“å¤§äºéƒ¨åˆ†ä¹‹å’Œ"

å®šä¹‰:
é€šè¿‡ç®€å•è§„åˆ™çš„äº¤äº’,
äº§ç”Ÿå¤æ‚çš„ã€ä¸å¯é¢„æµ‹çš„é›†ä½“è¡Œä¸ºã€‚

ç±»æ¯”:
- èšç¾¤: å•ä¸ªèš‚èšå¾ˆç®€å•,ä½†èšç¾¤èƒ½å»ºé€ å¤æ‚å·¢ç©´
- å¤§è„‘: å•ä¸ªç¥ç»å…ƒå¾ˆç®€å•,ä½†å¤§è„‘äº§ç”Ÿæ„è¯†
- å¸‚åœº: ä¸ªä½“ä¹°å–å†³ç­–,æ¶Œç°å‡ºå¸‚åœºä»·æ ¼
```

**åœ¨æ™ºèƒ½ä½“ä¸­çš„ä½“ç°**:

```python
# AutoGençš„æ¶Œç°å¼åä½œ

# ä½ åªå®šä¹‰ç®€å•è§„åˆ™:
agents = [
    AssistantAgent("Researcher", system_message="ä½ æ˜¯ç ”ç©¶å‘˜"),
    AssistantAgent("Critic", system_message="ä½ æ˜¯æ‰¹è¯„å®¶"),
    AssistantAgent("Writer", system_message="ä½ æ˜¯ä½œå®¶")
]

group_chat = GroupChat(
    agents=agents,
    messages=[],
    max_round=50,
    speaker_selection_method="auto"  # ç®€å•è§„åˆ™: AIè‡ªé€‰ä¸‹ä¸€ä¸ª
)

# æ¶Œç°ç»“æœ (ä¸å¯é¢„æµ‹):
# - å¯èƒ½: Researcheræå‡ºå‡è®¾ â†’ Criticè´¨ç–‘ â†’ Researcheræ”¹è¿› â†’ Writeræ€»ç»“
# - ä¹Ÿå¯èƒ½: Researcherå’ŒCriticæ¿€çƒˆäº‰è®º20è½® â†’ Writerä»‹å…¥è°ƒåœ
# - ç”šè‡³: Writerå…ˆæå‡ºæ¡†æ¶ â†’ Researcherå¡«å……å†…å®¹ â†’ Criticæ¶¦è‰²

# ä½ æ— æ³•äº‹å…ˆçŸ¥é“å¯¹è¯ä¼šå¦‚ä½•å‘å±•!
```

**ä¼˜åŠ¿**:

```
âœ… åˆ›é€ åŠ›
- å¯èƒ½äº§ç”Ÿæ„æƒ³ä¸åˆ°çš„è§£å†³æ–¹æ¡ˆ
- è¶…å‡ºè®¾è®¡è€…çš„é¢„æœŸ

âœ… é€‚åº”æ€§
- èƒ½åº”å¯¹æœªçŸ¥æƒ…å†µ
- è‡ªç»„ç»‡ã€è‡ªé€‚åº”

âœ… é²æ£’æ€§
- æ²¡æœ‰å•ç‚¹æ•…éšœ
- ä¸€ä¸ªæ™ºèƒ½ä½“å¤±æ•ˆ,å…¶ä»–å¯è¡¥ä½

å®é™…æ¡ˆä¾‹:
ä»»åŠ¡: "è®¾è®¡ä¸€ä¸ªåˆ›æ–°çš„æ™ºèƒ½å®¶å±…åŠŸèƒ½"

AutoGenç¾¤èŠ:
äº§å“ç»ç†: "æˆ‘ä»¬èƒ½ä¸èƒ½åšä¸ª..."
å·¥ç¨‹å¸ˆ: "ç­‰ç­‰,ä½ è¿™ä¸ªæƒ³æ³•è®©æˆ‘æƒ³åˆ°äº†..."
è®¾è®¡å¸ˆ: "å¦‚æœç»“åˆXXå’ŒYYå‘¢?"
äº§å“ç»ç†: "å“‡!è¿™ä¸ªæ–¹å‘æˆ‘ä¹‹å‰æ²¡æƒ³åˆ°!"

â†’ æ¶Œç°å‡ºäº†ä¸€ä¸ªå…¨æ–°çš„äº§å“æ€è·¯ (è°ä¹Ÿæ²¡æœ‰äº‹å…ˆè®¾è®¡)
```

**åŠ£åŠ¿**:

```
âŒ ä¸å¯é¢„æµ‹
- å¯èƒ½åç¦»ç›®æ ‡
- é™·å…¥æ— æ„ä¹‰çš„å¾ªç¯

âŒ éš¾ä»¥è°ƒè¯•
- é—®é¢˜éš¾ä»¥å¤ç°
- ä¸çŸ¥é“å“ªä¸ªæ™ºèƒ½ä½“å‡ºé”™

âŒ æ•ˆç‡ä¸ç¨³å®š
- æœ‰æ—¶å¾ˆå¿«,æœ‰æ—¶å¾ˆæ…¢
- æˆæœ¬éš¾ä»¥é¢„ä¼°

åé¢æ¡ˆä¾‹:
ä»»åŠ¡: "å†™ä¸€ä¸ªç®€å•çš„å‡½æ•°"

AutoGenç¾¤èŠ:
PM: "éœ€è¦ä¸€ä¸ªæ’åºå‡½æ•°"
å·¥ç¨‹å¸ˆA: "ç”¨å¿«æ’"
å·¥ç¨‹å¸ˆB: "ä¸,å½’å¹¶æ’åºæ›´ç¨³å®š"
å·¥ç¨‹å¸ˆA: "ä½†å¿«æ’å¹³å‡æ›´å¿«"
å·¥ç¨‹å¸ˆB: "ç¨³å®šæ€§æ›´é‡è¦"
... (äº‰è®ºäº†30è½®,å‡½æ•°è¿˜æ²¡å†™)

â†’ æ¶Œç°å‡ºäº†"æ— ä¼‘æ­¢çš„æŠ€æœ¯äº‰è®º" (ä¸æ˜¯ä½ æƒ³è¦çš„)
```

---

#### ğŸ¯ æ˜¾å¼æ§åˆ¶ (Explicit Control)

**æ ¸å¿ƒæ€æƒ³**:

```
"é¢„å…ˆå®šä¹‰æ¯ä¸€æ­¥"

å®šä¹‰:
å¼€å‘è€…æ˜ç¡®è§„åˆ’ç³»ç»Ÿçš„è¡Œä¸ºè·¯å¾„,
æ¯ä¸ªæ­¥éª¤ã€æ¯ä¸ªå†³ç­–ç‚¹éƒ½æ¸…æ™°å¯è§ã€‚

ç±»æ¯”:
- å·¥å‚æµæ°´çº¿: æ¯ä¸ªå·¥åºå›ºå®š
- ç¨‹åºä»£ç : æ¯è¡ŒæŒ‡ä»¤ç¡®å®š
- äº¤é€šè§„åˆ™: çº¢ç¯åœ,ç»¿ç¯è¡Œ
```

**åœ¨æ™ºèƒ½ä½“ä¸­çš„ä½“ç°**:

```python
# LangGraphçš„æ˜¾å¼æ§åˆ¶

# ä½ ç²¾ç¡®å®šä¹‰æ¯ä¸€æ­¥:
workflow = StateGraph(AgentState)

# Step 1: ç†è§£éœ€æ±‚
workflow.add_node("understand", understand_function)

# Step 2: æœç´¢çŸ¥è¯†åº“
workflow.add_node("search", search_function)

# Step 3: ç”Ÿæˆç­”æ¡ˆ
workflow.add_node("generate", generate_function)

# Step 4: è´¨é‡æ£€æŸ¥
workflow.add_node("check_quality", quality_check_function)

# å®šä¹‰æµç¨‹ (å®Œå…¨ç¡®å®š):
workflow.add_edge("understand", "search")
workflow.add_edge("search", "generate")

# æ¡ä»¶è·³è½¬ (ä½ æ§åˆ¶æ¡ä»¶):
workflow.add_conditional_edges(
    "check_quality",
    lambda state: "generate" if state["score"] < 0.8 else END
)

# ä½ çŸ¥é“ç³»ç»Ÿä¼šå¦‚ä½•è¿è¡Œ!
```

**ä¼˜åŠ¿**:

```
âœ… å¯é¢„æµ‹æ€§
- æµç¨‹æ¸…æ™°,ç»“æœç¨³å®š
- ä¾¿äºæµ‹è¯•å’ŒéªŒè¯

âœ… å¯è°ƒè¯•æ€§
- é—®é¢˜å®šä½ç²¾ç¡®
- æ—¥å¿—æ¸…æ™°

âœ… å¯å®¡è®¡æ€§
- æ¯ä¸€æ­¥éƒ½æœ‰è®°å½•
- ç¬¦åˆåˆè§„è¦æ±‚

å®é™…æ¡ˆä¾‹:
ä»»åŠ¡: "å¤„ç†ç”¨æˆ·é€€æ¬¾ç”³è¯·"

LangGraphæµç¨‹:
1. éªŒè¯è®¢å•çŠ¶æ€
2. æ£€æŸ¥é€€æ¬¾æ¡ä»¶
3. è®¡ç®—é€€æ¬¾é‡‘é¢
4. æäº¤è´¢åŠ¡å®¡æ‰¹
5. æ‰§è¡Œé€€æ¬¾
6. å‘é€é€šçŸ¥

æ¯ä¸€æ­¥éƒ½æ˜ç¡®,ä»»ä½•é—®é¢˜éƒ½èƒ½å¿«é€Ÿå®šä½!
```

**åŠ£åŠ¿**:

```
âŒ ç¼ºä¹çµæ´»æ€§
- æ— æ³•åº”å¯¹æœªçŸ¥æƒ…å†µ
- å›ºå®šè·¯å¾„å¯èƒ½ä¸æ˜¯æœ€ä¼˜

âŒ åˆ›é€ åŠ›å—é™
- ä¸ä¼šäº§ç”Ÿ"æƒŠå–œ"
- è¾“å‡ºå¯èƒ½æœºæ¢°

âŒ ç»´æŠ¤æˆæœ¬
- éœ€æ±‚å˜åŒ–æ—¶è¦ä¿®æ”¹å›¾ç»“æ„
- å¤æ‚æµç¨‹éš¾ä»¥ç®¡ç†

åé¢æ¡ˆä¾‹:
ä»»åŠ¡: "å†™ä¸€ç¯‡æœ‰åˆ›æ„çš„æ–‡ç« "

LangGraphæµç¨‹:
1. ç”Ÿæˆæ ‡é¢˜
2. ç”Ÿæˆå¤§çº²
3. å¡«å……ç¬¬ä¸€æ®µ
4. å¡«å……ç¬¬äºŒæ®µ
5. ...
6. ç”Ÿæˆç»“å°¾

â†’ äº§å‡ºçš„æ–‡ç« è™½ç„¶ç»“æ„å®Œæ•´,ä½†ç¼ºå°‘çµæ„Ÿ (å¤ªæœºæ¢°)
```

---

#### âš–ï¸ ä¸¤ç§å“²å­¦çš„æƒè¡¡

**é€‰æ‹©çŸ©é˜µ**:

| åœºæ™¯ç‰¹å¾ | æ¨èå“²å­¦ | ç†ç”± |
|---------|---------|------|
| ä»»åŠ¡ç›®æ ‡æ˜ç¡® | æ˜¾å¼æ§åˆ¶ | ä¸éœ€è¦æ¢ç´¢,ç›´æ¥æ‰§è¡Œ |
| ä»»åŠ¡ç›®æ ‡æ¨¡ç³Š | æ¶Œç°å¼ | é€šè¿‡å¯¹è¯æ˜ç¡®éœ€æ±‚ |
| éœ€è¦åˆ›æ–° | æ¶Œç°å¼ | ç»™æ™ºèƒ½ä½“è‡ªç”±å‘æŒ¥ç©ºé—´ |
| éœ€è¦å¯é  | æ˜¾å¼æ§åˆ¶ | ç¡®ä¿æ¯æ¬¡ç»“æœä¸€è‡´ |
| æ—¶é—´å……è£• | æ¶Œç°å¼ | å…è®¸å¤šè½®æ¢ç´¢ |
| æ—¶é—´ç´§è¿« | æ˜¾å¼æ§åˆ¶ | å›ºå®šæµç¨‹,å¯é¢„æµ‹æ—¶é—´ |
| æˆæœ¬æ•æ„Ÿ | æ˜¾å¼æ§åˆ¶ | Tokenæ¶ˆè€—å¯æ§ |
| è¿½æ±‚è´¨é‡ | æ¶Œç°å¼ | å¤šæ™ºèƒ½ä½“ç¢°æ’æå‡è´¨é‡ |

**æ··åˆç­–ç•¥ (æœ€ä½³å®è·µ)**:

```
ç­–ç•¥: "å¤–å±‚æ˜¾å¼,å†…å±‚æ¶Œç°"

ç¤ºä¾‹: æ™ºèƒ½ç ”å‘åŠ©æ‰‹

å¤–å±‚ (LangGraphæ˜¾å¼æ§åˆ¶):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ éœ€æ±‚åˆ†æé˜¶æ®µ              â”‚ â† æ˜¾å¼èŠ‚ç‚¹1
â”‚  â””â”€ [AutoGenç¾¤èŠ]        â”‚   (å†…å±‚æ¶Œç°)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æ–¹æ¡ˆè®¾è®¡é˜¶æ®µ              â”‚ â† æ˜¾å¼èŠ‚ç‚¹2
â”‚  â””â”€ [AutoGenç¾¤èŠ]        â”‚   (å†…å±‚æ¶Œç°)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ä»£ç å®ç°é˜¶æ®µ              â”‚ â† æ˜¾å¼èŠ‚ç‚¹3
â”‚  â””â”€ [å›ºå®šæµç¨‹]           â”‚   (æ˜¾å¼æ§åˆ¶)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æµ‹è¯•é˜¶æ®µ                  â”‚ â† æ˜¾å¼èŠ‚ç‚¹4
â”‚  â””â”€ [å›ºå®šæµç¨‹]           â”‚   (æ˜¾å¼æ§åˆ¶)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å¥½å¤„:
âœ… å¤§æµç¨‹å¯æ§ (LangGraph)
âœ… åˆ›æ„é˜¶æ®µè‡ªç”± (AutoGen)
âœ… æ‰§è¡Œé˜¶æ®µå¯é  (å›ºå®šæµç¨‹)
```

---

#### ğŸ“ å“²å­¦æ€»ç»“

```
æ¶Œç°å¼åä½œ:
"ç»™æ™ºèƒ½ä½“è‡ªç”±,è®©æ™ºæ…§æ¶Œç°"

é€‚åˆ:
- åˆ›æ„ã€æ¢ç´¢ã€åˆ›æ–°
- å¤æ‚é—®é¢˜æ±‚è§£
- éœ€è¦å¤šè§’åº¦æ€è€ƒ

ç‰¹ç‚¹:
- ç®€å•è§„åˆ™ â†’ å¤æ‚è¡Œä¸º
- ä¸å¯é¢„æµ‹ â†’ å¯èƒ½æƒŠå–œ
- è‡ªç»„ç»‡ â†’ é²æ£’æ€§å¼º

ä»£è¡¨æ¡†æ¶: AutoGen, CAMEL

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

æ˜¾å¼æ§åˆ¶:
"è§„åˆ’æ¯ä¸€æ­¥,ç¡®ä¿å¯é æ‰§è¡Œ"

é€‚åˆ:
- å›ºå®šæµç¨‹ã€å¯é æ€§è¦æ±‚é«˜
- éœ€è¦å®¡è®¡ã€åˆè§„
- æ—¶é—´æˆæœ¬æ•æ„Ÿ

ç‰¹ç‚¹:
- æ˜ç¡®è·¯å¾„ â†’ å¯é¢„æµ‹
- ç²¾ç¡®æ§åˆ¶ â†’ å¯è°ƒè¯•
- å›ºå®šæµç¨‹ â†’ æ•ˆç‡é«˜

ä»£è¡¨æ¡†æ¶: LangGraph

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

æ²¡æœ‰ç»å¯¹çš„å¥½å,åªæœ‰åœºæ™¯çš„é€‚é…!

æœ€ä½³å®è·µ:
1. åˆ›æ„é˜¶æ®µ â†’ æ¶Œç°å¼
2. æ‰§è¡Œé˜¶æ®µ â†’ æ˜¾å¼æ§åˆ¶
3. æ··åˆä½¿ç”¨ â†’ å–é•¿è¡¥çŸ­
```

---

## ä¹ é¢˜2: AutoGenæ‰©å±•å®è·µ

### é¢˜ç›®

åœ¨6.2èŠ‚çš„ `AutoGen` æ¡ˆä¾‹ä¸­,æˆ‘ä»¬æ„å»ºäº†ä¸€ä¸ª"è½¯ä»¶å¼€å‘å›¢é˜Ÿ"ã€‚è¯·åŸºäºæ­¤æ¡ˆä¾‹è¿›è¡Œæ‰©å±•æ€è€ƒ:

> **æç¤º**:è¿™æ˜¯ä¸€é“åŠ¨æ‰‹å®è·µé¢˜,å»ºè®®å®é™…æ“ä½œ

- å½“å‰çš„å›¢é˜Ÿä½¿ç”¨ `RoundRobinGroupChat`(è½®è¯¢ç¾¤èŠ)æ¨¡å¼,æ™ºèƒ½ä½“æŒ‰å›ºå®šé¡ºåºå‘è¨€ã€‚å¦‚æœéœ€æ±‚å˜æ›´,å·¥ç¨‹å¸ˆçš„ä»£ç éœ€è¦è¿”å›ç»™äº§å“ç»ç†é‡æ–°å®¡æ ¸,åº”è¯¥å¦‚ä½•ä¿®æ”¹åä½œæµç¨‹?è¯·è®¾è®¡ä¸€ä¸ªæ”¯æŒ"åŠ¨æ€å›é€€"çš„æœºåˆ¶ã€‚
- åœ¨æ¡ˆä¾‹ä¸­,æˆ‘ä»¬é€šè¿‡ `System Message` ä¸ºæ¯ä¸ªæ™ºèƒ½ä½“å®šä¹‰äº†è§’è‰²å’ŒèŒè´£ã€‚è¯·å°è¯•ä¸ºè¿™ä¸ªå›¢é˜Ÿæ·»åŠ ä¸€ä¸ªæ–°è§’è‰²"æµ‹è¯•å·¥ç¨‹å¸ˆ"(`Quality Assurance`),å¹¶è®¾è®¡å…¶ç³»ç»Ÿæ¶ˆæ¯,ä½¿å…¶èƒ½å¤Ÿåœ¨ä»£ç å®¡æŸ¥åæ‰§è¡Œè‡ªåŠ¨åŒ–æµ‹è¯•ã€‚
- `AutoGen` çš„å¯¹è¯å¼åä½œå­˜åœ¨å¯èƒ½çš„ä¸ç¨³å®šæ€§,å¯èƒ½å¯¼è‡´å¯¹è¯åç¦»ä¸»é¢˜æˆ–é™·å…¥å¾ªç¯ã€‚è¯·æ€è€ƒ:å¦‚ä½•è®¾è®¡ä¸€å¥—"å¯¹è¯è´¨é‡ç›‘æ§"æœºåˆ¶,åœ¨æ£€æµ‹åˆ°å¼‚å¸¸æ—¶åŠæ—¶å¹²é¢„?

---

### è§£ç­”2.1: åŠ¨æ€å›é€€æœºåˆ¶è®¾è®¡

#### ğŸ¤” é—®é¢˜åˆ†æ

**å½“å‰RoundRobinGroupChatçš„å±€é™**:

```
å›ºå®šè½®è¯¢é¡ºåº:
PM â†’ å·¥ç¨‹å¸ˆ â†’ å®¡æŸ¥å‘˜ â†’ ç”¨æˆ·ä»£ç† â†’ PM â†’ ...
 1      2        3         4        5

é—®é¢˜åœºæ™¯:
PM (è½®1): "éœ€æ±‚: ç”¨æˆ·ç™»å½•åŠŸèƒ½"
å·¥ç¨‹å¸ˆ (è½®2): "ä»£ç å·²å®Œæˆ [ä»£ç ]"
å®¡æŸ¥å‘˜ (è½®3): "å‘ç°é—®é¢˜: ç¼ºå°‘å¯†ç åŠ å¯†!"
ç”¨æˆ·ä»£ç† (è½®4): "ç­‰å¾…ä¿®å¤..."
PM (è½®5): "æˆ‘ç°åœ¨æ‰çœ‹åˆ°å®¡æŸ¥æ„è§??"

é—®é¢˜:
âŒ å®¡æŸ¥å‘˜å‘ç°é—®é¢˜,ä½†è¦ç­‰2è½®æ‰èƒ½å›åˆ°å·¥ç¨‹å¸ˆ
âŒ PMæ— æ³•ç«‹å³é‡æ–°å®¡æ ¸éœ€æ±‚
âŒ æµç¨‹åƒµåŒ–,æ— æ³•åŠ¨æ€è°ƒæ•´
```

---

#### ğŸ’¡ è§£å†³æ–¹æ¡ˆä¸€: ä½¿ç”¨SelectorGroupChat (æ™ºèƒ½é€‰æ‹©)

**æ ¸å¿ƒæ€æƒ³**: è®©AIè‡ªåŠ¨é€‰æ‹©ä¸‹ä¸€ä¸ªå‘è¨€è€…,è€Œéå›ºå®šé¡ºåº

```python
from autogen import AssistantAgent, UserProxyAgent, GroupChat, GroupChatManager

# 1. å®šä¹‰æ™ºèƒ½ä½“ (ä¸åŸæ¡ˆä¾‹ç›¸åŒ)
pm = AssistantAgent(
    name="ProductManager",
    system_message="""ä½ æ˜¯èµ„æ·±äº§å“ç»ç†ã€‚
    èŒè´£:
    - åˆ†æå’Œæ˜ç¡®éœ€æ±‚
    - å®¡æ ¸æœ€ç»ˆæ–¹æ¡ˆæ˜¯å¦æ»¡è¶³éœ€æ±‚
    - å¦‚æœä¸æ»¡è¶³,æ˜ç¡®æŒ‡å‡ºé—®é¢˜å¹¶è¦æ±‚ä¿®æ”¹

    è§„åˆ™:
    - å½“å®¡æŸ¥å‘˜æå‡ºé—®é¢˜æ—¶,ä½ éœ€è¦é‡æ–°è¯„ä¼°éœ€æ±‚
    - å½“ä»£ç ä¿®æ”¹å,ä½ è¦éªŒè¯æ˜¯å¦è§£å†³äº†é—®é¢˜
    """
)

engineer = AssistantAgent(
    name="Engineer",
    system_message="""ä½ æ˜¯é«˜çº§å·¥ç¨‹å¸ˆã€‚
    èŒè´£:
    - æ ¹æ®éœ€æ±‚ç¼–å†™ä»£ç 
    - æ ¹æ®å®¡æŸ¥æ„è§ä¿®æ”¹ä»£ç 
    - è§£é‡ŠæŠ€æœ¯å†³ç­–

    è§„åˆ™:
    - å½“å®¡æŸ¥å‘˜æŒ‡å‡ºé—®é¢˜æ—¶,ç«‹å³ä¿®å¤
    - ä¿®å¤åä¸»åŠ¨è¯·æ±‚PMç¡®è®¤
    """
)

reviewer = AssistantAgent(
    name="CodeReviewer",
    system_message="""ä½ æ˜¯ä»£ç å®¡æŸ¥ä¸“å®¶ã€‚
    èŒè´£:
    - å®¡æŸ¥ä»£ç è´¨é‡ã€å®‰å…¨æ€§ã€æ€§èƒ½
    - å‘ç°é—®é¢˜æ—¶,è¦æ±‚å·¥ç¨‹å¸ˆä¿®æ”¹
    - éªŒè¯ä¿®æ”¹æ˜¯å¦è§£å†³äº†é—®é¢˜

    è§„åˆ™:
    - å‘ç°é—®é¢˜æ—¶,ç›´æ¥@Engineerè¦æ±‚ä¿®æ”¹
    - ä¸è¦ç›´æ¥è¿›å…¥ä¸‹ä¸€è½®,è¦ç­‰å¾…ä¿®å¤
    """
)

user_proxy = UserProxyAgent(
    name="User",
    human_input_mode="NEVER",
    system_message="ä»£è¡¨ç”¨æˆ·,æœ€ç»ˆç¡®è®¤æ˜¯å¦æ»¡è¶³éœ€æ±‚"
)

# 2. åˆ›å»ºæ™ºèƒ½é€‰æ‹©çš„GroupChat
group_chat = GroupChat(
    agents=[pm, engineer, reviewer, user_proxy],
    messages=[],
    max_round=50,
    speaker_selection_method="auto"  # å…³é”®: è‡ªåŠ¨é€‰æ‹©!
)

# 3. åˆ›å»ºç®¡ç†å™¨
manager = GroupChatManager(
    groupchat=group_chat,
    llm_config={"model": "gpt-4"}
)

# 4. å¯åŠ¨å¯¹è¯
user_proxy.initiate_chat(
    manager,
    message="éœ€æ±‚: å®ç°ç”¨æˆ·ç™»å½•åŠŸèƒ½,è¦æ±‚å¯†ç åŠ å¯†å­˜å‚¨"
)
```

**è¿è¡Œæ•ˆæœ**:

```
å®é™…å¯¹è¯æµç¨‹ (åŠ¨æ€è°ƒæ•´):

è½®1: PM â†’ "éœ€æ±‚æ˜ç¡®: ç”¨æˆ·ç™»å½•,å¯†ç å¿…é¡»åŠ å¯†"
è½®2: Engineer â†’ "ä»£ç å®Œæˆ [å±•ç¤ºä»£ç ]"
è½®3: Reviewer â†’ "å‘ç°é—®é¢˜: å¯†ç æœªåŠ å¯†! @Engineer è¯·ä¿®æ”¹"
è½®4: Engineer â†’ "å·²ä¿®æ”¹,æ·»åŠ bcryptåŠ å¯† [æ–°ä»£ç ]"  â† åŠ¨æ€å›é€€!
è½®5: Reviewer â†’ "éªŒè¯é€šè¿‡,ä»£ç è´¨é‡è‰¯å¥½"
è½®6: PM â†’ "ç¡®è®¤æ»¡è¶³éœ€æ±‚"
è½®7: User â†’ "TERMINATE"

âœ… å®¡æŸ¥å‘˜å‘ç°é—®é¢˜å,AIè‡ªåŠ¨é€‰æ‹©å·¥ç¨‹å¸ˆç«‹å³ä¿®å¤
âœ… æ— éœ€ç­‰å¾…å®Œæ•´è½®æ¬¡
âœ… æµç¨‹åŠ¨æ€é€‚åº”å®é™…éœ€è¦
```

---

#### ğŸ’¡ è§£å†³æ–¹æ¡ˆäºŒ: è‡ªå®šä¹‰Speaker Selection Function

**æ›´ç²¾ç»†çš„æ§åˆ¶**: æ‰‹åŠ¨å®šä¹‰é€‰æ‹©é€»è¾‘

```python
def custom_speaker_selection(last_speaker, groupchat):
    """
    è‡ªå®šä¹‰å‘è¨€è€…é€‰æ‹©é€»è¾‘

    è§„åˆ™:
    1. å¦‚æœRevieweræå‡ºé—®é¢˜ â†’ é€‰æ‹©Engineer
    2. å¦‚æœEngineerä¿®æ”¹å®Œæˆ â†’ é€‰æ‹©Reviewerå¤æŸ¥
    3. å¦‚æœRevieweré€šè¿‡ â†’ é€‰æ‹©PMç¡®è®¤
    4. å¦‚æœPMç¡®è®¤ â†’ é€‰æ‹©Userç»ˆæ­¢
    5. å¦‚æœPMä¸æ»¡æ„ â†’ é€‰æ‹©Engineeré‡åš
    """
    messages = groupchat.messages
    last_message = messages[-1] if messages else None

    if not last_message:
        return pm  # åˆå§‹ç”±PMå‘èµ·

    last_speaker_name = last_speaker.name
    last_content = last_message.get("content", "")

    # è§„åˆ™1: Reviewerå‘ç°é—®é¢˜ â†’ Engineerä¿®å¤
    if last_speaker_name == "CodeReviewer":
        if "é—®é¢˜" in last_content or "é”™è¯¯" in last_content or "å»ºè®®" in last_content:
            print("[æµç¨‹æ§åˆ¶] Reviewerå‘ç°é—®é¢˜,è½¬ç»™Engineerä¿®å¤")
            return engineer
        else:
            print("[æµç¨‹æ§åˆ¶] Revieweré€šè¿‡,è½¬ç»™PMç¡®è®¤")
            return pm

    # è§„åˆ™2: Engineerå®Œæˆä¿®æ”¹ â†’ Reviewerå¤æŸ¥
    elif last_speaker_name == "Engineer":
        if "å·²ä¿®æ”¹" in last_content or "å·²ä¿®å¤" in last_content:
            print("[æµç¨‹æ§åˆ¶] Engineerå®Œæˆä¿®æ”¹,è½¬ç»™Reviewerå¤æŸ¥")
            return reviewer
        else:
            print("[æµç¨‹æ§åˆ¶] Engineeråˆæ¬¡æäº¤,è½¬ç»™Reviewerå®¡æŸ¥")
            return reviewer

    # è§„åˆ™3: PMè¯„ä¼° â†’ Engineeræ‰§è¡Œ æˆ– Reviewerå®¡æŸ¥
    elif last_speaker_name == "ProductManager":
        if "ä¿®æ”¹" in last_content or "ä¸æ»¡è¶³" in last_content:
            print("[æµç¨‹æ§åˆ¶] PMè¦æ±‚ä¿®æ”¹,è½¬ç»™Engineer")
            return engineer
        else:
            print("[æµç¨‹æ§åˆ¶] PMç¡®è®¤éœ€æ±‚,è½¬ç»™Userç»ˆæ­¢")
            return user_proxy

    # è§„åˆ™4: Userç¡®è®¤ â†’ ç»ˆæ­¢
    elif last_speaker_name == "User":
        return None  # ç»ˆæ­¢å¯¹è¯

    # é»˜è®¤: è½®è¯¢
    return None  # è®©AutoGenè‡ªåŠ¨é€‰æ‹©

# ä½¿ç”¨è‡ªå®šä¹‰é€‰æ‹©å‡½æ•°
group_chat = GroupChat(
    agents=[pm, engineer, reviewer, user_proxy],
    messages=[],
    max_round=50,
    speaker_selection_method=custom_speaker_selection  # è‡ªå®šä¹‰å‡½æ•°
)
```

**è¿è¡Œæ•ˆæœ**:

```
[æµç¨‹æ§åˆ¶] PMç¡®è®¤éœ€æ±‚,è½¬ç»™Engineer
Engineer: "ä»£ç å·²å®Œæˆ..."

[æµç¨‹æ§åˆ¶] Engineeråˆæ¬¡æäº¤,è½¬ç»™Reviewerå®¡æŸ¥
Reviewer: "å‘ç°é—®é¢˜: ç¼ºå°‘è¾“å…¥éªŒè¯"

[æµç¨‹æ§åˆ¶] Reviewerå‘ç°é—®é¢˜,è½¬ç»™Engineerä¿®å¤
Engineer: "å·²ä¿®æ”¹,æ·»åŠ äº†å‚æ•°éªŒè¯..."

[æµç¨‹æ§åˆ¶] Engineerå®Œæˆä¿®æ”¹,è½¬ç»™Reviewerå¤æŸ¥
Reviewer: "éªŒè¯é€šè¿‡"

[æµç¨‹æ§åˆ¶] Revieweré€šè¿‡,è½¬ç»™PMç¡®è®¤
PM: "æ»¡è¶³éœ€æ±‚"

[æµç¨‹æ§åˆ¶] PMç¡®è®¤éœ€æ±‚,è½¬ç»™Userç»ˆæ­¢
User: "TERMINATE"

âœ… æ¯ä¸€æ­¥éƒ½æŒ‰ç…§é¢„å®šä¹‰çš„ä¸šåŠ¡é€»è¾‘æµè½¬
âœ… æ”¯æŒåŠ¨æ€å›é€€å’Œå¾ªç¯
```

---

#### ğŸ’¡ è§£å†³æ–¹æ¡ˆä¸‰: çŠ¶æ€æœºæ¨¡å¼ (æœ€å¯æ§)

**æ€æƒ³**: å°†åä½œæµç¨‹å»ºæ¨¡ä¸ºçŠ¶æ€æœº

```python
from enum import Enum

class WorkflowState(Enum):
    REQUIREMENT_ANALYSIS = "éœ€æ±‚åˆ†æ"
    CODING = "ç¼–ç "
    CODE_REVIEW = "ä»£ç å®¡æŸ¥"
    PM_CONFIRMATION = "äº§å“ç¡®è®¤"
    COMPLETED = "å®Œæˆ"

class StatefulGroupChat:
    def __init__(self, agents):
        self.agents = {agent.name: agent for agent in agents}
        self.state = WorkflowState.REQUIREMENT_ANALYSIS
        self.messages = []
        self.revision_count = 0  # è¿½è¸ªä¿®æ”¹æ¬¡æ•°

    def next_speaker(self, last_speaker, last_message):
        """
        åŸºäºå½“å‰çŠ¶æ€å’Œä¸Šä¸€æ¡æ¶ˆæ¯,å†³å®šä¸‹ä¸€ä¸ªå‘è¨€è€…
        """
        content = last_message.get("content", "")

        # çŠ¶æ€: éœ€æ±‚åˆ†æ
        if self.state == WorkflowState.REQUIREMENT_ANALYSIS:
            if "éœ€æ±‚æ˜ç¡®" in content or "å¼€å§‹ç¼–ç " in content:
                self.state = WorkflowState.CODING
                print(f"[çŠ¶æ€è½¬æ¢] {self.state.value}")
                return self.agents["Engineer"]
            else:
                return self.agents["ProductManager"]

        # çŠ¶æ€: ç¼–ç 
        elif self.state == WorkflowState.CODING:
            if "ä»£ç å®Œæˆ" in content or "ä»£ç å¦‚ä¸‹" in content:
                self.state = WorkflowState.CODE_REVIEW
                print(f"[çŠ¶æ€è½¬æ¢] {self.state.value}")
                return self.agents["CodeReviewer"]
            else:
                return self.agents["Engineer"]

        # çŠ¶æ€: ä»£ç å®¡æŸ¥
        elif self.state == WorkflowState.CODE_REVIEW:
            if "é—®é¢˜" in content or "å»ºè®®ä¿®æ”¹" in content:
                # å‘ç°é—®é¢˜,å›é€€åˆ°ç¼–ç çŠ¶æ€
                self.state = WorkflowState.CODING
                self.revision_count += 1
                print(f"[çŠ¶æ€å›é€€] {self.state.value} (ç¬¬{self.revision_count}æ¬¡ä¿®æ”¹)")

                # å®‰å…¨æ£€æŸ¥: é¿å…æ— é™å¾ªç¯
                if self.revision_count > 5:
                    print("[è­¦å‘Š] ä¿®æ”¹æ¬¡æ•°è¿‡å¤š,è½¬äººå·¥ä»‹å…¥")
                    return self.agents["User"]

                return self.agents["Engineer"]

            elif "é€šè¿‡" in content or "å®¡æŸ¥é€šè¿‡" in content:
                self.state = WorkflowState.PM_CONFIRMATION
                print(f"[çŠ¶æ€è½¬æ¢] {self.state.value}")
                return self.agents["ProductManager"]
            else:
                return self.agents["CodeReviewer"]

        # çŠ¶æ€: PMç¡®è®¤
        elif self.state == WorkflowState.PM_CONFIRMATION:
            if "ä¸æ»¡è¶³" in content or "é‡æ–°" in content:
                # PMä¸æ»¡æ„,å›é€€åˆ°éœ€æ±‚åˆ†æ
                self.state = WorkflowState.REQUIREMENT_ANALYSIS
                print(f"[çŠ¶æ€å›é€€] {self.state.value}")
                return self.agents["ProductManager"]

            elif "ç¡®è®¤" in content or "æ»¡è¶³éœ€æ±‚" in content:
                self.state = WorkflowState.COMPLETED
                print(f"[çŠ¶æ€è½¬æ¢] {self.state.value}")
                return self.agents["User"]
            else:
                return self.agents["ProductManager"]

        # çŠ¶æ€: å®Œæˆ
        elif self.state == WorkflowState.COMPLETED:
            return None  # ç»ˆæ­¢

        return None

# ä½¿ç”¨æ–¹æ³•
stateful_chat = StatefulGroupChat(
    agents=[pm, engineer, reviewer, user_proxy]
)

group_chat = GroupChat(
    agents=[pm, engineer, reviewer, user_proxy],
    messages=[],
    max_round=50,
    speaker_selection_method=stateful_chat.next_speaker
)
```

**è¿è¡Œæ•ˆæœ**:

```
[çŠ¶æ€è½¬æ¢] éœ€æ±‚åˆ†æ
PM: "éœ€æ±‚æ˜ç¡®: ç”¨æˆ·ç™»å½•..."

[çŠ¶æ€è½¬æ¢] ç¼–ç 
Engineer: "ä»£ç å®Œæˆ..."

[çŠ¶æ€è½¬æ¢] ä»£ç å®¡æŸ¥
Reviewer: "å‘ç°é—®é¢˜: ç¼ºå°‘åŠ å¯†"

[çŠ¶æ€å›é€€] ç¼–ç  (ç¬¬1æ¬¡ä¿®æ”¹)  â† åŠ¨æ€å›é€€!
Engineer: "å·²ä¿®æ”¹,æ·»åŠ bcrypt..."

[çŠ¶æ€è½¬æ¢] ä»£ç å®¡æŸ¥
Reviewer: "å®¡æŸ¥é€šè¿‡"

[çŠ¶æ€è½¬æ¢] äº§å“ç¡®è®¤
PM: "ç¡®è®¤æ»¡è¶³éœ€æ±‚"

[çŠ¶æ€è½¬æ¢] å®Œæˆ
User: "TERMINATE"

âœ… çŠ¶æ€æ¸…æ™°,æµè½¬å¯æ§
âœ… æ”¯æŒå¤šæ¬¡å›é€€
âœ… è‡ªåŠ¨æ£€æµ‹æ— é™å¾ªç¯
```

---

#### ğŸ“Š ä¸‰ç§æ–¹æ¡ˆå¯¹æ¯”

| æ–¹æ¡ˆ | çµæ´»æ€§ | å¯æ§æ€§ | å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|--------|--------|--------|---------|
| æ™ºèƒ½é€‰æ‹©(auto) | â­â­â­â­â­ | â­â­â­ | â­ | ä¿¡ä»»AI,è¿½æ±‚è‡ªç„¶æµç¨‹ |
| è‡ªå®šä¹‰å‡½æ•° | â­â­â­â­ | â­â­â­â­ | â­â­â­ | éœ€è¦ä¸šåŠ¡è§„åˆ™,ä½†ä¿æŒçµæ´» |
| çŠ¶æ€æœº | â­â­â­ | â­â­â­â­â­ | â­â­â­â­ | ä¸¥æ ¼æµç¨‹æ§åˆ¶,å¯å®¡è®¡ |

**æ¨è**: æ ¹æ®å®é™…éœ€æ±‚é€‰æ‹©
- å¿«é€ŸåŸå‹: æ™ºèƒ½é€‰æ‹©
- ä¼ä¸šåº”ç”¨: è‡ªå®šä¹‰å‡½æ•°
- å…³é”®ä¸šåŠ¡: çŠ¶æ€æœº

---

### è§£ç­”2.2: æ·»åŠ æµ‹è¯•å·¥ç¨‹å¸ˆè§’è‰²

#### ğŸ¯ è§’è‰²è®¾è®¡

**æµ‹è¯•å·¥ç¨‹å¸ˆ(QA)çš„èŒè´£**:

```
æ ¸å¿ƒèŒè´£:
1. åœ¨ä»£ç å®¡æŸ¥é€šè¿‡å,æ‰§è¡Œè‡ªåŠ¨åŒ–æµ‹è¯•
2. éªŒè¯ä»£ç åŠŸèƒ½æ­£ç¡®æ€§
3. æ£€æŸ¥è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸æƒ…å†µ
4. å‘ç°Bugæ—¶,è¦æ±‚å·¥ç¨‹å¸ˆä¿®å¤

å·¥ä½œæµç¨‹:
CodeRevieweré€šè¿‡ â†’ QAæµ‹è¯• â†’ æµ‹è¯•é€šè¿‡ â†’ PMç¡®è®¤
                              â†“ æµ‹è¯•å¤±è´¥
                         Engineerä¿®å¤ â†’ QAå¤æµ‹
```

---

#### ğŸ’» å®Œæ•´å®ç°

```python
from autogen import AssistantAgent, UserProxyAgent, GroupChat, GroupChatManager
import json

# 1. å®šä¹‰QAæ™ºèƒ½ä½“
qa_engineer = AssistantAgent(
    name="QA_Engineer",
    system_message="""ä½ æ˜¯èµ„æ·±æµ‹è¯•å·¥ç¨‹å¸ˆ (Quality Assurance Engineer)ã€‚

## æ ¸å¿ƒèŒè´£
1. åœ¨ä»£ç å®¡æŸ¥é€šè¿‡å,æ‰§è¡Œè‡ªåŠ¨åŒ–æµ‹è¯•
2. è®¾è®¡æµ‹è¯•ç”¨ä¾‹,è¦†ç›–æ­£å¸¸æµç¨‹å’Œè¾¹ç•Œæƒ…å†µ
3. éªŒè¯ä»£ç åŠŸèƒ½ã€æ€§èƒ½ã€å®‰å…¨æ€§
4. å‘ç°é—®é¢˜æ—¶,è¯¦ç»†æŠ¥å‘ŠBugå¹¶è¦æ±‚ä¿®å¤

## å·¥ä½œæµç¨‹
1. ç­‰å¾…CodeReviewerå®¡æŸ¥é€šè¿‡åä»‹å…¥
2. åˆ†æä»£ç ,è®¾è®¡æµ‹è¯•ç”¨ä¾‹
3. æ‰§è¡Œæµ‹è¯• (å¯ä»¥è°ƒç”¨test_codeå·¥å…·)
4. æ ¹æ®æµ‹è¯•ç»“æœ:
   - é€šè¿‡: è½¬äº¤ProductManagerç¡®è®¤
   - å¤±è´¥: è¯¦ç»†æŠ¥å‘ŠBug,è¦æ±‚Engineerä¿®å¤

## æµ‹è¯•ç”¨ä¾‹è®¾è®¡åŸåˆ™
- æ­£å¸¸åœºæ™¯: éªŒè¯åŸºæœ¬åŠŸèƒ½
- è¾¹ç•Œæ¡ä»¶: ç©ºè¾“å…¥ã€æå¤§å€¼ã€æå°å€¼
- å¼‚å¸¸æƒ…å†µ: é”™è¯¯è¾“å…¥ã€ç½‘ç»œå¼‚å¸¸ã€æƒé™é—®é¢˜
- å®‰å…¨æ€§: SQLæ³¨å…¥ã€XSSã€CSRFç­‰

## è¾“å‡ºæ ¼å¼
æµ‹è¯•æŠ¥å‘Šæ ¼å¼:
```
## æµ‹è¯•æŠ¥å‘Š

### æµ‹è¯•ç”¨ä¾‹
1. [ç”¨ä¾‹åç§°]
   - è¾“å…¥: ...
   - é¢„æœŸ: ...
   - å®é™…: ...
   - ç»“æœ: âœ… é€šè¿‡ / âŒ å¤±è´¥

### æ€»ç»“
- é€šè¿‡: Xä¸ª
- å¤±è´¥: Yä¸ª
- ç»“è®º: [é€šè¿‡/éœ€è¦ä¿®å¤]

### Bugåˆ—è¡¨ (å¦‚æœ‰)
1. [Bugæè¿°]
   - ä¸¥é‡çº§åˆ«: P0/P1/P2
   - å¤ç°æ­¥éª¤: ...
   - å»ºè®®ä¿®å¤: ...
```
""",
    llm_config={
        "model": "gpt-4",
        "functions": [
            {
                "name": "run_tests",
                "description": "æ‰§è¡Œè‡ªåŠ¨åŒ–æµ‹è¯•",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "code": {
                            "type": "string",
                            "description": "è¦æµ‹è¯•çš„ä»£ç "
                        },
                        "test_cases": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "name": {"type": "string"},
                                    "input": {"type": "string"},
                                    "expected": {"type": "string"}
                                }
                            },
                            "description": "æµ‹è¯•ç”¨ä¾‹åˆ—è¡¨"
                        }
                    },
                    "required": ["code", "test_cases"]
                }
            }
        ]
    }
)

# 2. æ›´æ–°å…¶ä»–æ™ºèƒ½ä½“çš„System Message

pm = AssistantAgent(
    name="ProductManager",
    system_message="""ä½ æ˜¯èµ„æ·±äº§å“ç»ç†ã€‚

èŒè´£:
- åˆ†æå’Œæ˜ç¡®éœ€æ±‚
- ç­‰å¾…QAæµ‹è¯•é€šè¿‡å,ç¡®è®¤æ˜¯å¦æ»¡è¶³éœ€æ±‚
- å¦‚æœä¸æ»¡è¶³,è¦æ±‚ä¿®æ”¹

æµç¨‹:
éœ€æ±‚æ˜ç¡® â†’ Engineerç¼–ç  â†’ CodeReviewerå®¡æŸ¥ â†’ QAæµ‹è¯• â†’ ä½ ç¡®è®¤
"""
)

engineer = AssistantAgent(
    name="Engineer",
    system_message="""ä½ æ˜¯é«˜çº§å·¥ç¨‹å¸ˆã€‚

èŒè´£:
- æ ¹æ®éœ€æ±‚ç¼–å†™ä»£ç 
- æ ¹æ®CodeReviewerçš„æ„è§ä¿®æ”¹ä»£ç 
- æ ¹æ®QAçš„æµ‹è¯•æŠ¥å‘Šä¿®å¤Bug

æµç¨‹:
æ¥æ”¶éœ€æ±‚ â†’ ç¼–ç  â†’ æ¥å—å®¡æŸ¥ â†’ æ¥å—æµ‹è¯• â†’ ä¿®å¤Bug (å¦‚æœ‰)
"""
)

reviewer = AssistantAgent(
    name="CodeReviewer",
    system_message="""ä½ æ˜¯ä»£ç å®¡æŸ¥ä¸“å®¶ã€‚

èŒè´£:
- å®¡æŸ¥ä»£ç è´¨é‡ã€å®‰å…¨æ€§ã€æ€§èƒ½
- é€šè¿‡å,è½¬äº¤QA_Engineeræµ‹è¯•

æµç¨‹:
æ¥æ”¶ä»£ç  â†’ å®¡æŸ¥ â†’ é€šè¿‡å@QA_Engineeræµ‹è¯•
"""
)

user_proxy = UserProxyAgent(
    name="User",
    human_input_mode="NEVER",
    system_message="ä»£è¡¨ç”¨æˆ·,æœ€ç»ˆç¡®è®¤",
    function_map={
        "run_tests": lambda code, test_cases: run_tests_impl(code, test_cases)
    }
)

# 3. å®ç°æµ‹è¯•æ‰§è¡Œå‡½æ•°
def run_tests_impl(code: str, test_cases: list) -> dict:
    """
    å®é™…æ‰§è¡Œæµ‹è¯•çš„å‡½æ•°
    (è¿™é‡Œç®€åŒ–ä¸ºæ¨¡æ‹Ÿ,å®é™…åº”è¯¥æ‰§è¡ŒçœŸå®æµ‹è¯•)
    """
    results = []
    passed = 0
    failed = 0

    for test_case in test_cases:
        # æ¨¡æ‹Ÿæµ‹è¯•æ‰§è¡Œ
        # å®é™…åº”è¯¥: exec(code) ç„¶åè¿è¡Œæµ‹è¯•
        try:
            # ç®€åŒ–: å‡è®¾ä»£ç æ­£ç¡®
            result = {
                "name": test_case["name"],
                "status": "âœ… é€šè¿‡",
                "input": test_case["input"],
                "expected": test_case["expected"],
                "actual": test_case["expected"]  # ç®€åŒ–
            }
            passed += 1
        except Exception as e:
            result = {
                "name": test_case["name"],
                "status": "âŒ å¤±è´¥",
                "input": test_case["input"],
                "expected": test_case["expected"],
                "actual": f"Error: {str(e)}"
            }
            failed += 1

        results.append(result)

    return {
        "results": results,
        "summary": {
            "total": len(test_cases),
            "passed": passed,
            "failed": failed,
            "pass_rate": f"{(passed/len(test_cases)*100):.1f}%"
        }
    }

# 4. è‡ªå®šä¹‰Speaker Selection (åŒ…å«QA)
def speaker_selection_with_qa(last_speaker, groupchat):
    """
    åŒ…å«QAçš„å‘è¨€è€…é€‰æ‹©é€»è¾‘
    """
    messages = groupchat.messages
    last_message = messages[-1] if messages else None

    if not last_message:
        return pm

    last_speaker_name = last_speaker.name
    last_content = last_message.get("content", "")

    # CodeRevieweré€šè¿‡ â†’ QAæµ‹è¯•
    if last_speaker_name == "CodeReviewer":
        if "é€šè¿‡" in last_content and "é—®é¢˜" not in last_content:
            print("[æµç¨‹æ§åˆ¶] ä»£ç å®¡æŸ¥é€šè¿‡,è½¬ç»™QAæµ‹è¯•")
            return qa_engineer  # æ–°å¢!
        else:
            print("[æµç¨‹æ§åˆ¶] ä»£ç å®¡æŸ¥å‘ç°é—®é¢˜,è½¬ç»™Engineer")
            return engineer

    # QAæµ‹è¯•å®Œæˆ â†’ PMç¡®è®¤ æˆ– Engineerä¿®å¤
    elif last_speaker_name == "QA_Engineer":
        if "é€šè¿‡" in last_content or "æµ‹è¯•é€šè¿‡" in last_content:
            print("[æµç¨‹æ§åˆ¶] QAæµ‹è¯•é€šè¿‡,è½¬ç»™PMç¡®è®¤")
            return pm
        else:
            print("[æµç¨‹æ§åˆ¶] QAå‘ç°Bug,è½¬ç»™Engineerä¿®å¤")
            return engineer

    # Engineerä¿®æ”¹å â†’ é‡æ–°å®¡æŸ¥
    elif last_speaker_name == "Engineer":
        if "å·²ä¿®å¤" in last_content or "å·²ä¿®æ”¹" in last_content:
            print("[æµç¨‹æ§åˆ¶] Engineerå®Œæˆä¿®æ”¹,è½¬ç»™CodeReviewerå¤å®¡")
            return reviewer
        else:
            print("[æµç¨‹æ§åˆ¶] Engineeré¦–æ¬¡æäº¤,è½¬ç»™CodeReviewerå®¡æŸ¥")
            return reviewer

    # PMç¡®è®¤ â†’ å®Œæˆ
    elif last_speaker_name == "ProductManager":
        if "ç¡®è®¤" in last_content or "æ»¡è¶³" in last_content:
            print("[æµç¨‹æ§åˆ¶] PMç¡®è®¤,ä»»åŠ¡å®Œæˆ")
            return user_proxy
        else:
            print("[æµç¨‹æ§åˆ¶] PMè¦æ±‚ä¿®æ”¹,è½¬ç»™Engineer")
            return engineer

    return None

# 5. åˆ›å»ºGroupChat
group_chat = GroupChat(
    agents=[pm, engineer, reviewer, qa_engineer, user_proxy],  # åŒ…å«QA
    messages=[],
    max_round=100,
    speaker_selection_method=speaker_selection_with_qa
)

manager = GroupChatManager(
    groupchat=group_chat,
    llm_config={"model": "gpt-4"}
)

# 6. å¯åŠ¨å¯¹è¯
user_proxy.initiate_chat(
    manager,
    message="éœ€æ±‚: å®ç°ç”¨æˆ·æ³¨å†ŒåŠŸèƒ½,åŒ…æ‹¬é‚®ç®±éªŒè¯å’Œå¯†ç å¼ºåº¦æ£€æŸ¥"
)
```

---

#### ğŸ¬ è¿è¡Œæ•ˆæœç¤ºä¾‹

```
[æµç¨‹æ§åˆ¶] åˆå§‹ç”±PMå‘èµ·
PM: """
éœ€æ±‚æ˜ç¡®:
1. ç”¨æˆ·æ³¨å†ŒåŠŸèƒ½
2. é‚®ç®±æ ¼å¼éªŒè¯
3. å¯†ç å¼ºåº¦: è‡³å°‘8ä½,åŒ…å«å­—æ¯+æ•°å­—
4. å¯†ç éœ€åŠ å¯†å­˜å‚¨
"""

[æµç¨‹æ§åˆ¶] Engineeré¦–æ¬¡æäº¤,è½¬ç»™CodeReviewerå®¡æŸ¥
Engineer: """
ä»£ç å¦‚ä¸‹:
```python
def register_user(email, password):
    import re
    import bcrypt

    # é‚®ç®±éªŒè¯
    if not re.match(r'^[\w\.-]+@[\w\.-]+\.\w+$', email):
        return {"error": "é‚®ç®±æ ¼å¼é”™è¯¯"}

    # å¯†ç å¼ºåº¦æ£€æŸ¥
    if len(password) < 8:
        return {"error": "å¯†ç è‡³å°‘8ä½"}
    if not re.search(r'[A-Za-z]', password):
        return {"error": "å¯†ç å¿…é¡»åŒ…å«å­—æ¯"}
    if not re.search(r'\d', password):
        return {"error": "å¯†ç å¿…é¡»åŒ…å«æ•°å­—"}

    # åŠ å¯†å­˜å‚¨
    hashed = bcrypt.hashpw(password.encode(), bcrypt.gensalt())

    return {"success": True, "user": {"email": email}}
```
ä»£ç å®Œæˆ,è¯·å®¡æŸ¥ã€‚
"""

[æµç¨‹æ§åˆ¶] ä»£ç å®¡æŸ¥é€šè¿‡,è½¬ç»™QAæµ‹è¯•
CodeReviewer: """
ä»£ç å®¡æŸ¥é€šè¿‡:
âœ… é‚®ç®±éªŒè¯æ­£åˆ™è¡¨è¾¾å¼æ­£ç¡®
âœ… å¯†ç å¼ºåº¦æ£€æŸ¥å®Œæ•´
âœ… ä½¿ç”¨bcryptåŠ å¯†,ç¬¦åˆå®‰å…¨æ ‡å‡†
âœ… é”™è¯¯å¤„ç†æ¸…æ™°

è½¬äº¤QA_Engineeræµ‹è¯•ã€‚
"""

[æµç¨‹æ§åˆ¶] QAæ‰§è¡Œæµ‹è¯•
QA_Engineer: """
## æµ‹è¯•æŠ¥å‘Š

### æµ‹è¯•ç”¨ä¾‹

1. æ­£å¸¸æ³¨å†Œ
   - è¾“å…¥: email="test@example.com", password="Pass1234"
   - é¢„æœŸ: æ³¨å†ŒæˆåŠŸ
   - å®é™…: âœ… é€šè¿‡

2. é‚®ç®±æ ¼å¼é”™è¯¯
   - è¾“å…¥: email="invalid-email", password="Pass1234"
   - é¢„æœŸ: è¿”å›"é‚®ç®±æ ¼å¼é”™è¯¯"
   - å®é™…: âœ… é€šè¿‡

3. å¯†ç è¿‡çŸ­
   - è¾“å…¥: email="test@example.com", password="Pass1"
   - é¢„æœŸ: è¿”å›"å¯†ç è‡³å°‘8ä½"
   - å®é™…: âœ… é€šè¿‡

4. å¯†ç ç¼ºå°‘æ•°å­—
   - è¾“å…¥: email="test@example.com", password="Password"
   - é¢„æœŸ: è¿”å›"å¯†ç å¿…é¡»åŒ…å«æ•°å­—"
   - å®é™…: âœ… é€šè¿‡

5. è¾¹ç•Œæµ‹è¯• - ç‰¹æ®Šå­—ç¬¦é‚®ç®±
   - è¾“å…¥: email="test+tag@sub.example.com", password="Pass1234"
   - é¢„æœŸ: æ³¨å†ŒæˆåŠŸ
   - å®é™…: âŒ å¤±è´¥ (æ­£åˆ™è¡¨è¾¾å¼ä¸æ”¯æŒ+å·)

### æ€»ç»“
- é€šè¿‡: 4ä¸ª
- å¤±è´¥: 1ä¸ª
- é€šè¿‡ç‡: 80%

### BugæŠ¥å‘Š
**Bug #1: é‚®ç®±éªŒè¯ä¸æ”¯æŒç‰¹æ®Šå­—ç¬¦**
- ä¸¥é‡çº§åˆ«: P2 (ä¸­ç­‰)
- æè¿°: RFCæ ‡å‡†å…è®¸é‚®ç®±ä¸­åŒ…å«+å·,ä½†å½“å‰æ­£åˆ™ä¸æ”¯æŒ
- å¤ç°: è¾“å…¥"test+tag@example.com"
- å»ºè®®ä¿®å¤: ä¿®æ”¹æ­£åˆ™ä¸º r'^[\w\.\+\-]+@[\w\.\-]+\.\w+$'

@Engineer è¯·ä¿®å¤æ­¤Bugã€‚
"""

[æµç¨‹æ§åˆ¶] QAå‘ç°Bug,è½¬ç»™Engineerä¿®å¤
Engineer: """
å·²ä¿®å¤Bug #1:

```python
# ä¿®æ”¹å‰
if not re.match(r'^[\w\.-]+@[\w\.-]+\.\w+$', email):

# ä¿®æ”¹å
if not re.match(r'^[\w\.\+\-]+@[\w\.\-]+\.\w+$', email):
```

æ”¯æŒé‚®ç®±ä¸­çš„+å·å’Œ-å·,ç¬¦åˆRFC 5322æ ‡å‡†ã€‚
è¯·é‡æ–°æµ‹è¯•ã€‚
"""

[æµç¨‹æ§åˆ¶] Engineerå®Œæˆä¿®æ”¹,è½¬ç»™CodeReviewerå¤å®¡
CodeReviewer: """
ä¿®å¤å®¡æŸ¥é€šè¿‡,è½¬äº¤QAå¤æµ‹ã€‚
"""

[æµç¨‹æ§åˆ¶] ä»£ç å®¡æŸ¥é€šè¿‡,è½¬ç»™QAæµ‹è¯•
QA_Engineer: """
## å¤æµ‹æŠ¥å‘Š

é‡æ–°æ‰§è¡Œæµ‹è¯•ç”¨ä¾‹5:
- è¾“å…¥: email="test+tag@sub.example.com", password="Pass1234"
- é¢„æœŸ: æ³¨å†ŒæˆåŠŸ
- å®é™…: âœ… é€šè¿‡

å…¨éƒ¨æµ‹è¯•é€šè¿‡ç‡: 100%
ç»“è®º: æµ‹è¯•é€šè¿‡,è½¬äº¤ProductManagerç¡®è®¤ã€‚
"""

[æµç¨‹æ§åˆ¶] QAæµ‹è¯•é€šè¿‡,è½¬ç»™PMç¡®è®¤
PM: """
ç¡®è®¤åŠŸèƒ½æ»¡è¶³éœ€æ±‚:
âœ… é‚®ç®±éªŒè¯ (æ”¯æŒç‰¹æ®Šå­—ç¬¦)
âœ… å¯†ç å¼ºåº¦æ£€æŸ¥
âœ… å¯†ç åŠ å¯†å­˜å‚¨
âœ… æµ‹è¯•è¦†ç›–å…¨é¢

æ»¡è¶³ä¸Šçº¿æ ‡å‡†ã€‚
"""

[æµç¨‹æ§åˆ¶] PMç¡®è®¤,ä»»åŠ¡å®Œæˆ
User: "TERMINATE"
```

---

#### ğŸ¯ QAè§’è‰²çš„ä»·å€¼

**å¼•å…¥QAåçš„æ”¹è¿›**:

```
æ”¹è¿›å‰:
PM â†’ Engineer â†’ CodeReviewer â†’ PMç¡®è®¤
é—®é¢˜: ä»£ç å®¡æŸ¥åªçœ‹ä»£ç ,ä¸è¿è¡Œæµ‹è¯•

æ”¹è¿›å:
PM â†’ Engineer â†’ CodeReviewer â†’ QAæµ‹è¯• â†’ PMç¡®è®¤
ä¼˜åŠ¿:
âœ… å‘ç°è¿è¡Œæ—¶Bug (ä»£ç å®¡æŸ¥å¯èƒ½é—æ¼)
âœ… éªŒè¯è¾¹ç•Œæ¡ä»¶
âœ… æå‡ä»£ç è´¨é‡

å®é™…æ¡ˆä¾‹:
CodeReviewer: "ä»£ç é€»è¾‘æ­£ç¡®"
QA: "ä½†æ˜¯ç‰¹æ®Šå­—ç¬¦é‚®ç®±ä¼šå¤±è´¥!" â† è¿è¡Œæµ‹è¯•æ‰å‘ç°çš„Bug
```

---

### è§£ç­”2.3: å¯¹è¯è´¨é‡ç›‘æ§æœºåˆ¶

#### ğŸš¨ é—®é¢˜åœºæ™¯

**AutoGenå¯èƒ½å‡ºç°çš„å¼‚å¸¸**:

```
1. åç¦»ä¸»é¢˜
PM: "æˆ‘ä»¬åšä¸€ä¸ªç™»å½•åŠŸèƒ½"
Engineer: "ç™»å½•è®©æˆ‘æƒ³åˆ°äº†OAuth2.0çš„å†å²..."
Reviewer: "è¯´åˆ°å†å²,æˆ‘æƒ³èµ·äº†1990å¹´ä»£..."
PM: "ç­‰ç­‰,æˆ‘ä»¬åœ¨èŠä»€ä¹ˆ?"
â†’ å¯¹è¯åç¦»äº†åŸå§‹ä»»åŠ¡

2. æ— é™å¾ªç¯
Engineer: "æˆ‘å»ºè®®ç”¨æ–¹æ¡ˆA"
Reviewer: "ä¸,åº”è¯¥ç”¨æ–¹æ¡ˆB"
Engineer: "ä½†æ–¹æ¡ˆAæ›´å¥½"
Reviewer: "æ–¹æ¡ˆBæ›´ä¼˜"
... (å¾ªç¯50è½®)
â†’ é™·å…¥æ— æ„ä¹‰äº‰è®º

3. ä¿¡æ¯è¿‡è½½
æ¯ä¸ªæ™ºèƒ½ä½“éƒ½è¾“å‡º2000å­—çš„é•¿ç¯‡å¤§è®º
â†’ Tokenæˆæœ¬æš´æ¶¨,æ•ˆç‡ä½ä¸‹

4. æ²‰é»˜æ™ºèƒ½ä½“
æŸä¸ªæ™ºèƒ½ä½“ä¸€ç›´ä¸å‘è¨€
â†’ æµç¨‹å¡ä½
```

---

#### ğŸ’¡ è§£å†³æ–¹æ¡ˆ: å¤šå±‚ç›‘æ§æœºåˆ¶

**æ¶æ„è®¾è®¡**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç›‘æ§å±‚                          â”‚
â”‚ â”œâ”€ ä¸»é¢˜ä¸€è‡´æ€§ç›‘æ§               â”‚
â”‚ â”œâ”€ å¾ªç¯æ£€æµ‹                     â”‚
â”‚ â”œâ”€ è¾“å‡ºé•¿åº¦ç›‘æ§                 â”‚
â”‚ â”œâ”€ å‚ä¸åº¦ç›‘æ§                   â”‚
â”‚ â””â”€ æƒ…æ„Ÿåˆ†æ (å¯é€‰)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†“ (æ£€æµ‹åˆ°å¼‚å¸¸)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å¹²é¢„å±‚                          â”‚
â”‚ â”œâ”€ æé†’æ™ºèƒ½ä½“å›å½’ä¸»é¢˜           â”‚
â”‚ â”œâ”€ å¼ºåˆ¶ç»ˆæ­¢æ— æ„ä¹‰å¾ªç¯           â”‚
â”‚ â”œâ”€ é™åˆ¶å•æ¬¡è¾“å‡ºé•¿åº¦             â”‚
â”‚ â””â”€ å¼•å¯¼æ²‰é»˜æ™ºèƒ½ä½“å‘è¨€           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### ğŸ“‹ å®Œæ•´å®ç°

```python
from autogen import AssistantAgent, GroupChat, GroupChatManager
from collections import defaultdict
import re
from typing import List, Dict

class QualityMonitor:
    """
    å¯¹è¯è´¨é‡ç›‘æ§å™¨
    """

    def __init__(self,
                 original_task: str,
                 max_rounds_without_progress: int = 5,
                 max_message_length: int = 1000,
                 min_participation_rate: float = 0.3):
        """
        åˆå§‹åŒ–ç›‘æ§å™¨

        Args:
            original_task: åŸå§‹ä»»åŠ¡æè¿°
            max_rounds_without_progress: æ— è¿›å±•æœ€å¤§è½®æ•°
            max_message_length: å•æ¡æ¶ˆæ¯æœ€å¤§é•¿åº¦
            min_participation_rate: æœ€ä½å‚ä¸ç‡
        """
        self.original_task = original_task
        self.max_rounds_without_progress = max_rounds_without_progress
        self.max_message_length = max_message_length
        self.min_participation_rate = min_participation_rate

        # ç»Ÿè®¡ä¿¡æ¯
        self.speaker_count = defaultdict(int)  # æ¯ä¸ªæ™ºèƒ½ä½“å‘è¨€æ¬¡æ•°
        self.topic_keywords = self._extract_keywords(original_task)
        self.recent_messages = []  # æœ€è¿‘Næ¡æ¶ˆæ¯
        self.loop_detector = LoopDetector()

    def _extract_keywords(self, text: str) -> set:
        """æå–ä»»åŠ¡å…³é”®è¯"""
        # ç®€åŒ–: æå–3å­—ä»¥ä¸Šçš„è¯
        words = re.findall(r'\b\w{3,}\b', text.lower())
        return set(words[:10])  # å–å‰10ä¸ªå…³é”®è¯

    def check_quality(self, messages: List[Dict]) -> Dict:
        """
        æ£€æŸ¥å¯¹è¯è´¨é‡

        Returns:
            {
                "is_healthy": bool,
                "issues": List[str],
                "suggestions": List[str]
            }
        """
        issues = []
        suggestions = []

        if not messages:
            return {"is_healthy": True, "issues": [], "suggestions": []}

        # æ£€æŸ¥1: ä¸»é¢˜ä¸€è‡´æ€§
        topic_issue = self._check_topic_consistency(messages)
        if topic_issue:
            issues.append(topic_issue)
            suggestions.append("è¯·å›åˆ°åŸå§‹ä»»åŠ¡: " + self.original_task)

        # æ£€æŸ¥2: å¾ªç¯æ£€æµ‹
        loop_issue = self._check_loops(messages)
        if loop_issue:
            issues.append(loop_issue)
            suggestions.append("æ£€æµ‹åˆ°é‡å¤è®¨è®º,å»ºè®®åšå‡ºå†³ç­–æˆ–å¯»æ±‚æ–°è§†è§’")

        # æ£€æŸ¥3: æ¶ˆæ¯é•¿åº¦
        length_issue = self._check_message_length(messages)
        if length_issue:
            issues.append(length_issue)
            suggestions.append(f"è¯·å°†å›å¤æ§åˆ¶åœ¨{self.max_message_length}å­—ä»¥å†…")

        # æ£€æŸ¥4: å‚ä¸åº¦
        participation_issue = self._check_participation(messages)
        if participation_issue:
            issues.append(participation_issue)
            suggestions.append("é¼“åŠ±æ‰€æœ‰æ™ºèƒ½ä½“ç§¯æå‚ä¸è®¨è®º")

        # æ£€æŸ¥5: è¿›å±•æ£€æµ‹
        progress_issue = self._check_progress(messages)
        if progress_issue:
            issues.append(progress_issue)
            suggestions.append("å¯¹è¯ä¼¼ä¹åœæ»,å»ºè®®æ€»ç»“å½“å‰è¿›å±•å¹¶æ˜ç¡®ä¸‹ä¸€æ­¥")

        is_healthy = len(issues) == 0

        return {
            "is_healthy": is_healthy,
            "issues": issues,
            "suggestions": suggestions
        }

    def _check_topic_consistency(self, messages: List[Dict]) -> str:
        """æ£€æŸ¥ä¸»é¢˜ä¸€è‡´æ€§"""
        recent_5 = messages[-5:]  # æ£€æŸ¥æœ€è¿‘5æ¡æ¶ˆæ¯

        keyword_match_count = 0
        for msg in recent_5:
            content = msg.get("content", "").lower()
            # æ£€æŸ¥æ˜¯å¦åŒ…å«åŸå§‹ä»»åŠ¡çš„å…³é”®è¯
            if any(keyword in content for keyword in self.topic_keywords):
                keyword_match_count += 1

        # å¦‚æœæœ€è¿‘5æ¡æ¶ˆæ¯ä¸­,å°‘äº2æ¡æåˆ°ä»»åŠ¡å…³é”®è¯
        if keyword_match_count < 2:
            return "âš ï¸ å¯¹è¯åç¦»ä¸»é¢˜"

        return None

    def _check_loops(self, messages: List[Dict]) -> str:
        """æ£€æµ‹å¾ªç¯"""
        if len(messages) < 10:
            return None

        # æ£€æŸ¥æœ€è¿‘10æ¡æ¶ˆæ¯
        recent_10 = messages[-10:]

        # æ£€æµ‹é‡å¤æ¨¡å¼
        speakers = [msg.get("name", "") for msg in recent_10]

        # ç®€å•æ£€æµ‹: Aâ†’Bâ†’Aâ†’B... æ¨¡å¼
        if len(set(speakers)) == 2:
            # åªæœ‰ä¸¤ä¸ªäººåœ¨å¯¹è¯
            if speakers[0::2] == [speakers[0]] * 5 and speakers[1::2] == [speakers[1]] * 5:
                return f"âš ï¸ æ£€æµ‹åˆ°å¾ªç¯: {speakers[0]} å’Œ {speakers[1]} åå¤è®¨è®º"

        # æ£€æµ‹å†…å®¹é‡å¤
        contents = [msg.get("content", "")[:100] for msg in recent_10]
        if len(set(contents)) < 5:  # 10æ¡æ¶ˆæ¯ä¸­,åªæœ‰ä¸åˆ°5ç§ä¸åŒå†…å®¹
            return "âš ï¸ æ£€æµ‹åˆ°å†…å®¹é‡å¤,å¯¹è¯å¯èƒ½é™·å…¥å¾ªç¯"

        return None

    def _check_message_length(self, messages: List[Dict]) -> str:
        """æ£€æŸ¥æ¶ˆæ¯é•¿åº¦"""
        last_message = messages[-1]
        content = last_message.get("content", "")

        if len(content) > self.max_message_length:
            speaker = last_message.get("name", "Unknown")
            return f"âš ï¸ {speaker}çš„å›å¤è¿‡é•¿ ({len(content)}å­— > {self.max_message_length}å­—)"

        return None

    def _check_participation(self, messages: List[Dict]) -> str:
        """æ£€æŸ¥å‚ä¸åº¦"""
        # ç»Ÿè®¡æ¯ä¸ªæ™ºèƒ½ä½“çš„å‘è¨€æ¬¡æ•°
        speaker_counts = defaultdict(int)
        for msg in messages:
            speaker = msg.get("name", "Unknown")
            speaker_counts[speaker] += 1

        total_messages = len(messages)
        num_speakers = len(speaker_counts)

        if num_speakers == 0:
            return None

        # è®¡ç®—å‚ä¸ç‡æœ€ä½çš„æ™ºèƒ½ä½“
        min_participation = min(speaker_counts.values()) / total_messages

        if min_participation < self.min_participation_rate:
            silent_speakers = [
                speaker for speaker, count in speaker_counts.items()
                if count / total_messages < self.min_participation_rate
            ]
            return f"âš ï¸ éƒ¨åˆ†æ™ºèƒ½ä½“å‚ä¸åº¦ä½: {', '.join(silent_speakers)}"

        return None

    def _check_progress(self, messages: List[Dict]) -> str:
        """æ£€æµ‹æ˜¯å¦æœ‰è¿›å±•"""
        if len(messages) < self.max_rounds_without_progress:
            return None

        # æ£€æŸ¥æœ€è¿‘Nè½®æ˜¯å¦åŒ…å«"å†³ç­–æ€§"å…³é”®è¯
        recent_n = messages[-self.max_rounds_without_progress:]

        progress_keywords = [
            "å†³å®š", "ç¡®å®š", "é€‰æ‹©", "å®Œæˆ", "å®ç°", "ä»£ç ",
            "æµ‹è¯•", "é€šè¿‡", "ä¿®å¤", "ä¼˜åŒ–", "éƒ¨ç½²"
        ]

        has_progress = False
        for msg in recent_n:
            content = msg.get("content", "")
            if any(keyword in content for keyword in progress_keywords):
                has_progress = True
                break

        if not has_progress:
            return f"âš ï¸ æœ€è¿‘{self.max_rounds_without_progress}è½®å¯¹è¯æ— æ˜æ˜¾è¿›å±•"

        return None

class LoopDetector:
    """å¾ªç¯æ£€æµ‹å™¨ (é«˜çº§ç‰ˆ)"""

    def __init__(self, window_size: int = 10):
        self.window_size = window_size
        self.history = []

    def add_message(self, speaker: str, content: str):
        """æ·»åŠ æ¶ˆæ¯"""
        self.history.append({
            "speaker": speaker,
            "content_hash": hash(content[:200])  # ä½¿ç”¨å‰200å­—çš„hash
        })

        # ä¿æŒçª—å£å¤§å°
        if len(self.history) > self.window_size:
            self.history.pop(0)

    def detect_loop(self) -> bool:
        """æ£€æµ‹æ˜¯å¦å¾ªç¯"""
        if len(self.history) < 6:
            return False

        # æ£€æµ‹Aâ†’Bâ†’Aâ†’Bæ¨¡å¼
        for i in range(len(self.history) - 5):
            pattern = self.history[i:i+6]
            if (pattern[0]["speaker"] == pattern[2]["speaker"] == pattern[4]["speaker"] and
                pattern[1]["speaker"] == pattern[3]["speaker"] == pattern[5]["speaker"]):
                # å¹¶ä¸”å†…å®¹ç›¸ä¼¼
                if (pattern[0]["content_hash"] == pattern[2]["content_hash"] and
                    pattern[1]["content_hash"] == pattern[3]["content_hash"]):
                    return True

        return False

# 3. é›†æˆåˆ°GroupChat

class MonitoredGroupChat(GroupChat):
    """å¸¦ç›‘æ§çš„GroupChat"""

    def __init__(self, *args, monitor: QualityMonitor = None, **kwargs):
        super().__init__(*args, **kwargs)
        self.monitor = monitor
        self.intervention_count = 0
        self.max_interventions = 3  # æœ€å¤šå¹²é¢„3æ¬¡

    def append(self, message: Dict, speaker: AssistantAgent):
        """é‡å†™appendæ–¹æ³•,åŠ å…¥ç›‘æ§"""
        # æ·»åŠ æ¶ˆæ¯åˆ°å†å²
        super().append(message, speaker)

        # è´¨é‡æ£€æŸ¥
        if self.monitor:
            quality_report = self.monitor.check_quality(self.messages)

            if not quality_report["is_healthy"]:
                print("\n" + "="*60)
                print("ğŸš¨ å¯¹è¯è´¨é‡ç›‘æ§å‘Šè­¦")
                print("="*60)

                print("\nå‘ç°é—®é¢˜:")
                for issue in quality_report["issues"]:
                    print(f"  {issue}")

                print("\nå»ºè®®:")
                for suggestion in quality_report["suggestions"]:
                    print(f"  ğŸ’¡ {suggestion}")

                # å¹²é¢„: æ³¨å…¥æé†’æ¶ˆæ¯
                if self.intervention_count < self.max_interventions:
                    intervention_message = {
                        "role": "system",
                        "name": "QualityMonitor",
                        "content": f"""
[ç³»ç»Ÿæé†’]
æ£€æµ‹åˆ°å¯¹è¯è´¨é‡é—®é¢˜,è¯·æ³¨æ„:

é—®é¢˜:
{chr(10).join('- ' + issue for issue in quality_report['issues'])}

å»ºè®®:
{chr(10).join('- ' + suggestion for suggestion in quality_report['suggestions'])}

åŸå§‹ä»»åŠ¡: {self.monitor.original_task}

è¯·å›åˆ°æ­£è½¨,ç»§ç»­æ¨è¿›ä»»åŠ¡ã€‚
"""
                    }
                    self.messages.append(intervention_message)
                    self.intervention_count += 1
                    print("\nâœ… å·²æ³¨å…¥æé†’æ¶ˆæ¯")
                else:
                    print("\nâš ï¸ å¹²é¢„æ¬¡æ•°å·²è¾¾ä¸Šé™,è€ƒè™‘ç»ˆæ­¢å¯¹è¯")
                    # å¯ä»¥é€‰æ‹©å¼ºåˆ¶ç»ˆæ­¢
                    # self.terminate = True

                print("="*60 + "\n")

# 4. ä½¿ç”¨ç¤ºä¾‹

# åˆ›å»ºç›‘æ§å™¨
monitor = QualityMonitor(
    original_task="å®ç°ç”¨æˆ·ç™»å½•åŠŸèƒ½,åŒ…æ‹¬é‚®ç®±éªŒè¯å’Œå¯†ç åŠ å¯†",
    max_rounds_without_progress=5,
    max_message_length=800,
    min_participation_rate=0.2
)

# åˆ›å»ºå¸¦ç›‘æ§çš„GroupChat
monitored_chat = MonitoredGroupChat(
    agents=[pm, engineer, reviewer, qa_engineer, user_proxy],
    messages=[],
    max_round=100,
    monitor=monitor  # æ³¨å…¥ç›‘æ§å™¨
)

manager = GroupChatManager(
    groupchat=monitored_chat,
    llm_config={"model": "gpt-4"}
)

# å¯åŠ¨å¯¹è¯
user_proxy.initiate_chat(
    manager,
    message="å®ç°ç”¨æˆ·ç™»å½•åŠŸèƒ½,åŒ…æ‹¬é‚®ç®±éªŒè¯å’Œå¯†ç åŠ å¯†"
)
```

---

#### ğŸ¬ è¿è¡Œæ•ˆæœç¤ºä¾‹

```
PM: "éœ€æ±‚æ˜ç¡®: ç”¨æˆ·ç™»å½•åŠŸèƒ½..."
Engineer: "æˆ‘å»ºè®®ä½¿ç”¨JWTè®¤è¯..."
Reviewer: "JWTæœ‰å®‰å…¨é£é™©,åº”è¯¥ç”¨Session..."
Engineer: "ä½†JWTæ›´é€‚åˆåˆ†å¸ƒå¼ç³»ç»Ÿ..."
Reviewer: "Sessionä¹Ÿå¯ä»¥åˆ†å¸ƒå¼éƒ¨ç½²..."
Engineer: "JWTæ€§èƒ½æ›´å¥½..."
Reviewer: "æ€§èƒ½å·®å¼‚å¯ä»¥å¿½ç•¥..."

============================================================
ğŸš¨ å¯¹è¯è´¨é‡ç›‘æ§å‘Šè­¦
============================================================

å‘ç°é—®é¢˜:
  âš ï¸ æ£€æµ‹åˆ°å¾ªç¯: Engineer å’Œ Reviewer åå¤è®¨è®º
  âš ï¸ æœ€è¿‘5è½®å¯¹è¯æ— æ˜æ˜¾è¿›å±•

å»ºè®®:
  ğŸ’¡ æ£€æµ‹åˆ°é‡å¤è®¨è®º,å»ºè®®åšå‡ºå†³ç­–æˆ–å¯»æ±‚æ–°è§†è§’
  ğŸ’¡ å¯¹è¯ä¼¼ä¹åœæ»,å»ºè®®æ€»ç»“å½“å‰è¿›å±•å¹¶æ˜ç¡®ä¸‹ä¸€æ­¥

âœ… å·²æ³¨å…¥æé†’æ¶ˆæ¯
============================================================

[ç³»ç»Ÿæé†’]
æ£€æµ‹åˆ°å¯¹è¯è´¨é‡é—®é¢˜,è¯·æ³¨æ„:

é—®é¢˜:
- æ£€æµ‹åˆ°å¾ªç¯: Engineer å’Œ Reviewer åå¤è®¨è®º
- æœ€è¿‘5è½®å¯¹è¯æ— æ˜æ˜¾è¿›å±•

å»ºè®®:
- æ£€æµ‹åˆ°é‡å¤è®¨è®º,å»ºè®®åšå‡ºå†³ç­–æˆ–å¯»æ±‚æ–°è§†è§’
- å¯¹è¯ä¼¼ä¹åœæ»,å»ºè®®æ€»ç»“å½“å‰è¿›å±•å¹¶æ˜ç¡®ä¸‹ä¸€æ­¥

åŸå§‹ä»»åŠ¡: å®ç°ç”¨æˆ·ç™»å½•åŠŸèƒ½,åŒ…æ‹¬é‚®ç®±éªŒè¯å’Œå¯†ç åŠ å¯†

è¯·å›åˆ°æ­£è½¨,ç»§ç»­æ¨è¿›ä»»åŠ¡ã€‚

PM: "æˆ‘æ¥æ€»ç»“ä¸€ä¸‹,ä¸ºäº†æ¨è¿›ä»»åŠ¡,æˆ‘ä»¬é€‰æ‹©JWTæ–¹æ¡ˆ,
     ç†ç”±æ˜¯æ›´é€‚åˆæœªæ¥æ‰©å±•ã€‚è¯·Engineerå®ç°ä»£ç ã€‚"

Engineer: "æ”¶åˆ°,å¼€å§‹å®ç°..."

âœ… å¯¹è¯å›å½’æ­£è½¨!
```

---

#### ğŸ“Š ç›‘æ§æŒ‡æ ‡æ€»ç»“

| ç›‘æ§ç»´åº¦ | æ£€æµ‹æ–¹æ³• | å¹²é¢„æªæ–½ |
|---------|---------|---------|
| ä¸»é¢˜ä¸€è‡´æ€§ | å…³é”®è¯åŒ¹é… | æé†’å›åˆ°åŸå§‹ä»»åŠ¡ |
| å¾ªç¯æ£€æµ‹ | å‘è¨€æ¨¡å¼åˆ†æ | å»ºè®®åšå‡ºå†³ç­– |
| æ¶ˆæ¯é•¿åº¦ | å­—ç¬¦è®¡æ•° | é™åˆ¶è¾“å‡ºé•¿åº¦ |
| å‚ä¸åº¦ | å‘è¨€æ¬¡æ•°ç»Ÿè®¡ | å¼•å¯¼æ²‰é»˜è€…å‘è¨€ |
| è¿›å±•æ£€æµ‹ | å†³ç­–å…³é”®è¯è¯†åˆ« | è¦æ±‚æ€»ç»“å’Œæ¨è¿› |

---

è¿™å°±æ˜¯ç¬¬2é¢˜çš„å®Œæ•´è§£ç­”!åŒ…å«:
1. åŠ¨æ€å›é€€æœºåˆ¶ (3ç§æ–¹æ¡ˆ)
2. æ·»åŠ QAè§’è‰² (å®Œæ•´å®ç°)
3. å¯¹è¯è´¨é‡ç›‘æ§ (å¤šå±‚æœºåˆ¶)

---

## ä¹ é¢˜3: AgentScope æ·±åº¦åˆ†æ

### é¢˜ç›®

åœ¨6.3èŠ‚çš„ `AgentScope` æ¡ˆä¾‹ä¸­ï¼Œæˆ‘ä»¬å®ç°äº†ä¸€ä¸ª"ä¸‰å›½ç‹¼äººæ€"æ¸¸æˆã€‚è¯·æ·±å…¥åˆ†æï¼š

- æ¡ˆä¾‹ä¸­ä½¿ç”¨äº† `MsgHub`ï¼ˆæ¶ˆæ¯ä¸­å¿ƒï¼‰æ¥ç®¡ç†æ™ºèƒ½ä½“é—´çš„é€šä¿¡ã€‚è¯·è§£é‡Šæ¶ˆæ¯é©±åŠ¨æ¶æ„ç›¸æ¯”ä¼ ç»Ÿå‡½æ•°è°ƒç”¨çš„ä¼˜åŠ¿æ˜¯ä»€ä¹ˆï¼Ÿåœ¨ä»€ä¹ˆåœºæ™¯ä¸‹è¿™ç§æ¶æ„ç‰¹åˆ«æœ‰ä»·å€¼ï¼Ÿ
- æ¸¸æˆä¸­ä½¿ç”¨äº†ç»“æ„åŒ–è¾“å‡ºï¼ˆå¦‚ `DiscussionModelCN`ã€`WitchActionModelCN`ï¼‰æ¥çº¦æŸæ™ºèƒ½ä½“è¡Œä¸ºã€‚è¯·è®¾è®¡ä¸€ä¸ªæ–°çš„æ¸¸æˆè§’è‰²"çŒäºº"ï¼Œå¹¶å®šä¹‰å…¶å¯¹åº”çš„ç»“æ„åŒ–è¾“å‡ºæ¨¡å‹ï¼ŒåŒ…æ‹¬å­—æ®µå®šä¹‰å’ŒéªŒè¯è§„åˆ™ã€‚
- `AgentScope` æ”¯æŒåˆ†å¸ƒå¼éƒ¨ç½²ï¼Œè¿™æ„å‘³ç€ä¸åŒçš„æ™ºèƒ½ä½“å¯ä»¥è¿è¡Œåœ¨ä¸åŒçš„æœåŠ¡å™¨ä¸Šã€‚è¯·æ€è€ƒï¼šåœ¨"ä¸‰å›½ç‹¼äººæ€"è¿™æ ·çš„å®æ—¶æ¸¸æˆåœºæ™¯ä¸­ï¼Œåˆ†å¸ƒå¼éƒ¨ç½²ä¼šå¸¦æ¥å“ªäº›æŠ€æœ¯æŒ‘æˆ˜ï¼Ÿå¦‚ä½•ä¿è¯æ¶ˆæ¯çš„é¡ºåºæ€§å’Œä¸€è‡´æ€§ï¼Ÿ

---

### è§£ç­”3.1: æ¶ˆæ¯é©±åŠ¨æ¶æ„çš„ä¼˜åŠ¿

#### ğŸ¯ ä¼ ç»Ÿå‡½æ•°è°ƒç”¨ vs æ¶ˆæ¯é©±åŠ¨æ¶æ„

**ä¼ ç»Ÿå‡½æ•°è°ƒç”¨æ¨¡å¼**:

```python
# ä¼ ç»Ÿçš„åŒæ­¥è°ƒç”¨æ–¹å¼
class TraditionalAgent:
    def process_request(self, request):
        # ç›´æ¥è°ƒç”¨å¦ä¸€ä¸ªæ™ºèƒ½ä½“
        result = other_agent.handle(request)
        # å¿…é¡»ç­‰å¾…è¿”å›
        return self.generate_response(result)

# é—®é¢˜:
# 1. ç´§è€¦åˆ - å¿…é¡»çŸ¥é“other_agentçš„å…·ä½“å®ç°
# 2. åŒæ­¥é˜»å¡ - å¿…é¡»ç­‰å¾…other_agentè¿”å›
# 3. å•ç‚¹æ•…éšœ - other_agentå´©æºƒä¼šå¯¼è‡´æ•´ä¸ªæµç¨‹ä¸­æ–­
# 4. éš¾ä»¥æ‰©å±• - æ·»åŠ æ–°æ™ºèƒ½ä½“éœ€è¦ä¿®æ”¹ç°æœ‰ä»£ç 
```

**æ¶ˆæ¯é©±åŠ¨æ¶æ„**:

```python
# AgentScopeçš„æ¶ˆæ¯é©±åŠ¨æ–¹å¼
from agentscope.message import Msg

class MessageDrivenAgent:
    async def process_request(self, request):
        # å‘é€æ¶ˆæ¯åˆ°MsgHub
        msg = Msg(
            name=self.name,
            content=request,
            role="user"
        )
        await msg_hub.publish(msg)

        # ä¸éœ€è¦ç­‰å¾…,ç»§ç»­å¤„ç†å…¶ä»–ä»»åŠ¡
        # å“åº”ä¼šé€šè¿‡å›è°ƒå¼‚æ­¥è¿”å›

# ä¼˜åŠ¿:
# âœ… æ¾è€¦åˆ - ä¸éœ€è¦çŸ¥é“æ¥æ”¶è€…æ˜¯è°
# âœ… å¼‚æ­¥éé˜»å¡ - å¯ä»¥åŒæ—¶å¤„ç†å¤šä¸ªè¯·æ±‚
# âœ… å®¹é”™æ€§å¼º - å•ä¸ªæ™ºèƒ½ä½“æ•…éšœä¸å½±å“æ•´ä½“
# âœ… æ˜“äºæ‰©å±• - æ–°æ™ºèƒ½ä½“åªéœ€è®¢é˜…æ¶ˆæ¯
```

---

#### ğŸ“Š æ¶ˆæ¯é©±åŠ¨æ¶æ„çš„æ ¸å¿ƒä¼˜åŠ¿

**1. æ—¶é—´è§£è€¦ (Temporal Decoupling)**

```
ä¼ ç»Ÿè°ƒç”¨:
æ™ºèƒ½ä½“A â”€â”€è°ƒç”¨â”€â”€> æ™ºèƒ½ä½“B
   â†“ (ç­‰å¾…)        â†“ (å¤„ç†)
   â† â”€â”€â”€â”€â”€è¿”å›â”€â”€â”€ â†

æ—¶é—´çº¿: Aå¿…é¡»ç­‰å¾…Bå®Œæˆæ‰èƒ½ç»§ç»­

æ¶ˆæ¯é©±åŠ¨:
æ™ºèƒ½ä½“A â”€â”€å‘é€æ¶ˆæ¯â”€â”€> MsgHub â”€â”€è·¯ç”±â”€â”€> æ™ºèƒ½ä½“B
   â†“ (ç»§ç»­å·¥ä½œ)                      â†“ (å¼‚æ­¥å¤„ç†)

æ—¶é—´çº¿: Aå‘é€åç«‹å³ç»§ç»­,Bä½•æ—¶å¤„ç†ç”±è°ƒåº¦å™¨å†³å®š
```

**å®é™…æ¡ˆä¾‹ - ç‹¼äººæ€æ¸¸æˆä¸­çš„åº”ç”¨**:

```python
# ä¼ ç»Ÿæ–¹å¼: å¿…é¡»ç­‰å¾…æ‰€æœ‰ç‹¼äººå‘è¨€
def werewolf_discussion_traditional():
    for wolf in werewolves:
        response = wolf.discuss()  # é˜»å¡ç­‰å¾…
        print(response)
    # æ€»è€—æ—¶ = ç‹¼äºº1è€—æ—¶ + ç‹¼äºº2è€—æ—¶ + ...

# æ¶ˆæ¯é©±åŠ¨: å¹¶å‘è®¨è®º
async def werewolf_discussion_message_driven():
    async with MsgHub(werewolves) as hub:
        # æ‰€æœ‰ç‹¼äººåŒæ—¶å¼€å§‹è®¨è®º
        tasks = [wolf.discuss() for wolf in werewolves]
        responses = await asyncio.gather(*tasks)
    # æ€»è€—æ—¶ â‰ˆ max(ç‹¼äººè€—æ—¶)
```

**æ”¶ç›Š**:
- æ¸¸æˆå“åº”é€Ÿåº¦æå‡ 3-5å€
- ç”¨æˆ·ä½“éªŒæ›´æµç•…

---

**2. ç©ºé—´è§£è€¦ (Spatial Decoupling)**

```
ä¼ ç»Ÿè°ƒç”¨:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  ç›´æ¥å¼•ç”¨  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ™ºèƒ½ä½“A  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚ æ™ºèƒ½ä½“B  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
é—®é¢˜: Aå¿…é¡»çŸ¥é“Båœ¨å“ªé‡Œ(è¿›ç¨‹å†…/è¿›ç¨‹å¤–/æœåŠ¡å™¨åœ°å€)

æ¶ˆæ¯é©±åŠ¨:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ™ºèƒ½ä½“A  â”‚            â”‚ æ™ºèƒ½ä½“B  â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚ publish              â”‚ subscribe
     â†“                      â†“
     â””â”€â”€â”€â”€â”€> MsgHub <â”€â”€â”€â”€â”€â”€â”€â”˜
ä¼˜åŠ¿: Aå’ŒBäº’ä¸çŸ¥æ™“å¯¹æ–¹ä½ç½®,ç”±MsgHubè´Ÿè´£è·¯ç”±
```

**å®é™…æ¡ˆä¾‹ - åˆ†å¸ƒå¼ç‹¼äººæ€**:

```python
# éƒ¨ç½²åœ¨æœåŠ¡å™¨1
werewolf_agent = WerewolfAgent("æ›¹æ“")
werewolf_agent.connect_to_hub("redis://game-hub:6379")

# éƒ¨ç½²åœ¨æœåŠ¡å™¨2
seer_agent = SeerAgent("è¯¸è‘›äº®")
seer_agent.connect_to_hub("redis://game-hub:6379")

# ä¸¤ä¸ªæ™ºèƒ½ä½“å¯ä»¥åœ¨ä¸åŒæœºå™¨ä¸Š,ä½†é€šè¿‡MsgHubæ— ç¼é€šä¿¡
```

**æ”¶ç›Š**:
- æ”¯æŒæ°´å¹³æ‰©å±•
- å¯ä»¥å°†è®¡ç®—å¯†é›†å‹æ™ºèƒ½ä½“éƒ¨ç½²åˆ°GPUæœåŠ¡å™¨
- å¯ä»¥åŠ¨æ€å¢å‡æ™ºèƒ½ä½“å®ä¾‹

---

**3. å¯è§‚æµ‹æ€§ (Observability)**

```python
# æ¶ˆæ¯é©±åŠ¨å¤©ç„¶æ”¯æŒæ—¥å¿—è®°å½•
class ObservableMsgHub:
    def publish(self, msg: Msg):
        # è‡ªåŠ¨è®°å½•æ‰€æœ‰æ¶ˆæ¯
        self.logger.info({
            "timestamp": datetime.now(),
            "sender": msg.name,
            "content": msg.content,
            "metadata": msg.metadata
        })

        # è·¯ç”±æ¶ˆæ¯
        self._route(msg)

    def get_conversation_history(self, session_id):
        # è½»æ¾é‡æ”¾æ•´ä¸ªå¯¹è¯
        return self.db.query(
            "SELECT * FROM messages WHERE session_id = ?",
            session_id
        )
```

**å®é™…ä»·å€¼**:

```
è°ƒè¯•åœºæ™¯:
"ä¸ºä»€ä¹ˆç¬¬3è½®ç‹¼äººæ²¡æœ‰å‡»æ€æˆåŠŸ?"

ä¼ ç»Ÿæ–¹å¼:
â†’ éœ€è¦åœ¨ä»£ç ä¸­åŠ printè¯­å¥
â†’ é‡æ–°è¿è¡Œæ¸¸æˆ
â†’ å¸Œæœ›èƒ½å¤ç°é—®é¢˜

æ¶ˆæ¯é©±åŠ¨:
â†’ æŸ¥è¯¢æ¶ˆæ¯æ—¥å¿—: SELECT * FROM messages WHERE round=3
â†’ ç«‹å³çœ‹åˆ°å®Œæ•´çš„æ¶ˆæ¯æµ:
   - ç‹¼äººAæŠ•ç¥¨: ç›®æ ‡=è¯¸è‘›äº®
   - ç‹¼äººBæŠ•ç¥¨: ç›®æ ‡=èµµäº‘
   - ç³»ç»Ÿè£å†³: ç¥¨æ•°å¹³åˆ†,å‡»æ€å¤±è´¥
â†’ 5ç§’å®šä½é—®é¢˜æ ¹å› 
```

---

**4. å®¹é”™æ€§ (Fault Tolerance)**

```python
# æ¶ˆæ¯é©±åŠ¨æ”¯æŒæ¶ˆæ¯æŒä¹…åŒ–å’Œé‡è¯•
class ResilientMsgHub:
    async def publish(self, msg: Msg):
        # 1. æ¶ˆæ¯æŒä¹…åŒ–
        await self.db.save(msg)

        try:
            # 2. å°è¯•å‘é€
            await self._send(msg)
        except AgentUnavailable:
            # 3. æ™ºèƒ½ä½“æš‚æ—¶ä¸å¯ç”¨,åŠ å…¥é‡è¯•é˜Ÿåˆ—
            await self.retry_queue.add(msg, delay=5)

        except AgentCrashed:
            # 4. æ™ºèƒ½ä½“å´©æºƒ,è§¦å‘é™çº§ç­–ç•¥
            await self._fallback_handler(msg)
```

**å®é™…æ¡ˆä¾‹ - æ¸¸æˆå®¹é”™**:

```python
# åœºæ™¯: é¢„è¨€å®¶æ™ºèƒ½ä½“åœ¨æŸ¥éªŒæ—¶å´©æºƒ

# ä¼ ç»Ÿæ–¹å¼:
def seer_phase():
    result = seer_agent.check_player(target)  # å´©æºƒ â†’ æ•´ä¸ªæ¸¸æˆä¸­æ–­

# æ¶ˆæ¯é©±åŠ¨:
async def seer_phase():
    msg = Msg(content=f"æŸ¥éªŒ{target}", role="seer")

    try:
        result = await msg_hub.request(msg, timeout=10)
    except TimeoutError:
        # æ™ºèƒ½ä½“æ— å“åº”,ä½¿ç”¨é»˜è®¤è¡Œä¸º
        logger.warning("é¢„è¨€å®¶æ— å“åº”,è·³è¿‡æŸ¥éªŒç¯èŠ‚")
        result = None  # æ¸¸æˆç»§ç»­

    return result
```

**æ”¶ç›Š**:
- å•ä¸ªæ™ºèƒ½ä½“æ•…éšœä¸ä¼šå¯¼è‡´æ•´åœºæ¸¸æˆå´©æºƒ
- ç”¨æˆ·ä½“éªŒæ›´å¯é 

---

#### ğŸ¯ æ¶ˆæ¯é©±åŠ¨ç‰¹åˆ«æœ‰ä»·å€¼çš„åœºæ™¯

**åœºæ™¯1: é«˜å¹¶å‘å¤šäººåœ¨çº¿æ¸¸æˆ**

```
éœ€æ±‚:
- 1000ä¸ªç©å®¶åŒæ—¶åœ¨çº¿
- æ¯ä¸ªç©å®¶éƒ½æ˜¯ä¸€ä¸ªæ™ºèƒ½ä½“
- éœ€è¦å®æ—¶å“åº”

ä¼ ç»Ÿæ–¹å¼:
â†’ å•çº¿ç¨‹å¤„ç†,å“åº”å»¶è¿Ÿ = 1000 Ã— å•ä¸ªå¤„ç†æ—¶é—´
â†’ æ— æ³•æ‰©å±•

æ¶ˆæ¯é©±åŠ¨:
â†’ æ¶ˆæ¯åˆ†å‘åˆ°100å°æœåŠ¡å™¨å¹¶è¡Œå¤„ç†
â†’ å“åº”å»¶è¿Ÿ = 10 Ã— å•ä¸ªå¤„ç†æ—¶é—´
â†’ å¯æ°´å¹³æ‰©å±•
```

**åœºæ™¯2: é•¿æ—¶è¿è¡Œçš„åä½œä»»åŠ¡**

```
éœ€æ±‚:
- æ™ºèƒ½ä½“å›¢é˜Ÿåä½œä¸€ä¸ªå¤æ‚é¡¹ç›®
- ä»»åŠ¡å¯èƒ½æŒç»­æ•°å°æ—¶ç”šè‡³æ•°å¤©
- éœ€è¦æ”¯æŒä¸­æ–­å’Œæ¢å¤

ä¼ ç»Ÿæ–¹å¼:
â†’ è¿›ç¨‹å´©æºƒ = æ‰€æœ‰è¿›åº¦ä¸¢å¤±
â†’ æ— æ³•æš‚åœ/æ¢å¤

æ¶ˆæ¯é©±åŠ¨:
â†’ æ¯æ¡æ¶ˆæ¯éƒ½æŒä¹…åŒ–
â†’ å¯ä»¥ä»ä»»æ„æ–­ç‚¹æ¢å¤
â†’ æ”¯æŒ"ä¿å­˜æ¸¸æˆ"åŠŸèƒ½
```

**åœºæ™¯3: è·¨ç»„ç»‡çš„æ™ºèƒ½ä½“åä½œ**

```
éœ€æ±‚:
- å…¬å¸Açš„é‡‡è´­æ™ºèƒ½ä½“ éœ€è¦ä¸ å…¬å¸Bçš„é”€å”®æ™ºèƒ½ä½“ åä½œ
- ä¸¤å®¶å…¬å¸çš„ç³»ç»Ÿå®Œå…¨ç‹¬ç«‹
- éœ€è¦å®‰å…¨çš„é€šä¿¡

ä¼ ç»Ÿæ–¹å¼:
â†’ éœ€è¦VPNæ‰“é€šç½‘ç»œ
â†’ éœ€è¦æš´éœ²å†…éƒ¨API
â†’ å®‰å…¨é£é™©é«˜

æ¶ˆæ¯é©±åŠ¨:
â†’ é€šè¿‡æ¶ˆæ¯é˜Ÿåˆ—(å¦‚Kafka)æ¾è€¦åˆé€šä¿¡
â†’ åªæš´éœ²æ¶ˆæ¯åè®®,ä¸æš´éœ²å†…éƒ¨å®ç°
â†’ æ¶ˆæ¯å¯åŠ å¯†å’Œå®¡è®¡
```

---

#### ğŸ“Š å¯¹æ¯”æ€»ç»“

| ç»´åº¦ | ä¼ ç»Ÿå‡½æ•°è°ƒç”¨ | æ¶ˆæ¯é©±åŠ¨æ¶æ„ |
|------|-------------|-------------|
| **è€¦åˆåº¦** | ç´§è€¦åˆ(éœ€è¦çŸ¥é“å¯¹æ–¹å®ç°) | æ¾è€¦åˆ(åªéœ€è¦çŸ¥é“æ¶ˆæ¯æ ¼å¼) |
| **å¹¶å‘æ€§** | åŒæ­¥é˜»å¡ | å¼‚æ­¥éé˜»å¡ |
| **æ‰©å±•æ€§** | éš¾(éœ€ä¿®æ”¹ç°æœ‰ä»£ç ) | æ˜“(æ–°æ™ºèƒ½ä½“è®¢é˜…æ¶ˆæ¯å³å¯) |
| **å®¹é”™æ€§** | å¼±(å•ç‚¹æ•…éšœå½±å“å…¨å±€) | å¼º(æ¶ˆæ¯æŒä¹…åŒ–+é‡è¯•) |
| **å¯è§‚æµ‹æ€§** | éœ€æ‰‹åŠ¨æ·»åŠ æ—¥å¿— | å¤©ç„¶æ”¯æŒæ¶ˆæ¯è¿½è¸ª |
| **åˆ†å¸ƒå¼** | éœ€è¦RPCæ¡†æ¶ | åŸç”Ÿæ”¯æŒ |
| **é€‚ç”¨åœºæ™¯** | ç®€å•æµç¨‹,å•æœºåº”ç”¨ | å¤æ‚åä½œ,åˆ†å¸ƒå¼ç³»ç»Ÿ |

---

### è§£ç­”3.2: è®¾è®¡"çŒäºº"è§’è‰²çš„ç»“æ„åŒ–è¾“å‡ºæ¨¡å‹

#### ğŸ¯ çŒäººè§’è‰²çš„æ¸¸æˆè§„åˆ™

**çŒäºº (Hunter)** æ˜¯ç‹¼äººæ€ä¸­çš„ç‰¹æ®Šè§’è‰²:

```
èƒ½åŠ›:
1. å¹³å±€èƒ½åŠ›: è¢«ç‹¼äººå‡»æ€æˆ–è¢«æŠ•ç¥¨å‡ºå±€æ—¶,å¯ä»¥"å¼€æª"å¸¦èµ°ä¸€åç©å®¶
2. æŠ€èƒ½é™åˆ¶: è¢«å¥³å·«æ¯’æ­»æ—¶,ä¸èƒ½å¼€æª(è¢«"ç¼´æ¢°")
3. ç­–ç•¥é€‰æ‹©: å¯ä»¥é€‰æ‹©å¼€æªæˆ–æ”¾å¼ƒ

æ¸¸æˆæµç¨‹:
æ­»äº¡è§¦å‘ â†’ åˆ¤æ–­æ­»å›  â†’ å†³å®šæ˜¯å¦å¼€æª â†’ é€‰æ‹©ç›®æ ‡ â†’ æ‰§è¡Œå‡»æ€
```

---

#### ğŸ’» å®Œæ•´å®ç°

**æ­¥éª¤1: å®šä¹‰çŒäººè¡ŒåŠ¨çš„ç»“æ„åŒ–æ¨¡å‹**

```python
from pydantic import BaseModel, Field, field_validator
from typing import Optional, Literal

class HunterActionModelCN(BaseModel):
    """
    çŒäººè¡ŒåŠ¨çš„ç»“æ„åŒ–è¾“å‡ºæ¨¡å‹

    ä½¿ç”¨åœºæ™¯:
    å½“çŒäººè¢«å‡»æ€æˆ–å‡ºå±€æ—¶,ç³»ç»Ÿä¼šè°ƒç”¨æ­¤æ¨¡å‹çº¦æŸå…¶å†³ç­–
    """

    # æ ¸å¿ƒå†³ç­–å­—æ®µ
    use_skill: bool = Field(
        description="æ˜¯å¦ä½¿ç”¨çŒäººæŠ€èƒ½å¼€æª",
        default=False
    )

    # ç›®æ ‡é€‰æ‹©å­—æ®µ
    target_name: Optional[str] = Field(
        description="å¼€æªçš„ç›®æ ‡ç©å®¶å§“å(ä»…å½“use_skill=Trueæ—¶æœ‰æ•ˆ)",
        default=None
    )

    # æ­»å› è®°å½•(ç”±ç³»ç»Ÿå¡«å……)
    death_cause: Literal["werewolf_kill", "vote_out", "witch_poison"] = Field(
        description="çŒäººçš„æ­»äº¡åŸå› ",
        default="werewolf_kill"
    )

    # å†³ç­–ç†ç”±
    reasoning: str = Field(
        description="åšå‡ºæ­¤å†³ç­–çš„ç†ç”±(100å­—ä»¥å†…)",
        max_length=100,
        default=""
    )

    # ä¿¡å¿ƒç­‰çº§
    confidence: int = Field(
        description="å¯¹ç›®æ ‡æ˜¯ç‹¼äººçš„ä¿¡å¿ƒç¨‹åº¦(1-10)",
        ge=1,
        le=10,
        default=5
    )

    @field_validator('use_skill')
    @classmethod
    def validate_skill_usage(cls, v, info):
        """
        è§„åˆ™1: è¢«å¥³å·«æ¯’æ­»æ—¶ä¸èƒ½å¼€æª
        """
        if info.data.get('death_cause') == 'witch_poison' and v:
            raise ValueError("çŒäººè¢«å¥³å·«æ¯’æ­»æ—¶æ— æ³•ä½¿ç”¨æŠ€èƒ½(å·²è¢«ç¼´æ¢°)")
        return v

    @field_validator('target_name')
    @classmethod
    def validate_target(cls, v, info):
        """
        è§„åˆ™2: å¦‚æœé€‰æ‹©å¼€æª,å¿…é¡»æŒ‡å®šç›®æ ‡
        """
        if info.data.get('use_skill') and not v:
            raise ValueError("é€‰æ‹©å¼€æªæ—¶å¿…é¡»æŒ‡å®šç›®æ ‡ç©å®¶")

        if not info.data.get('use_skill') and v:
            raise ValueError("æœªé€‰æ‹©å¼€æªæ—¶ä¸åº”æŒ‡å®šç›®æ ‡")

        return v

    @field_validator('target_name')
    @classmethod
    def validate_target_not_self(cls, v, info):
        """
        è§„åˆ™3: ä¸èƒ½å¯¹è‡ªå·±å¼€æª
        """
        # å‡è®¾çŒäººçš„åå­—å­˜å‚¨åœ¨ä¸Šä¸‹æ–‡ä¸­
        hunter_name = info.context.get('hunter_name') if info.context else None

        if v and hunter_name and v == hunter_name:
            raise ValueError("çŒäººä¸èƒ½å¯¹è‡ªå·±å¼€æª")

        return v

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_hunter_model():
    """æ¼”ç¤ºæ¨¡å‹çš„éªŒè¯èƒ½åŠ›"""

    # âœ… åˆæ³•æ“ä½œ1: æ­£å¸¸å¼€æª
    valid_action_1 = HunterActionModelCN(
        use_skill=True,
        target_name="æ›¹æ“",
        death_cause="werewolf_kill",
        reasoning="æ›¹æ“åœ¨ç¬¬2è½®å‘è¨€æ—¶é€»è¾‘çŸ›ç›¾,æ€€ç–‘æ˜¯ç‹¼äºº",
        confidence=8
    )
    print("âœ… åˆæ³•æ“ä½œ:", valid_action_1)

    # âœ… åˆæ³•æ“ä½œ2: æ”¾å¼ƒå¼€æª
    valid_action_2 = HunterActionModelCN(
        use_skill=False,
        target_name=None,
        death_cause="vote_out",
        reasoning="ä¿¡æ¯ä¸è¶³,ä¸æƒ³è¯¯ä¼¤å¥½äºº",
        confidence=3
    )
    print("âœ… åˆæ³•æ“ä½œ:", valid_action_2)

    # âŒ éæ³•æ“ä½œ1: è¢«æ¯’åå¼€æª
    try:
        invalid_action_1 = HunterActionModelCN(
            use_skill=True,
            target_name="å­™æƒ",
            death_cause="witch_poison"  # è¢«æ¯’æ­»
        )
    except ValueError as e:
        print("âŒ è¿è§„æ“ä½œè¢«æ‹¦æˆª:", e)

    # âŒ éæ³•æ“ä½œ2: å¼€æªä½†æœªæŒ‡å®šç›®æ ‡
    try:
        invalid_action_2 = HunterActionModelCN(
            use_skill=True,
            target_name=None  # ç¼ºå°‘ç›®æ ‡
        )
    except ValueError as e:
        print("âŒ è¿è§„æ“ä½œè¢«æ‹¦æˆª:", e)
```

**è¿è¡Œæ•ˆæœ**:

```
âœ… åˆæ³•æ“ä½œ: use_skill=True target_name='æ›¹æ“' death_cause='werewolf_kill'...
âœ… åˆæ³•æ“ä½œ: use_skill=False target_name=None death_cause='vote_out'...
âŒ è¿è§„æ“ä½œè¢«æ‹¦æˆª: çŒäººè¢«å¥³å·«æ¯’æ­»æ—¶æ— æ³•ä½¿ç”¨æŠ€èƒ½(å·²è¢«ç¼´æ¢°)
âŒ è¿è§„æ“ä½œè¢«æ‹¦æˆª: é€‰æ‹©å¼€æªæ—¶å¿…é¡»æŒ‡å®šç›®æ ‡ç©å®¶
```

---

**æ­¥éª¤2: æ‰©å±•çŒäººæ­»äº¡åˆ¤æ–­æ¨¡å‹**

é™¤äº†è¡ŒåŠ¨æ¨¡å‹,æˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªæ¨¡å‹æ¥çº¦æŸçŒäººå¯¹æ­»äº¡åŸå› çš„æ¨ç†:

```python
class HunterDeathAnalysisModelCN(BaseModel):
    """
    çŒäººæ­»äº¡åˆ†ææ¨¡å‹

    ç”¨äºçº¦æŸçŒäººå¯¹è‡ªå·±æ­»å› çš„æ¨ç†å’Œä¿¡æ¯å…¬å¼€
    """

    suspected_killers: list[str] = Field(
        description="æ€€ç–‘çš„å‡»æ€è€…åˆ—è¡¨",
        default_factory=list
    )

    key_evidence: str = Field(
        description="æ”¯æŒåˆ¤æ–­çš„å…³é”®è¯æ®",
        max_length=200
    )

    reveal_information: bool = Field(
        description="æ˜¯å¦å…¬å¼€è‡ªå·±æŒæ¡çš„å…³é”®ä¿¡æ¯",
        default=True
    )

    information_to_reveal: Optional[str] = Field(
        description="è¦å…¬å¼€çš„ä¿¡æ¯å†…å®¹",
        default=None
    )

    @field_validator('information_to_reveal')
    @classmethod
    def validate_reveal_content(cls, v, info):
        """å¦‚æœé€‰æ‹©å…¬å¼€ä¿¡æ¯,å¿…é¡»æä¾›å†…å®¹"""
        if info.data.get('reveal_information') and not v:
            raise ValueError("é€‰æ‹©å…¬å¼€ä¿¡æ¯æ—¶å¿…é¡»æä¾›å…·ä½“å†…å®¹")
        return v

# å®Œæ•´çš„çŒäººæ™ºèƒ½ä½“é›†æˆç¤ºä¾‹
class HunterAgent:
    def __init__(self, name: str, character: str):
        self.name = name
        self.character = character  # ä¸‰å›½äººç‰©
        self.is_alive = True
        self.has_used_skill = False

    async def on_death(
        self,
        death_cause: Literal["werewolf_kill", "vote_out", "witch_poison"],
        alive_players: list[str]
    ) -> Optional[str]:
        """
        çŒäººæ­»äº¡æ—¶çš„å¤„ç†é€»è¾‘

        Returns:
            è¢«å‡»æ€çš„ç©å®¶åå­—,å¦‚æœæ”¾å¼ƒå¼€æªåˆ™è¿”å›None
        """

        # 1. åˆ†ææ­»å› 
        analysis = await self.analyze_death(death_cause)

        # 2. å†³å®šæ˜¯å¦å¼€æª
        action = await self.decide_action(
            death_cause=death_cause,
            alive_players=alive_players,
            analysis=analysis
        )

        # 3. å…¬å¼€ä¿¡æ¯(å¦‚æœé€‰æ‹©å…¬å¼€)
        if analysis.reveal_information:
            print(f"[{self.name}é—è¨€] {analysis.information_to_reveal}")

        # 4. æ‰§è¡Œå¼€æª
        if action.use_skill:
            print(f"ğŸ’¥ {self.name}({self.character})å¼€æªå‡»æ€äº†{action.target_name}!")
            print(f"   ç†ç”±: {action.reasoning}")
            self.has_used_skill = True
            return action.target_name
        else:
            print(f"ğŸ¤ {self.name}({self.character})é€‰æ‹©ä¸å¼€æª")
            return None

    async def decide_action(
        self,
        death_cause: str,
        alive_players: list[str],
        analysis: HunterDeathAnalysisModelCN
    ) -> HunterActionModelCN:
        """ä½¿ç”¨LLMç”Ÿæˆç»“æ„åŒ–å†³ç­–"""

        prompt = f"""ä½ æ˜¯{self.character},æ‰®æ¼”çŒäººè§’è‰²ã€‚
ä½ åˆšåˆš{self._get_death_description(death_cause)}ã€‚

å­˜æ´»ç©å®¶: {', '.join(alive_players)}
ä½ çš„åˆ†æ: {analysis.key_evidence}

è¯·å†³å®šæ˜¯å¦å¼€æªä»¥åŠç›®æ ‡ã€‚è¾“å‡ºå¿…é¡»ç¬¦åˆHunterActionModelCNæ ¼å¼ã€‚"""

        # è°ƒç”¨LLM,å¼ºåˆ¶ä½¿ç”¨ç»“æ„åŒ–è¾“å‡º
        response = await self.llm(
            prompt,
            structured_model=HunterActionModelCN,
            validation_context={"hunter_name": self.name}
        )

        return response

    def _get_death_description(self, cause: str) -> str:
        """å°†æ­»å› è½¬æ¢ä¸ºè‡ªç„¶è¯­è¨€"""
        descriptions = {
            "werewolf_kill": "è¢«ç‹¼äººå‡»æ€",
            "vote_out": "è¢«æŠ•ç¥¨å‡ºå±€",
            "witch_poison": "è¢«å¥³å·«æ¯’æ­»"
        }
        return descriptions.get(cause, "æ­»äº¡")
```

---

**æ­¥éª¤3: æ¸¸æˆæµç¨‹é›†æˆ**

```python
async def hunter_death_phase(
    game_state: GameState,
    hunter: HunterAgent,
    death_cause: str
) -> Optional[str]:
    """
    å¤„ç†çŒäººæ­»äº¡é˜¶æ®µ

    Returns:
        è¢«çŒäººå‡»æ€çš„ç©å®¶åå­—
    """

    print(f"\n{'='*60}")
    print(f"ğŸ’€ {hunter.name}({hunter.character})å·²æ­»äº¡ - è§¦å‘çŒäººæŠ€èƒ½åˆ¤å®š")
    print(f"{'='*60}")

    # æ£€æŸ¥æ˜¯å¦è¢«å¥³å·«æ¯’æ­»
    if death_cause == "witch_poison":
        print("âš ï¸  çŒäººè¢«å¥³å·«æ¯’æ­»,æŠ€èƒ½å·²è¢«ç¼´æ¢°,æ— æ³•å¼€æª")
        return None

    # çŒäººå†³ç­–
    victim = await hunter.on_death(
        death_cause=death_cause,
        alive_players=game_state.get_alive_players()
    )

    # å¦‚æœçŒäººå¼€æªå‡»æ€äº†æŸäºº,æ›´æ–°æ¸¸æˆçŠ¶æ€
    if victim:
        game_state.kill_player(victim, cause="hunter_shot")

        # è¿é”ååº”: å¦‚æœè¢«å‡»æ€çš„ä¹Ÿæ˜¯çŒäºº,ç»§ç»­è§¦å‘
        victim_agent = game_state.get_player(victim)
        if isinstance(victim_agent, HunterAgent) and not victim_agent.has_used_skill:
            print(f"\nâš¡ è¿é”ååº”: {victim}ä¹Ÿæ˜¯çŒäºº!")
            await hunter_death_phase(game_state, victim_agent, "hunter_shot")

    return victim

# å®Œæ•´æ¸¸æˆæ¼”ç¤º
async def demo_hunter_gameplay():
    """æ¼”ç¤ºçŒäººåœ¨æ¸¸æˆä¸­çš„å®Œæ•´æµç¨‹"""

    # åˆå§‹åŒ–æ¸¸æˆ
    game = ThreeKingdomsWerewolfGame()

    # æ·»åŠ çŒäººè§’è‰²
    hunter = HunterAgent(name="èµµäº‘", character="èµµäº‘")
    game.add_player(hunter, role="hunter")

    # æ¨¡æ‹Ÿå¤œæ™š:ç‹¼äººå‡»æ€çŒäºº
    print("ğŸŒ™ å¤œæ™šé˜¶æ®µ...")
    killed_by_wolf = "èµµäº‘"

    # è§¦å‘çŒäººæŠ€èƒ½
    victim = await hunter_death_phase(
        game_state=game.state,
        hunter=hunter,
        death_cause="werewolf_kill"
    )

    if victim:
        print(f"\nğŸ“Š æœ€ç»ˆç»“æœ: {hunter.name}å¸¦èµ°äº†{victim}")
```

**è¿è¡Œæ•ˆæœç¤ºä¾‹**:

```
============================================================
ğŸ’€ èµµäº‘(èµµäº‘)å·²æ­»äº¡ - è§¦å‘çŒäººæŠ€èƒ½åˆ¤å®š
============================================================

[èµµäº‘åˆ†ææ­»å› ]
å…³é”®è¯æ®: æ›¹æ“åœ¨ç¬¬3è½®å‘è¨€æ—¶åˆ»æ„å¼•å¯¼è§†çº¿,ä¸”æŠ•ç¥¨é˜¶æ®µè¡¨ç°å¼‚å¸¸

[èµµäº‘é—è¨€] æˆ‘æ€€ç–‘æ›¹æ“å’Œå­™æƒæ˜¯ç‹¼äºº,è¯·å¥½äººæ³¨æ„!

ğŸ’¥ èµµäº‘(èµµäº‘)å¼€æªå‡»æ€äº†æ›¹æ“!
   ç†ç”±: æ›¹æ“åœ¨ç¬¬2è½®å‘è¨€æ—¶é€»è¾‘çŸ›ç›¾,æ€€ç–‘æ˜¯ç‹¼äºº
   ä¿¡å¿ƒç­‰çº§: 8/10

ğŸ“Š æœ€ç»ˆç»“æœ: èµµäº‘å¸¦èµ°äº†æ›¹æ“
```

---

#### ğŸ¯ è®¾è®¡äº®ç‚¹æ€»ç»“

| è®¾è®¡è¦ç´  | å®ç°æ–¹å¼ | ä»·å€¼ |
|---------|---------|------|
| **è§„åˆ™çº¦æŸ** | PydanticéªŒè¯å™¨è‡ªåŠ¨æ£€æŸ¥æ­»å›  | é˜²æ­¢è¢«æ¯’åå¼€æªçš„éæ³•æ“ä½œ |
| **æ•°æ®å®Œæ•´æ€§** | æ¡ä»¶å­—æ®µéªŒè¯ | ç¡®ä¿å¼€æªå¿…é¡»æœ‰ç›®æ ‡ |
| **æ¸¸æˆå¹³è¡¡** | ç¦æ­¢è‡ªæ€éªŒè¯ | é˜²æ­¢çŒäººæ»¥ç”¨æŠ€èƒ½ |
| **å¯è¿½æº¯æ€§** | reasoningå­—æ®µå¼ºåˆ¶å¡«å†™ | ä¾¿äºå›æ”¾å’Œè°ƒè¯• |
| **è¿é”ååº”** | é€’å½’è°ƒç”¨hunter_death_phase | æ”¯æŒçŒäººäº’å°„çš„è¿é” |
| **ä¿¡æ¯å…¬å¼€** | reveal_informationæœºåˆ¶ | æ¨¡æ‹ŸçœŸå®é—è¨€ç¯èŠ‚ |

---

### è§£ç­”3.3: åˆ†å¸ƒå¼éƒ¨ç½²çš„æŠ€æœ¯æŒ‘æˆ˜

#### ğŸŒ åˆ†å¸ƒå¼æ¶æ„å›¾

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   Redis/Kafka   â”‚
                    â”‚    (MsgHub)     â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                â”‚                â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
    â”‚  æœåŠ¡å™¨1     â”‚  â”‚  æœåŠ¡å™¨2    â”‚  â”‚   æœåŠ¡å™¨3   â”‚
    â”‚              â”‚  â”‚             â”‚  â”‚             â”‚
    â”‚  ç‹¼äººæ™ºèƒ½ä½“  â”‚  â”‚ é¢„è¨€å®¶æ™ºèƒ½ä½“â”‚  â”‚  å¥³å·«æ™ºèƒ½ä½“ â”‚
    â”‚  (æ›¹æ“,å­™æƒ) â”‚  â”‚  (è¯¸è‘›äº®)   â”‚  â”‚   (å¼ é£)    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         åŒ—äº¬              ä¸Šæµ·              æ·±åœ³
```

åœ¨è¿™ç§åˆ†å¸ƒå¼æ¶æ„ä¸‹,è™½ç„¶è·å¾—äº†æ‰©å±•æ€§å’Œå®¹é”™æ€§,ä½†ä¹Ÿå¼•å…¥äº†æ–°çš„æŒ‘æˆ˜ã€‚

---

#### âš ï¸ æŒ‘æˆ˜1: æ¶ˆæ¯é¡ºåºæ€§ (Message Ordering)

**é—®é¢˜åœºæ™¯**:

```
ç‹¼äººæ€ç¬¬3è½®æŠ•ç¥¨é˜¶æ®µ:

æ—¶é—´è½´:
T1: æ›¹æ“(æœåŠ¡å™¨1) â†’ æŠ•ç¥¨ç»™è¯¸è‘›äº®
T2: å­™æƒ(æœåŠ¡å™¨1) â†’ æŠ•ç¥¨ç»™èµµäº‘
T3: è¯¸è‘›äº®(æœåŠ¡å™¨2) â†’ æŠ•ç¥¨ç»™æ›¹æ“

ç½‘ç»œå»¶è¿Ÿå½±å“:
æœåŠ¡å™¨1 â†’ MsgHub: 10ms
æœåŠ¡å™¨2 â†’ MsgHub: 50ms (ç½‘ç»œæ‹¥å µ)

MsgHubæ¥æ”¶é¡ºåº:
1. æ›¹æ“çš„æŠ•ç¥¨ (T1+10ms)
2. å­™æƒçš„æŠ•ç¥¨ (T2+10ms)
3. è¯¸è‘›äº®çš„æŠ•ç¥¨ (T3+50ms)  â† å®é™…æœ€æ—©å‘å‡º,ä½†æœ€æ™šåˆ°è¾¾!

é—®é¢˜:
å¦‚æœæŒ‰æ¥æ”¶é¡ºåºå¤„ç†,è¯¸è‘›äº®çš„æŠ•ç¥¨å¯èƒ½è¢«è¯¯åˆ¤ä¸º"è¶…æ—¶"
```

**è§£å†³æ–¹æ¡ˆ: é€»è¾‘æ—¶é’Ÿ (Lamport Timestamp)**

```python
import time
from dataclasses import dataclass

@dataclass
class OrderedMessage:
    """å¸¦é€»è¾‘æ—¶é’Ÿçš„æ¶ˆæ¯"""
    sender: str
    content: str
    lamport_time: int  # é€»è¾‘æ—¶é—´æˆ³
    physical_time: float  # ç‰©ç†æ—¶é—´æˆ³
    round_id: int  # æ¸¸æˆå›åˆID

class DistributedMsgHub:
    def __init__(self):
        self.lamport_clock = 0
        self.message_buffer = []  # æ¶ˆæ¯ç¼“å†²åŒº
        self.lock = asyncio.Lock()

    async def send_message(self, sender: str, content: str, round_id: int):
        """æ™ºèƒ½ä½“å‘é€æ¶ˆæ¯"""
        async with self.lock:
            # å¢åŠ é€»è¾‘æ—¶é’Ÿ
            self.lamport_clock += 1

            msg = OrderedMessage(
                sender=sender,
                content=content,
                lamport_time=self.lamport_clock,
                physical_time=time.time(),
                round_id=round_id
            )

            # å‘é€åˆ°æ¶ˆæ¯é˜Ÿåˆ—
            await self.kafka_producer.send('game_messages', msg)
            return msg.lamport_time

    async def receive_messages(self, round_id: int, timeout: float = 5.0):
        """æ¥æ”¶å¹¶æ’åºæ¶ˆæ¯"""
        deadline = time.time() + timeout
        buffer = []

        # 1. æ”¶é›†æ¶ˆæ¯åˆ°ç¼“å†²åŒº
        while time.time() < deadline:
            msg = await self.kafka_consumer.poll(timeout=0.1)
            if msg and msg.round_id == round_id:
                buffer.append(msg)

        # 2. æŒ‰é€»è¾‘æ—¶é’Ÿæ’åº
        buffer.sort(key=lambda m: (m.lamport_time, m.sender))

        # 3. æ£€æµ‹é¡ºåºå¼‚å¸¸
        for i in range(len(buffer) - 1):
            if buffer[i].physical_time > buffer[i+1].physical_time + 1.0:
                logger.warning(
                    f"æ¶ˆæ¯ä¹±åº: {buffer[i].sender}çš„æ¶ˆæ¯ç‰©ç†æ—¶é—´æ™šäº{buffer[i+1].sender},ä½†é€»è¾‘æ—¶é—´æ›´æ—©"
                )

        return buffer

# ä½¿ç”¨ç¤ºä¾‹
async def voting_phase_distributed(game_round: int):
    """åˆ†å¸ƒå¼æŠ•ç¥¨é˜¶æ®µ"""
    msg_hub = DistributedMsgHub()

    # æ‰€æœ‰æ™ºèƒ½ä½“å¹¶å‘æŠ•ç¥¨
    vote_tasks = []
    for player in all_players:
        task = player.vote(msg_hub, round_id=game_round)
        vote_tasks.append(task)

    # ç­‰å¾…æ‰€æœ‰æŠ•ç¥¨å‘é€
    await asyncio.gather(*vote_tasks)

    # æ¥æ”¶å¹¶æ’åºæŠ•ç¥¨(ä¿è¯é¡ºåº)
    votes = await msg_hub.receive_messages(
        round_id=game_round,
        timeout=10.0
    )

    # æŒ‰é€»è¾‘æ—¶é’Ÿé¡ºåºå¤„ç†æŠ•ç¥¨
    for vote in votes:
        print(f"[æ—¶é’Ÿ{vote.lamport_time}] {vote.sender}: {vote.content}")

    return votes
```

**æ•ˆæœ**:

```
# è¾“å‡º(æŒ‰é€»è¾‘æ—¶é—´æ’åº,ä¸å—ç½‘ç»œå»¶è¿Ÿå½±å“)
[æ—¶é’Ÿ1] æ›¹æ“: æŠ•ç¥¨ç»™è¯¸è‘›äº®
[æ—¶é’Ÿ2] å­™æƒ: æŠ•ç¥¨ç»™èµµäº‘
[æ—¶é’Ÿ3] è¯¸è‘›äº®: æŠ•ç¥¨ç»™æ›¹æ“

âœ… å³ä½¿è¯¸è‘›äº®çš„æ¶ˆæ¯å› ç½‘ç»œå»¶è¿Ÿæœ€æ™šåˆ°è¾¾,
   é€»è¾‘æ—¶é’Ÿç¡®ä¿äº†å®ƒè¢«æ­£ç¡®æ’åºå¤„ç†
```

---

#### âš ï¸ æŒ‘æˆ˜2: çŠ¶æ€ä¸€è‡´æ€§ (State Consistency)

**é—®é¢˜åœºæ™¯**:

```
åˆ†å¸ƒå¼ç¯å¢ƒä¸‹çš„"ç‹¼äººæ€äºº"é˜¶æ®µ:

åˆå§‹çŠ¶æ€:
å­˜æ´»ç©å®¶ = [æ›¹æ“, å­™æƒ, è¯¸è‘›äº®, èµµäº‘, å¼ é£]

å¹¶å‘æ“ä½œ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æœåŠ¡å™¨1(ç‹¼äºº) â”‚  æœåŠ¡å™¨2(å¥³å·«) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ T1: è¯»å–å­˜æ´»åˆ—è¡¨â”‚                â”‚
â”‚ [æ›¹,å­™,è¯¸,èµµ,å¼ ]â”‚                â”‚
â”‚                 â”‚ T2: è¯»å–å­˜æ´»åˆ—è¡¨â”‚
â”‚                 â”‚ [æ›¹,å­™,è¯¸,èµµ,å¼ ]â”‚
â”‚ T3: å‡»æ€è¯¸è‘›äº®  â”‚                â”‚
â”‚ æ›´æ–°:          â”‚                â”‚
â”‚ [æ›¹,å­™,èµµ,å¼ ]  â”‚                â”‚
â”‚                 â”‚ T4: æ¯’æ­»èµµäº‘   â”‚
â”‚                 â”‚ æ›´æ–°:          â”‚
â”‚                 â”‚ [æ›¹,å­™,è¯¸,å¼ ]  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

é—®é¢˜:
ä¸¤ä¸ªæœåŠ¡å™¨çš„çŠ¶æ€ä¸ä¸€è‡´!
æœåŠ¡å™¨1: è¯¸è‘›äº®æ­»,èµµäº‘æ´»
æœåŠ¡å™¨2: èµµäº‘æ­»,è¯¸è‘›äº®æ´»
```

**è§£å†³æ–¹æ¡ˆ: åˆ†å¸ƒå¼äº‹åŠ¡ + æœ€ç»ˆä¸€è‡´æ€§**

```python
from redis import Redis
from typing import List, Optional

class DistributedGameState:
    """ä½¿ç”¨Rediså®ç°åˆ†å¸ƒå¼æ¸¸æˆçŠ¶æ€"""

    def __init__(self, redis_client: Redis):
        self.redis = redis_client
        self.game_id = "werewolf_game_001"

    async def atomic_kill_player(
        self,
        killer_role: str,
        victim: str,
        round_id: int
    ) -> bool:
        """
        åŸå­æ€§å‡»æ€æ“ä½œ

        ä½¿ç”¨Redis Luaè„šæœ¬ä¿è¯åŸå­æ€§
        """

        # Luaè„šæœ¬:åŸå­æ€§æ£€æŸ¥å¹¶æ›´æ–°
        lua_script = """
        local game_key = KEYS[1]
        local death_log_key = KEYS[2]
        local victim = ARGV[1]
        local killer_role = ARGV[2]
        local round_id = ARGV[3]
        local timestamp = ARGV[4]

        -- 1. æ£€æŸ¥ç©å®¶æ˜¯å¦å­˜æ´»
        local alive_players = redis.call('SMEMBERS', game_key)
        local is_alive = false
        for _, player in ipairs(alive_players) do
            if player == victim then
                is_alive = true
                break
            end
        end

        if not is_alive then
            return 0  -- ç©å®¶å·²æ­»äº¡,æ“ä½œå¤±è´¥
        end

        -- 2. æ£€æŸ¥æœ¬å›åˆæ˜¯å¦å·²æœ‰å‡»æ€è®°å½•
        local existing_kill = redis.call('HGET', death_log_key, round_id)
        if existing_kill then
            return -1  -- æœ¬å›åˆå·²æœ‰å‡»æ€,ä¸èƒ½é‡å¤
        end

        -- 3. æ‰§è¡Œå‡»æ€
        redis.call('SREM', game_key, victim)

        -- 4. è®°å½•æ­»äº¡æ—¥å¿—
        local death_record = cjson.encode({
            victim = victim,
            killer = killer_role,
            round = round_id,
            timestamp = timestamp
        })
        redis.call('HSET', death_log_key, round_id, death_record)

        return 1  -- æˆåŠŸ
        """

        # æ‰§è¡ŒåŸå­æ“ä½œ
        result = await self.redis.eval(
            lua_script,
            keys=[
                f"{self.game_id}:alive_players",
                f"{self.game_id}:death_log"
            ],
            args=[
                victim,
                killer_role,
                str(round_id),
                str(time.time())
            ]
        )

        if result == 0:
            logger.warning(f"{victim}å·²æ­»äº¡,å‡»æ€æ“ä½œè¢«æ‹’ç»")
            return False
        elif result == -1:
            logger.warning(f"ç¬¬{round_id}è½®å·²æœ‰å‡»æ€è®°å½•,æ“ä½œè¢«æ‹’ç»")
            return False
        else:
            logger.info(f"âœ… {killer_role}æˆåŠŸå‡»æ€{victim}")
            return True

    async def get_alive_players(self) -> List[str]:
        """è·å–å­˜æ´»ç©å®¶åˆ—è¡¨(è¯»å–ä¸€è‡´æ€§è§†å›¾)"""
        players = await self.redis.smembers(
            f"{self.game_id}:alive_players"
        )
        return list(players)

    async def get_death_log(self, round_id: int) -> Optional[dict]:
        """è·å–æŒ‡å®šå›åˆçš„æ­»äº¡è®°å½•"""
        record = await self.redis.hget(
            f"{self.game_id}:death_log",
            str(round_id)
        )
        if record:
            import json
            return json.loads(record)
        return None

# ä½¿ç”¨ç¤ºä¾‹
async def distributed_night_phase(round_id: int):
    """åˆ†å¸ƒå¼å¤œæ™šé˜¶æ®µ"""
    redis_client = Redis(host='game-state-server')
    game_state = DistributedGameState(redis_client)

    # ç‹¼äººå‡»æ€(æœåŠ¡å™¨1)
    werewolf_task = game_state.atomic_kill_player(
        killer_role="werewolf",
        victim="è¯¸è‘›äº®",
        round_id=round_id
    )

    # å¥³å·«æ¯’æ€(æœåŠ¡å™¨2)
    witch_task = game_state.atomic_kill_player(
        killer_role="witch",
        victim="èµµäº‘",
        round_id=round_id
    )

    # å¹¶å‘æ‰§è¡Œ
    results = await asyncio.gather(werewolf_task, witch_task)

    # ç”±äºåŸå­æ€§ä¿è¯,åªæœ‰ä¸€ä¸ªä¼šæˆåŠŸ
    if results[0]:
        print("âœ… ç‹¼äººå‡»æ€æˆåŠŸ")
    if results[1]:
        print("âœ… å¥³å·«æ¯’æ€æˆåŠŸ")

    # è·å–æœ€ç»ˆä¸€è‡´çš„å­˜æ´»åˆ—è¡¨
    alive = await game_state.get_alive_players()
    print(f"å­˜æ´»ç©å®¶: {alive}")
```

**æ•ˆæœ**:

```
âœ… ç‹¼äººå‡»æ€æˆåŠŸ
âš ï¸  å¥³å·«æ¯’æ€è¢«æ‹’ç»: ç¬¬3è½®å·²æœ‰å‡»æ€è®°å½•

å­˜æ´»ç©å®¶: ['æ›¹æ“', 'å­™æƒ', 'èµµäº‘', 'å¼ é£']

âœ… æ‰€æœ‰æœåŠ¡å™¨çœ‹åˆ°çš„çŠ¶æ€ä¸€è‡´!
```

---

#### âš ï¸ æŒ‘æˆ˜3: ç½‘ç»œåˆ†åŒº (Network Partition)

**é—®é¢˜åœºæ™¯**:

```
æœºæˆ¿æ•…éšœå¯¼è‡´ç½‘ç»œåˆ†åŒº:

æ­£å¸¸çŠ¶æ€:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç‹¼äººA  â”‚â”€â”€â”€â”€>â”‚ MsgHub â”‚<â”€â”€â”€â”€â”‚ é¢„è¨€å®¶ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  åŒ—äº¬           ä¸­å¿ƒ           ä¸Šæµ·

ç½‘ç»œåˆ†åŒº:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  X  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç‹¼äººA  â”‚â”€â”€â”€â”€>â”‚ MsgHub â”‚     â”‚ é¢„è¨€å®¶ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  åŒ—äº¬           ä¸­å¿ƒ           ä¸Šæµ·(æ–­ç½‘)

é—®é¢˜:
1. é¢„è¨€å®¶æ— æ³•æ¥æ”¶å…¶ä»–ç©å®¶çš„æ¶ˆæ¯
2. å…¶ä»–ç©å®¶ä¸çŸ¥é“é¢„è¨€å®¶æ‰çº¿
3. æ¸¸æˆæ˜¯å¦åº”è¯¥æš‚åœ?
```

**è§£å†³æ–¹æ¡ˆ: å¿ƒè·³æ£€æµ‹ + é™çº§ç­–ç•¥**

```python
from datetime import datetime, timedelta
from enum import Enum

class AgentStatus(Enum):
    ONLINE = "online"
    OFFLINE = "offline"
    DEGRADED = "degraded"  # é™çº§æ¨¡å¼(ç½‘ç»œä¸ç¨³å®š)

class HeartbeatManager:
    """åˆ†å¸ƒå¼å¿ƒè·³ç®¡ç†å™¨"""

    def __init__(self, redis_client: Redis):
        self.redis = redis_client
        self.heartbeat_interval = 3.0  # 3ç§’å‘é€ä¸€æ¬¡å¿ƒè·³
        self.timeout_threshold = 10.0  # 10ç§’æ— å¿ƒè·³åˆ™åˆ¤å®šç¦»çº¿

    async def send_heartbeat(self, agent_name: str):
        """æ™ºèƒ½ä½“å‘é€å¿ƒè·³"""
        await self.redis.setex(
            f"heartbeat:{agent_name}",
            time=int(self.timeout_threshold),
            value=datetime.now().isoformat()
        )

    async def check_agent_status(self, agent_name: str) -> AgentStatus:
        """æ£€æŸ¥æ™ºèƒ½ä½“çŠ¶æ€"""
        last_heartbeat = await self.redis.get(f"heartbeat:{agent_name}")

        if not last_heartbeat:
            return AgentStatus.OFFLINE

        last_time = datetime.fromisoformat(last_heartbeat.decode())
        elapsed = (datetime.now() - last_time).total_seconds()

        if elapsed > self.timeout_threshold:
            return AgentStatus.OFFLINE
        elif elapsed > self.heartbeat_interval * 2:
            return AgentStatus.DEGRADED  # å¿ƒè·³ä¸ç¨³å®š
        else:
            return AgentStatus.ONLINE

    async def get_all_statuses(self, agents: List[str]) -> dict:
        """æ‰¹é‡æ£€æŸ¥æ‰€æœ‰æ™ºèƒ½ä½“çŠ¶æ€"""
        statuses = {}
        for agent in agents:
            statuses[agent] = await self.check_agent_status(agent)
        return statuses

class FaultTolerantGameManager:
    """å®¹é”™æ¸¸æˆç®¡ç†å™¨"""

    def __init__(self, heartbeat_manager: HeartbeatManager):
        self.heartbeat = heartbeat_manager
        self.degraded_mode = False

    async def wait_for_players(
        self,
        required_players: List[str],
        timeout: float = 30.0
    ) -> List[str]:
        """
        ç­‰å¾…ç©å®¶å“åº”,æ”¯æŒé™çº§

        Returns:
            å®é™…å“åº”çš„ç©å®¶åˆ—è¡¨
        """
        deadline = time.time() + timeout
        responded = set()

        while time.time() < deadline:
            statuses = await self.heartbeat.get_all_statuses(required_players)

            # ç»Ÿè®¡åœ¨çº¿ç©å®¶
            online_players = [
                name for name, status in statuses.items()
                if status in [AgentStatus.ONLINE, AgentStatus.DEGRADED]
            ]

            # æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å¿…éœ€ç©å®¶éƒ½åœ¨çº¿
            if set(online_players) == set(required_players):
                print("âœ… æ‰€æœ‰ç©å®¶åœ¨çº¿")
                return required_players

            # æ£€æŸ¥ç¦»çº¿ç©å®¶
            offline_players = [
                name for name, status in statuses.items()
                if status == AgentStatus.OFFLINE
            ]

            if offline_players:
                print(f"âš ï¸  æ£€æµ‹åˆ°ç¦»çº¿ç©å®¶: {offline_players}")

                # é™çº§ç­–ç•¥: å¦‚æœè¶…è¿‡50%ç©å®¶åœ¨çº¿,å¯ç”¨é™çº§æ¨¡å¼
                if len(online_players) / len(required_players) >= 0.5:
                    print(f"ğŸ”„ å¯åŠ¨é™çº§æ¨¡å¼,ä½¿ç”¨{len(online_players)}/{len(required_players)}ç©å®¶ç»§ç»­æ¸¸æˆ")
                    self.degraded_mode = True
                    return online_players

            await asyncio.sleep(1.0)

        # è¶…æ—¶å¤„ç†
        raise TimeoutError(f"ç­‰å¾…ç©å®¶å“åº”è¶…æ—¶,ç¦»çº¿: {offline_players}")

    async def execute_phase_with_retry(
        self,
        phase_func,
        max_retries: int = 3
    ):
        """
        æ‰§è¡Œæ¸¸æˆé˜¶æ®µ,æ”¯æŒé‡è¯•
        """
        for attempt in range(max_retries):
            try:
                result = await phase_func()
                return result

            except NetworkError as e:
                logger.warning(f"ç½‘ç»œé”™è¯¯(å°è¯•{attempt+1}/{max_retries}): {e}")

                if attempt < max_retries - 1:
                    # æŒ‡æ•°é€€é¿é‡è¯•
                    await asyncio.sleep(2 ** attempt)
                else:
                    # æœ€ç»ˆå¤±è´¥,å¯ç”¨é™çº§
                    logger.error("å¤šæ¬¡é‡è¯•å¤±è´¥,å¯ç”¨é™çº§æ¨¡å¼")
                    self.degraded_mode = True
                    return await self._degraded_execution(phase_func)

# ä½¿ç”¨ç¤ºä¾‹
async def robust_werewolf_phase(round_id: int):
    """å®¹é”™çš„ç‹¼äººé˜¶æ®µ"""
    heartbeat = HeartbeatManager(redis_client)
    game_mgr = FaultTolerantGameManager(heartbeat)

    werewolf_agents = ["æ›¹æ“", "å­™æƒ"]

    try:
        # ç­‰å¾…ç‹¼äººå“åº”(æ”¯æŒé™çº§)
        online_werewolves = await game_mgr.wait_for_players(
            required_players=werewolf_agents,
            timeout=15.0
        )

        print(f"å‚ä¸è®¨è®ºçš„ç‹¼äºº: {online_werewolves}")

        # æ‰§è¡Œç‹¼äººè®¨è®º(æ”¯æŒé‡è¯•)
        result = await game_mgr.execute_phase_with_retry(
            phase_func=lambda: werewolf_discussion(online_werewolves),
            max_retries=3
        )

        return result

    except TimeoutError:
        print("âŒ ç‹¼äººé˜¶æ®µè¶…æ—¶,è‡ªåŠ¨è·³è¿‡")
        return None
```

**è¿è¡Œæ•ˆæœ**:

```
# æ­£å¸¸æƒ…å†µ
âœ… æ‰€æœ‰ç©å®¶åœ¨çº¿
å‚ä¸è®¨è®ºçš„ç‹¼äºº: ['æ›¹æ“', 'å­™æƒ']
ç‹¼äººè®¨è®ºå®Œæˆ

# ç½‘ç»œåˆ†åŒºæƒ…å†µ
âš ï¸  æ£€æµ‹åˆ°ç¦»çº¿ç©å®¶: ['å­™æƒ']
ğŸ”„ å¯åŠ¨é™çº§æ¨¡å¼,ä½¿ç”¨1/2ç©å®¶ç»§ç»­æ¸¸æˆ
å‚ä¸è®¨è®ºçš„ç‹¼äºº: ['æ›¹æ“']
âš ï¸  é™çº§æ¨¡å¼: ä»…æ›¹æ“åœ¨çº¿,è‡ªåŠ¨é€‰æ‹©å‡»æ€ç›®æ ‡

# å®Œå…¨æ–­ç½‘æƒ…å†µ
âš ï¸  æ£€æµ‹åˆ°ç¦»çº¿ç©å®¶: ['æ›¹æ“', 'å­™æƒ']
âŒ ç‹¼äººé˜µè¥å…¨éƒ¨ç¦»çº¿,è‡ªåŠ¨è·³è¿‡ç‹¼äººé˜¶æ®µ
```

---

#### ğŸ“Š åˆ†å¸ƒå¼æŒ‘æˆ˜æ€»ç»“

| æŒ‘æˆ˜ | æ ¹å›  | è§£å†³æ–¹æ¡ˆ | ä»£ä»· |
|------|------|---------|------|
| **æ¶ˆæ¯ä¹±åº** | ç½‘ç»œå»¶è¿Ÿä¸ä¸€è‡´ | Lamporté€»è¾‘æ—¶é’Ÿ | éœ€è¦ç¼“å†²åŒº,å¢åŠ å»¶è¿Ÿ |
| **çŠ¶æ€ä¸ä¸€è‡´** | å¹¶å‘å†™å†²çª | RedisåŸå­æ“ä½œ | æ€§èƒ½ä¸‹é™20-30% |
| **ç½‘ç»œåˆ†åŒº** | æœºæˆ¿/é“¾è·¯æ•…éšœ | å¿ƒè·³æ£€æµ‹+é™çº§ | æ¸¸æˆä½“éªŒé™çº§ |
| **æ¶ˆæ¯ä¸¢å¤±** | ç½‘ç»œæŠ–åŠ¨ | æ¶ˆæ¯æŒä¹…åŒ–+é‡ä¼  | å­˜å‚¨æˆæœ¬å¢åŠ  |
| **æ—¶é’Ÿæ¼‚ç§»** | æœåŠ¡å™¨æ—¶é—´ä¸åŒæ­¥ | NTPåŒæ­¥+é€»è¾‘æ—¶é’Ÿ | éœ€è¦é¢å¤–åŸºç¡€è®¾æ–½ |

---

è¿™å°±æ˜¯ç¬¬3é¢˜çš„å®Œæ•´è§£ç­”!æ¶µç›–:
1. æ¶ˆæ¯é©±åŠ¨æ¶æ„çš„ä¼˜åŠ¿åˆ†æ
2. çŒäººè§’è‰²çš„å®Œæ•´ç»“æ„åŒ–æ¨¡å‹è®¾è®¡
3. åˆ†å¸ƒå¼éƒ¨ç½²çš„æŠ€æœ¯æŒ‘æˆ˜ä¸è§£å†³æ–¹æ¡ˆ

---

## ä¹ é¢˜4: CAMEL å†²çªè§£å†³ä¸æ‰©å±•

### é¢˜ç›®

åœ¨6.4èŠ‚çš„ `CAMEL` æ¡ˆä¾‹ä¸­ï¼Œæˆ‘ä»¬è®©å¿ƒç†å­¦å®¶å’Œä½œå®¶åä½œåˆ›ä½œç”µå­ä¹¦ã€‚

- åœ¨æ¡ˆä¾‹ä¸­ï¼Œåä½œä¼šåœ¨æ£€æµ‹åˆ° `<CAMEL_TASK_DONE>` æ ‡å¿—æ—¶å¼ºåˆ¶ç»ˆæ­¢ã€‚ä½†å¦‚æœä¸¤ä¸ªæ™ºèƒ½ä½“æ„è§åˆ†æ­§ï¼ˆä¸€ä½è®¤ä¸ºå¯ä»¥ç»ˆæ­¢ï¼Œä¸€ä½è®¤ä¸ºä¸åº”è¯¥ç»ˆæ­¢ï¼‰ï¼Œæ— æ³•è¾¾æˆä¸€è‡´æ€ä¹ˆåŠï¼Ÿè¯·è®¾è®¡ä¸€ä¸ª"å†²çªè§£å†³"çš„å…¼å®¹æœºåˆ¶ã€‚
- `CAMEL` æœ€åˆè®¾è®¡ç”¨äºåŒæ™ºèƒ½ä½“åä½œï¼Œä½†ç°åœ¨å·²ç»æ‰©å±•æ”¯æŒå¤šæ™ºèƒ½ä½“ã€‚è¯·æŸ¥é˜… `CAMEL` çš„æœ€æ–°æ–‡æ¡£ï¼Œäº†è§£å…¶å¤šæ™ºèƒ½ä½“åä½œæ¨¡å— `workforce`ï¼Œå¹¶ç»“åˆæ¶æ„å›¾è¯´æ˜å…¶ä¸ `AutoGen` çš„ç¾¤èŠæ¨¡å¼æœ‰ä½•ä¸åŒã€‚

---

### è§£ç­”4.1: å†²çªè§£å†³æœºåˆ¶è®¾è®¡

#### ğŸ¤” é—®é¢˜åˆ†æ

**å†²çªåœºæ™¯ç¤ºä¾‹**:

```
ç”µå­ä¹¦åˆ›ä½œçš„ç¬¬25è½®å¯¹è¯:

å¿ƒç†å­¦å®¶ (AI Assistant):
"æˆ‘è®¤ä¸ºå†…å®¹å·²ç»è¶³å¤Ÿå…¨é¢,æ¶µç›–äº†æ‹–å»¶ç—‡çš„ç†è®ºã€æ¡ˆä¾‹å’Œå®è·µå»ºè®®ã€‚
<CAMEL_TASK_DONE>"

ä½œå®¶ (AI User):
"ç­‰ç­‰!æˆ‘è§‰å¾—è¿˜ç¼ºå°‘ä¸€ä¸ªé‡è¦ç« èŠ‚:å¦‚ä½•å¸®åŠ©ä»–äººå…‹æœæ‹–å»¶ç—‡ã€‚
è¿™å¯¹è¯»è€…å¾ˆæœ‰ä»·å€¼,ä¸åº”è¯¥ç»“æŸã€‚"

é—®é¢˜:
- ä¸€æ–¹å‘å‡ºäº† CAMEL_TASK_DONE ä¿¡å·
- å¦ä¸€æ–¹æ˜ç¡®è¡¨ç¤ºä¸åŒæ„
- ç³»ç»Ÿåº”è¯¥ç»ˆæ­¢è¿˜æ˜¯ç»§ç»­?
```

---

#### ğŸ’¡ è§£å†³æ–¹æ¡ˆä¸€: å…±è¯†ç¡®è®¤æœºåˆ¶

**æ ¸å¿ƒæ€æƒ³**: åªæœ‰å½“åŒæ–¹éƒ½åŒæ„æ—¶æ‰ç»ˆæ­¢ä»»åŠ¡

```python
from camel.societies import RolePlaying
from camel.messages import BaseMessage
from typing import List, Optional
import re

class ConsensusBasedRolePlaying(RolePlaying):
    """
    æ‰©å±•CAMELçš„RolePlaying,æ·»åŠ å…±è¯†ç¡®è®¤æœºåˆ¶
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.termination_votes = {
            "user": False,      # AI Useræ˜¯å¦æŠ•ç¥¨ç»ˆæ­¢
            "assistant": False  # AI Assistantæ˜¯å¦æŠ•ç¥¨ç»ˆæ­¢
        }
        self.consensus_required = True  # æ˜¯å¦éœ€è¦åŒæ–¹ä¸€è‡´åŒæ„

    def check_termination_consensus(
        self,
        user_message: BaseMessage,
        assistant_message: BaseMessage
    ) -> bool:
        """
        æ£€æŸ¥æ˜¯å¦è¾¾æˆç»ˆæ­¢å…±è¯†

        Returns:
            True if both agree to terminate, False otherwise
        """
        # æ£€æŸ¥Useræ˜¯å¦æŠ•ç¥¨ç»ˆæ­¢
        if "<CAMEL_TASK_DONE>" in user_message.content:
            self.termination_votes["user"] = True
            print("ğŸ“Š ä½œå®¶æŠ•ç¥¨: åŒæ„ç»“æŸ")
        else:
            self.termination_votes["user"] = False

        # æ£€æŸ¥Assistantæ˜¯å¦æŠ•ç¥¨ç»ˆæ­¢
        if "<CAMEL_TASK_DONE>" in assistant_message.content:
            self.termination_votes["assistant"] = True
            print("ğŸ“Š å¿ƒç†å­¦å®¶æŠ•ç¥¨: åŒæ„ç»“æŸ")
        else:
            self.termination_votes["assistant"] = False

        # åˆ¤æ–­æ˜¯å¦è¾¾æˆå…±è¯†
        if self.consensus_required:
            consensus = all(self.termination_votes.values())
            if consensus:
                print("âœ… åŒæ–¹è¾¾æˆå…±è¯†,ä»»åŠ¡ç»“æŸ")
            elif any(self.termination_votes.values()):
                print("âš ï¸  å­˜åœ¨åˆ†æ­§,ç»§ç»­åä½œ...")
                # è§¦å‘å†²çªè§£å†³æµç¨‹
                self._trigger_conflict_resolution()
            return consensus
        else:
            # ä»»ä¸€æ–¹åŒæ„å³å¯ç»ˆæ­¢(åŸå§‹CAMELè¡Œä¸º)
            return any(self.termination_votes.values())

    def _trigger_conflict_resolution(self):
        """è§¦å‘å†²çªè§£å†³æµç¨‹"""
        print("\n" + "="*60)
        print("ğŸ”„ å¯åŠ¨å†²çªè§£å†³æµç¨‹")
        print("="*60)

        # æ³¨å…¥è°ƒåœæ¶ˆæ¯
        resolution_prompt = """
[ç³»ç»Ÿæç¤º]
æ£€æµ‹åˆ°åä½œåŒæ–¹å¯¹ä»»åŠ¡å®Œæˆåº¦å­˜åœ¨åˆ†æ­§ã€‚è¯·è¿›è¡Œæœ€åä¸€è½®æ²Ÿé€š:

1. æå‡ºåˆ†æ­§æ–¹: æ˜ç¡®è¯´æ˜è¿˜éœ€è¦è¡¥å……ä»€ä¹ˆå†…å®¹,ä»¥åŠä¸ºä»€ä¹ˆé‡è¦
2. ä¸»å¼ ç»“æŸæ–¹: è¯„ä¼°å¯¹æ–¹çš„å»ºè®®æ˜¯å¦åˆç†
3. åŒæ–¹è¾¾æˆä¸€è‡´: è¦ä¹ˆè¡¥å……å†…å®¹,è¦ä¹ˆç¡®è®¤å½“å‰ç‰ˆæœ¬å·²è¶³å¤Ÿ

è¯·åœ¨è¿™ä¸€è½®å¯¹è¯åæ˜ç¡®è¡¨æ€æ˜¯å¦ç»“æŸ (ä½¿ç”¨<CAMEL_TASK_DONE>)ã€‚
"""
        print(resolution_prompt)

# ä½¿ç”¨ç¤ºä¾‹
async def collaborative_writing_with_consensus():
    """å¸¦å…±è¯†æœºåˆ¶çš„åä½œå†™ä½œ"""

    task_prompt = "åˆ›ä½œä¸€æœ¬å…³äºæ‹–å»¶ç—‡å¿ƒç†å­¦çš„ç”µå­ä¹¦..."

    # ä½¿ç”¨å¢å¼ºçš„RolePlaying
    session = ConsensusBasedRolePlaying(
        assistant_role_name="å¿ƒç†å­¦å®¶",
        user_role_name="ä½œå®¶",
        task_prompt=task_prompt,
        with_task_specify=False
    )

    chat_turn_limit = 50
    n = 0

    input_msg = session.init_chat()

    while n < chat_turn_limit:
        n += 1

        assistant_response, user_response = session.step(input_msg)

        if assistant_response.msg is None or user_response.msg is None:
            break

        print(f"\n[ç¬¬{n}è½®]")
        print(f"ä½œå®¶: {user_response.msg.content[:200]}...")
        print(f"å¿ƒç†å­¦å®¶: {assistant_response.msg.content[:200]}...")

        # æ£€æŸ¥å…±è¯†
        if session.check_termination_consensus(
            user_response.msg,
            assistant_response.msg
        ):
            print("\nâœ… åä½œå®Œæˆ!")
            break

        input_msg = assistant_response.msg

    return session
```

**è¿è¡Œæ•ˆæœ**:

```
[ç¬¬24è½®]
ä½œå®¶: å†…å®¹å·²ç»å¾ˆå…¨é¢äº†...<CAMEL_TASK_DONE>
å¿ƒç†å­¦å®¶: æˆ‘è§‰å¾—è¿˜ç¼ºå°‘ä¸€ä¸ªç« èŠ‚:å¦‚ä½•å¸®åŠ©ä»–äººå…‹æœæ‹–å»¶ç—‡...

ğŸ“Š ä½œå®¶æŠ•ç¥¨: åŒæ„ç»“æŸ
ğŸ“Š å¿ƒç†å­¦å®¶æŠ•ç¥¨: ä¸åŒæ„ç»“æŸ
âš ï¸  å­˜åœ¨åˆ†æ­§,ç»§ç»­åä½œ...

============================================================
ğŸ”„ å¯åŠ¨å†²çªè§£å†³æµç¨‹
============================================================
[ç³»ç»Ÿæç¤º]
æ£€æµ‹åˆ°åä½œåŒæ–¹å¯¹ä»»åŠ¡å®Œæˆåº¦å­˜åœ¨åˆ†æ­§...

[ç¬¬25è½®]
ä½œå®¶: å¿ƒç†å­¦å®¶æå‡ºçš„è§‚ç‚¹å¾ˆæœ‰é“ç†,å¸®åŠ©ä»–äººçš„å†…å®¹ç¡®å®é‡è¦ã€‚è®©æˆ‘ä»¬è¡¥å……è¿™ä¸€ç« èŠ‚...
å¿ƒç†å­¦å®¶: æ„Ÿè°¢ä½œå®¶çš„ç†è§£,æˆ‘æ¥æä¾›ç›¸å…³çš„å¿ƒç†å­¦ç†è®ºå’ŒæŠ€å·§...<CAMEL_TASK_DONE>

ğŸ“Š ä½œå®¶æŠ•ç¥¨: ä¸åŒæ„ç»“æŸ(æ­£åœ¨è¡¥å……å†…å®¹)
ğŸ“Š å¿ƒç†å­¦å®¶æŠ•ç¥¨: åŒæ„ç»“æŸ

[ç¬¬26è½®]
ä½œå®¶: æ–°ç« èŠ‚å·²å®Œæˆ,ç°åœ¨å†…å®¹ç¡®å®å®Œæ•´äº†ã€‚<CAMEL_TASK_DONE>
å¿ƒç†å­¦å®¶: åŒæ„,ç”µå­ä¹¦å·²è¾¾åˆ°å‡ºç‰ˆæ ‡å‡†ã€‚<CAMEL_TASK_DONE>

ğŸ“Š ä½œå®¶æŠ•ç¥¨: åŒæ„ç»“æŸ
ğŸ“Š å¿ƒç†å­¦å®¶æŠ•ç¥¨: åŒæ„ç»“æŸ
âœ… åŒæ–¹è¾¾æˆå…±è¯†,ä»»åŠ¡ç»“æŸ
```

---

#### ğŸ’¡ è§£å†³æ–¹æ¡ˆäºŒ: è´¨é‡è¯„ä¼°ä»²è£æœºåˆ¶

**æ ¸å¿ƒæ€æƒ³**: å¼•å…¥ç¬¬ä¸‰æ–¹"è¯„å®¡æ™ºèƒ½ä½“"ä½œä¸ºä»²è£è€…

```python
from camel.agents import ChatAgent
from camel.messages import BaseMessage

class ArbitratedRolePlaying:
    """
    å¸¦ä»²è£æœºåˆ¶çš„è§’è‰²æ‰®æ¼”

    å½“åŒæ–¹åˆ†æ­§æ—¶,ç”±è¯„å®¡æ™ºèƒ½ä½“åšæœ€ç»ˆè£å†³
    """

    def __init__(
        self,
        user_agent: ChatAgent,
        assistant_agent: ChatAgent,
        task_prompt: str,
        quality_threshold: float = 0.8
    ):
        self.user_agent = user_agent
        self.assistant_agent = assistant_agent
        self.task_prompt = task_prompt
        self.quality_threshold = quality_threshold

        # åˆ›å»ºè¯„å®¡æ™ºèƒ½ä½“
        self.reviewer_agent = self._create_reviewer()

    def _create_reviewer(self) -> ChatAgent:
        """åˆ›å»ºè¯„å®¡æ™ºèƒ½ä½“"""
        reviewer_sys_msg = f"""ä½ æ˜¯ä¸€ä½èµ„æ·±çš„å†…å®¹è¯„å®¡ä¸“å®¶ã€‚

ä½ çš„èŒè´£æ˜¯è¯„ä¼°åä½œäº§å‡ºçš„è´¨é‡,å¹¶åœ¨åŒæ–¹æ„è§åˆ†æ­§æ—¶åšå‡ºå…¬æ­£è£å†³ã€‚

åŸå§‹ä»»åŠ¡: {self.task_prompt}

è¯„å®¡æ ‡å‡†:
1. å†…å®¹å®Œæ•´æ€§: æ˜¯å¦æ¶µç›–äº†ä»»åŠ¡è¦æ±‚çš„æ‰€æœ‰è¦ç‚¹ (40åˆ†)
2. è´¨é‡æ°´å¹³: å†…å®¹çš„æ·±åº¦ã€å‡†ç¡®æ€§å’Œå®ç”¨æ€§ (30åˆ†)
3. ç»“æ„æ¸…æ™°: é€»è¾‘æ€§å’Œå¯è¯»æ€§ (20åˆ†)
4. åˆ›æ–°ä»·å€¼: æ˜¯å¦æœ‰ç‹¬ç‰¹è§è§£ (10åˆ†)

è¯„åˆ†è§„åˆ™:
- æ€»åˆ†100åˆ†
- è¾¾åˆ°{self.quality_threshold * 100}åˆ†ä»¥ä¸Šå¯ä»¥ç»“æŸ
- ä½äºæ­¤åˆ†æ•°éœ€è¦ç»§ç»­å®Œå–„

è¾“å‡ºæ ¼å¼:
```json
{{
    "completeness_score": åˆ†æ•°,
    "quality_score": åˆ†æ•°,
    "structure_score": åˆ†æ•°,
    "innovation_score": åˆ†æ•°,
    "total_score": æ€»åˆ†,
    "can_terminate": true/false,
    "suggestions": "æ”¹è¿›å»ºè®®"
}}
```
"""
        return ChatAgent(
            system_message=reviewer_sys_msg,
            model_type="gpt-4"  # ä½¿ç”¨æ›´å¼ºçš„æ¨¡å‹ä½œä¸ºè¯„å®¡
        )

    async def resolve_conflict(
        self,
        current_output: str,
        user_opinion: str,
        assistant_opinion: str
    ) -> dict:
        """
        è§£å†³å†²çª

        Returns:
            {
                "decision": "continue" or "terminate",
                "reason": "è£å†³ç†ç”±",
                "scores": {...}
            }
        """
        review_request = f"""
è¯·è¯„å®¡ä»¥ä¸‹åä½œæˆæœ:

---åä½œäº§å‡º---
{current_output}

---åŒæ–¹æ„è§---
AI User (ä½œå®¶): {user_opinion}
AI Assistant (å¿ƒç†å­¦å®¶): {assistant_opinion}

è¯·æä¾›å®¢è§‚è¯„åˆ†å’Œè£å†³å»ºè®®ã€‚
"""

        # è°ƒç”¨è¯„å®¡æ™ºèƒ½ä½“
        response = await self.reviewer_agent.step(review_request)
        review_result = self._parse_review(response.msg.content)

        # åšå‡ºè£å†³
        if review_result["total_score"] >= self.quality_threshold * 100:
            decision = "terminate"
            reason = f"è´¨é‡è¯„åˆ†{review_result['total_score']}åˆ†,è¾¾åˆ°ç»ˆæ­¢æ ‡å‡†"
        else:
            decision = "continue"
            reason = f"è´¨é‡è¯„åˆ†{review_result['total_score']}åˆ†,å»ºè®®ç»§ç»­å®Œå–„:\n{review_result['suggestions']}"

        print("\n" + "="*60)
        print("âš–ï¸  è¯„å®¡æ™ºèƒ½ä½“è£å†³")
        print("="*60)
        print(f"å†³å®š: {decision.upper()}")
        print(f"ç†ç”±: {reason}")
        print(f"è¯¦ç»†è¯„åˆ†: {review_result}")
        print("="*60 + "\n")

        return {
            "decision": decision,
            "reason": reason,
            "scores": review_result
        }

    def _parse_review(self, review_text: str) -> dict:
        """è§£æè¯„å®¡ç»“æœ"""
        import json
        import re

        # æå–JSONéƒ¨åˆ†
        json_match = re.search(r'```json\n(.*?)\n```', review_text, re.DOTALL)
        if json_match:
            return json.loads(json_match.group(1))
        else:
            # é™çº§: è¿”å›é»˜è®¤è¯„åˆ†
            return {
                "total_score": 75,
                "can_terminate": False,
                "suggestions": "è¯„å®¡è§£æå¤±è´¥,å»ºè®®ç»§ç»­"
            }

# ä½¿ç”¨ç¤ºä¾‹
async def writing_with_arbitration():
    """å¸¦ä»²è£çš„åä½œå†™ä½œ"""

    # åˆå§‹åŒ–æ™ºèƒ½ä½“
    user_agent = ChatAgent(system_message="ä½ æ˜¯ä½œå®¶...")
    assistant_agent = ChatAgent(system_message="ä½ æ˜¯å¿ƒç†å­¦å®¶...")

    # åˆ›å»ºä»²è£ä¼šè¯
    session = ArbitratedRolePlaying(
        user_agent=user_agent,
        assistant_agent=assistant_agent,
        task_prompt="åˆ›ä½œæ‹–å»¶ç—‡ç”µå­ä¹¦",
        quality_threshold=0.8
    )

    # ... åä½œè¿‡ç¨‹ ...

    # å½“æ£€æµ‹åˆ°åˆ†æ­§æ—¶
    if has_disagreement:
        current_book_content = "..."  # å½“å‰ä¹¦ç¨¿å†…å®¹
        user_opinion = "æˆ‘è§‰å¾—å·²ç»å®Œæˆäº†..."
        assistant_opinion = "è¿˜éœ€è¦è¡¥å……..."

        # è¯·æ±‚ä»²è£
        arbitration = await session.resolve_conflict(
            current_output=current_book_content,
            user_opinion=user_opinion,
            assistant_opinion=assistant_opinion
        )

        if arbitration["decision"] == "terminate":
            print("âœ… è¯„å®¡æ™ºèƒ½ä½“è£å®š: ä»»åŠ¡å®Œæˆ")
        else:
            print(f"ğŸ”„ è¯„å®¡æ™ºèƒ½ä½“è£å®š: ç»§ç»­å®Œå–„\nå»ºè®®: {arbitration['reason']}")
```

**è¿è¡Œæ•ˆæœ**:

```
æ£€æµ‹åˆ°åˆ†æ­§:
- ä½œå®¶: è®¤ä¸ºå·²å®Œæˆ
- å¿ƒç†å­¦å®¶: è®¤ä¸ºéœ€è¦è¡¥å……

============================================================
âš–ï¸  è¯„å®¡æ™ºèƒ½ä½“è£å†³
============================================================
å†³å®š: CONTINUE
ç†ç”±: è´¨é‡è¯„åˆ†76åˆ†,å»ºè®®ç»§ç»­å®Œå–„:
     ç¼ºå°‘"å¦‚ä½•å¸®åŠ©ä»–äººå…‹æœæ‹–å»¶ç—‡"ç« èŠ‚,è¿™å¯¹å®ç”¨æ€§å¾ˆé‡è¦ã€‚
     å»ºè®®è¡¥å……æ¡ˆä¾‹åˆ†æå’Œå…·ä½“æ²Ÿé€šæŠ€å·§ã€‚
è¯¦ç»†è¯„åˆ†: {
  "completeness_score": 35,  # å®Œæ•´æ€§ç•¥ä½
  "quality_score": 25,
  "structure_score": 16,
  "total_score": 76
}
============================================================

ğŸ”„ æ ¹æ®è¯„å®¡æ„è§,åä½œç»§ç»­...
```

---

#### ğŸ’¡ è§£å†³æ–¹æ¡ˆä¸‰: è½®æ¬¡é™åˆ¶ä¸å¼ºåˆ¶è°ƒåœ

**æ ¸å¿ƒæ€æƒ³**: å¦‚æœåˆ†æ­§æŒç»­å¤šè½®,å¼ºåˆ¶è¿›å…¥æœ€ç»ˆè£å†³

```python
class TurnLimitedRolePlaying(RolePlaying):
    """
    é™åˆ¶åˆ†æ­§è½®æ¬¡çš„è§’è‰²æ‰®æ¼”

    å¦‚æœåˆ†æ­§è¶…è¿‡Nè½®,å¼ºåˆ¶è§¦å‘æœ€ç»ˆè£å†³
    """

    def __init__(self, *args, max_disagreement_turns=3, **kwargs):
        super().__init__(*args, **kwargs)
        self.max_disagreement_turns = max_disagreement_turns
        self.disagreement_count = 0
        self.last_disagreement_state = None

    def check_and_resolve(self, user_msg, assistant_msg):
        """æ£€æŸ¥åˆ†æ­§å¹¶è§£å†³"""

        user_wants_end = "<CAMEL_TASK_DONE>" in user_msg.content
        assistant_wants_end = "<CAMEL_TASK_DONE>" in assistant_msg.content

        # æƒ…å†µ1: åŒæ–¹ä¸€è‡´åŒæ„ç»“æŸ
        if user_wants_end and assistant_wants_end:
            print("âœ… åŒæ–¹ä¸€è‡´åŒæ„,ä»»åŠ¡ç»“æŸ")
            return True

        # æƒ…å†µ2: åŒæ–¹ä¸€è‡´åŒæ„ç»§ç»­
        if not user_wants_end and not assistant_wants_end:
            self.disagreement_count = 0  # é‡ç½®è®¡æ•°å™¨
            return False

        # æƒ…å†µ3: å­˜åœ¨åˆ†æ­§
        self.disagreement_count += 1
        print(f"âš ï¸  æ£€æµ‹åˆ°åˆ†æ­§ (ç¬¬{self.disagreement_count}/{self.max_disagreement_turns}æ¬¡)")

        # å¦‚æœåˆ†æ­§æ¬¡æ•°è¶…è¿‡é˜ˆå€¼,å¼ºåˆ¶è£å†³
        if self.disagreement_count >= self.max_disagreement_turns:
            return self._force_mediation(user_msg, assistant_msg)

        # å¦åˆ™ç»§ç»­åä½œ
        return False

    def _force_mediation(self, user_msg, assistant_msg):
        """å¼ºåˆ¶è°ƒåœ"""
        print("\n" + "="*60)
        print("ğŸš¨ åˆ†æ­§æŒç»­è¿‡ä¹…,å¯åŠ¨å¼ºåˆ¶è°ƒåœ")
        print("="*60)

        # ç­–ç•¥1: é‡‡çº³æ›´ä¿å®ˆçš„æ„è§(ç»§ç»­å®Œå–„)
        # ç†ç”±: å®å¯å¤šåš,ä¸è¦æ¼åš
        print("ğŸ“‹ è°ƒåœç­–ç•¥: é‡‡çº³'ç»§ç»­å®Œå–„'çš„å»ºè®®")
        print("   ç†ç”±: åœ¨è´¨é‡å’Œé€Ÿåº¦ä¹‹é—´,ä¼˜å…ˆä¿è¯è´¨é‡")

        # ç»™åŒæ–¹å‘é€è°ƒåœé€šçŸ¥
        mediation_msg = """
[ç³»ç»Ÿè°ƒåœ]
åŒæ–¹æ„è§åˆ†æ­§å·²æŒç»­{self.disagreement_count}è½®ã€‚

æ ¹æ®"è´¨é‡ä¼˜å…ˆ"åŸåˆ™,ç³»ç»Ÿè£å®š: ç»§ç»­å®Œå–„å†…å®¹ã€‚

è¯·æå‡ºåˆ†æ­§æ–¹æä¾›å…·ä½“çš„è¡¥å……æ¸…å•(ä¸è¶…è¿‡3é¡¹),
ä¸»å¼ ç»“æŸæ–¹è¯„ä¼°å,å…±åŒå®Œæˆè¿™äº›è¡¥å……é¡¹,ç„¶åç»“æŸä»»åŠ¡ã€‚

è¿™æ˜¯æœ€åä¸€è½®è¡¥å……æœºä¼š,è¯·åŒæ–¹çæƒœå¹¶é«˜æ•ˆåä½œã€‚
"""
        print(mediation_msg)

        # é‡ç½®è®¡æ•°å™¨,ç»™æœ€åä¸€æ¬¡æœºä¼š
        self.disagreement_count = 0
        return False  # ä¸ç»ˆæ­¢,ç»™æœ€åæœºä¼š

# ä½¿ç”¨ç¤ºä¾‹
session = TurnLimitedRolePlaying(
    assistant_role_name="å¿ƒç†å­¦å®¶",
    user_role_name="ä½œå®¶",
    task_prompt="...",
    max_disagreement_turns=3  # æœ€å¤šå®¹å¿3è½®åˆ†æ­§
)
```

---

#### ğŸ“Š ä¸‰ç§æ–¹æ¡ˆå¯¹æ¯”

| æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|---------|
| **å…±è¯†ç¡®è®¤** | ç®€å•,ä¿è¯åŒæ–¹éƒ½æ»¡æ„ | å¯èƒ½é™·å…¥åƒµæŒ | è´¨é‡è¦æ±‚é«˜,æ—¶é—´å……è£• |
| **è´¨é‡ä»²è£** | å®¢è§‚å…¬æ­£,æœ‰é‡åŒ–æ ‡å‡† | éœ€è¦é¢å¤–LLMè°ƒç”¨,æˆæœ¬é«˜ | é«˜ä»·å€¼é¡¹ç›®,éœ€è¦è´¨é‡ä¿è¯ |
| **è½®æ¬¡é™åˆ¶** | é˜²æ­¢æ— é™åƒµæŒ,å…¼é¡¾æ•ˆç‡ | å¯èƒ½å¼ºåˆ¶ç»“æŸè¿‡æ—© | æ—¶é—´æ•æ„Ÿä»»åŠ¡ |

**æ¨èç»„åˆç­–ç•¥**:

```python
class HybridConflictResolution(RolePlaying):
    """æ··åˆå†²çªè§£å†³æœºåˆ¶"""

    def resolve_conflict(self, context):
        # ç¬¬1-2è½®åˆ†æ­§: é¼“åŠ±æ²Ÿé€š
        if self.disagreement_count <= 2:
            return self._encourage_discussion()

        # ç¬¬3-4è½®åˆ†æ­§: è¯·æ±‚ä»²è£
        elif self.disagreement_count <= 4:
            return self._request_arbitration(context)

        # ç¬¬5è½®+: å¼ºåˆ¶è°ƒåœ
        else:
            return self._force_mediation()
```

---

### è§£ç­”4.2: CAMEL Workforce å¤šæ™ºèƒ½ä½“åä½œ

#### ğŸ¢ Workforce æ¶æ„æ¦‚è§ˆ

æ ¹æ®CAMELæœ€æ–°æ–‡æ¡£,`workforce`æ¨¡å—æä¾›äº†ç»“æ„åŒ–çš„å¤šæ™ºèƒ½ä½“åä½œæ¡†æ¶:

```
CAMEL Workforce æ¶æ„:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            Workforce Manager                â”‚
â”‚  (ä»»åŠ¡è°ƒåº¦ã€èµ„æºåˆ†é…ã€è¿›åº¦ç›‘æ§)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
     â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚           â”‚         â”‚         â”‚
â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”  â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â” â”Œâ”€â”€â–¼â”€â”€â”€â”€â”€â” â”Œâ–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Task 1  â”‚  â”‚Task 2  â”‚ â”‚Task 3  â”‚ â”‚Task N   â”‚
â”‚        â”‚  â”‚        â”‚ â”‚        â”‚ â”‚         â”‚
â”‚Worker Aâ”‚  â”‚Worker Bâ”‚ â”‚Worker Câ”‚ â”‚Worker D â”‚
â”‚Worker Bâ”‚  â”‚Worker Câ”‚ â”‚Worker Dâ”‚ â”‚Worker A â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 å¹¶è¡Œæ‰§è¡Œ     å¹¶è¡Œæ‰§è¡Œ    å¹¶è¡Œæ‰§è¡Œ     å¹¶è¡Œæ‰§è¡Œ
```

**æ ¸å¿ƒç‰¹ç‚¹**:

1. **ä»»åŠ¡åˆ†è§£**: å°†å¤æ‚ä»»åŠ¡åˆ†è§£ä¸ºå¤šä¸ªå­ä»»åŠ¡
2. **Workeræ± **: ç»´æŠ¤ä¸€ä¸ªå¯å¤ç”¨çš„Workeræ™ºèƒ½ä½“æ± 
3. **åŠ¨æ€åˆ†é…**: æ ¹æ®ä»»åŠ¡éœ€æ±‚åŠ¨æ€åˆ†é…Worker
4. **å¹¶è¡Œæ‰§è¡Œ**: æ”¯æŒå¤šä»»åŠ¡å¹¶è¡Œå¤„ç†

---

#### ğŸ†š ä¸AutoGenç¾¤èŠæ¨¡å¼çš„å¯¹æ¯”

**AutoGen RoundRobinGroupChat**:

```python
# AutoGen: ç¾¤èŠæ¨¡å¼(ä¼šè®®å®¤éšå–»)
from autogen import GroupChat, GroupChatManager

# æ‰€æœ‰æ™ºèƒ½ä½“å›´ååœ¨ä¸€èµ·"å¼€ä¼š"
group_chat = GroupChat(
    agents=[pm, engineer, reviewer],
    messages=[],
    speaker_selection_method="round_robin"  # è½®æµå‘è¨€
)

# ç‰¹ç‚¹:
# âœ… æ‰€æœ‰æ™ºèƒ½ä½“å…±äº«åŒä¸€ä¸ªå¯¹è¯ä¸Šä¸‹æ–‡
# âœ… å¯ä»¥ç›¸äº’å‚è€ƒå½¼æ­¤çš„å‘è¨€
# âŒ å¿…é¡»ç­‰å¾…å‰é¢çš„äººå‘è¨€å®Œæ¯•
# âŒ æ— æ³•å¹¶è¡Œå¤„ç†å­ä»»åŠ¡
```

**CAMEL Workforce**:

```python
# CAMEL: å·¥ä½œå›¢é˜Ÿæ¨¡å¼(é¡¹ç›®ç®¡ç†éšå–»)
from camel.workforce import Workforce, Task

# å®šä¹‰ä»»åŠ¡æ± 
tasks = [
    Task(id="T1", description="éœ€æ±‚åˆ†æ", assignees=["pm"]),
    Task(id="T2", description="æŠ€æœ¯è®¾è®¡", assignees=["architect"]),
    Task(id="T3", description="ç¼–ç å®ç°", assignees=["engineer1", "engineer2"]),
]

# åˆ›å»ºWorkforce
workforce = Workforce(
    workers={
        "pm": ProductManagerAgent(),
        "architect": ArchitectAgent(),
        "engineer1": EngineerAgent(),
        "engineer2": EngineerAgent()
    },
    tasks=tasks
)

# ç‰¹ç‚¹:
# âœ… ä»»åŠ¡å¯ä»¥å¹¶è¡Œæ‰§è¡Œ(T1, T2å¯åŒæ—¶è¿›è¡Œ)
# âœ… Workerå¯ä»¥ä¸“æ³¨äºè‡ªå·±çš„ä»»åŠ¡
# âœ… æ”¯æŒä»»åŠ¡ä¾èµ–å…³ç³» (T3ä¾èµ–T1, T2å®Œæˆ)
# âŒ Workerä¹‹é—´çš„ç›´æ¥äº¤æµå—é™
```

---

#### ğŸ“Š è¯¦ç»†å¯¹æ¯”è¡¨

| ç»´åº¦ | AutoGen GroupChat | CAMEL Workforce |
|------|------------------|-----------------|
| **åä½œéšå–»** | ä¼šè®®å®¤/è®¨è®ºä¼š | é¡¹ç›®å›¢é˜Ÿ/çœ‹æ¿ |
| **é€šä¿¡æ–¹å¼** | å…±äº«å¯¹è¯å†å² | ä»»åŠ¡è¾“å…¥è¾“å‡º |
| **æ‰§è¡Œæ¨¡å¼** | é¡ºåºå‘è¨€(æˆ–AIé€‰æ‹©) | å¹¶è¡Œä»»åŠ¡æ‰§è¡Œ |
| **ä¸Šä¸‹æ–‡å…±äº«** | å…¨å±€å…±äº« | ä»»åŠ¡çº§éš”ç¦» |
| **é€‚åˆåœºæ™¯** | å¤´è„‘é£æš´ã€å†³ç­–è®¨è®º | ç»“æ„åŒ–é¡¹ç›®ã€æµæ°´çº¿ |
| **æ‰©å±•æ€§** | å—é™(å¯¹è¯è¶Šé•¿è¶Šæ…¢) | å¥½(ä»»åŠ¡å¯å¹¶è¡Œ) |
| **å¯é¢„æµ‹æ€§** | ä½(å¯¹è¯é©±åŠ¨) | é«˜(ä»»åŠ¡é©±åŠ¨) |

---

#### ğŸ¯ æ··åˆä½¿ç”¨åœºæ™¯

æœ€ä½³å®è·µæ˜¯åœ¨åŒä¸€ä¸ªé¡¹ç›®ä¸­ç»„åˆä½¿ç”¨:

```python
# é˜¶æ®µ1: ä½¿ç”¨AutoGenè¿›è¡Œéœ€æ±‚è®¨è®º
group_chat = GroupChat(agents=[pm, engineer, designer])
requirements = group_chat.run("è®¨è®ºäº§å“éœ€æ±‚")

# é˜¶æ®µ2: ä½¿ç”¨CAMEL Workforceå¹¶è¡Œæ‰§è¡Œä»»åŠ¡
tasks = [
    Task("å‰ç«¯å¼€å‘", workers=[frontend_engineer]),
    Task("åç«¯å¼€å‘", workers=[backend_engineer]),
    Task("UIè®¾è®¡", workers=[designer])
]
workforce = Workforce(tasks=tasks)
results = workforce.execute_parallel()

# é˜¶æ®µ3: ä½¿ç”¨AutoGenè¿›è¡Œé›†æˆè¯„å®¡
review_chat = GroupChat(agents=[pm, qa, all_engineers])
final_review = review_chat.run("è¯„å®¡é›†æˆç»“æœ")
```

---

è¿™å°±æ˜¯ç¬¬4é¢˜çš„å®Œæ•´è§£ç­”!åŒ…å«:
1. ä¸‰ç§å†²çªè§£å†³æœºåˆ¶çš„è®¾è®¡ä¸å®ç°
2. CAMEL Workforceæ¶æ„åˆ†æ
3. ä¸AutoGenç¾¤èŠæ¨¡å¼çš„æ·±åº¦å¯¹æ¯”

---

## ä¹ é¢˜5: LangGraph åæ€å¾ªç¯è®¾è®¡

### é¢˜ç›®

åœ¨6.5èŠ‚çš„ `LangGraph` æ¡ˆä¾‹ä¸­ï¼Œæˆ‘ä»¬æ„å»ºäº†ä¸€ä¸ª"ä¸‰æ­¥é—®ç­”åŠ©æ‰‹"ã€‚è¯·åˆ†æï¼š

- `LangGraph` å°†æ™ºèƒ½ä½“æµç¨‹å»ºæ¨¡ä¸ºçŠ¶æ€æœºå’Œæœ‰å‘å›¾ã€‚è¯·ç”»å‡ºæ¡ˆä¾‹ä¸­"ç†è§£-æœç´¢-å›ç­”"æµç¨‹çš„å›¾ç»“æ„ï¼Œæ ‡æ³¨èŠ‚ç‚¹ã€è¾¹å’ŒçŠ¶æ€è½¬æ¢æ¡ä»¶ã€‚
- å½“å‰çš„åŠ©æ‰‹æ˜¯ä¸€ä¸ªçº¿æ€§æµç¨‹ã€‚è¯·æ‰©å±•è¿™ä¸ªæ¡ˆä¾‹ï¼Œæ·»åŠ ä¸€ä¸ª"åæ€"èŠ‚ç‚¹ï¼šå¦‚æœç”Ÿæˆçš„ç­”æ¡ˆè´¨é‡ä½ï¼ˆä¾‹å¦‚è¿‡äºç®€çŸ­æˆ–ç¼ºä¹ç»†èŠ‚ï¼‰ï¼Œç³»ç»Ÿåº”è¯¥é‡æ–°æœç´¢æˆ–é‡æ–°ç”Ÿæˆç­”æ¡ˆã€‚è¯·è®¾è®¡è¿™ä¸ªå¾ªç¯æœºåˆ¶çš„æ¡ä»¶è¾¹é€»è¾‘ã€‚
- `LangGraph` çš„ä¼˜åŠ¿åœ¨äºå¯¹å¾ªç¯çš„åŸç”Ÿæ”¯æŒã€‚è¯·è®¾è®¡ä¸€ä¸ªæ›´å¤æ‚çš„åº”ç”¨åœºæ™¯ï¼Œå……åˆ†åˆ©ç”¨è¿™ä¸€ç‰¹æ€§ï¼šä¾‹å¦‚"ä»£ç ç”Ÿæˆ-æµ‹è¯•-ä¿®å¤"å¾ªç¯ã€"è®ºæ–‡å†™ä½œ-å®¡é˜…-ä¿®æ”¹"å¾ªç¯ç­‰ã€‚è¦æ±‚ç”»å‡ºå®Œæ•´çš„å›¾ç»“æ„å¹¶è¯´æ˜å…³é”®èŠ‚ç‚¹çš„åŠŸèƒ½ã€‚

---

### è§£ç­”5.1: ä¸‰æ­¥é—®ç­”åŠ©æ‰‹çš„å›¾ç»“æ„åˆ†æ

#### ğŸ“Š åŸå§‹æµç¨‹å›¾

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  START  â”‚
                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
                         â”‚
                         â†“
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  ç†è§£æŸ¥è¯¢èŠ‚ç‚¹     â”‚
              â”‚ (understand)     â”‚
              â”‚                  â”‚
              â”‚ åŠŸèƒ½:            â”‚
              â”‚ - åˆ†æç”¨æˆ·æ„å›¾   â”‚
              â”‚ - ç”Ÿæˆæœç´¢å…³é”®è¯ â”‚
              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚ å¸¸è§„è¾¹(æ— æ¡ä»¶)
                   â”‚ state["search_query"] = "ä¼˜åŒ–åçš„å…³é”®è¯"
                   â†“
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   æœç´¢èŠ‚ç‚¹        â”‚
              â”‚  (search)        â”‚
              â”‚                  â”‚
              â”‚ åŠŸèƒ½:            â”‚
              â”‚ - è°ƒç”¨Tavily API â”‚
              â”‚ - è·å–æœç´¢ç»“æœ   â”‚
              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚ å¸¸è§„è¾¹(æ— æ¡ä»¶)
                   â”‚ state["search_results"] = "æœç´¢åˆ°çš„å†…å®¹"
                   â”‚ state["step"] = "searched"
                   â†“
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   å›ç­”èŠ‚ç‚¹        â”‚
              â”‚  (answer)        â”‚
              â”‚                  â”‚
              â”‚ åŠŸèƒ½:            â”‚
              â”‚ - åŸºäºæœç´¢ç»“æœ   â”‚
              â”‚ - ç”Ÿæˆæœ€ç»ˆç­”æ¡ˆ   â”‚
              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚ å¸¸è§„è¾¹(æ— æ¡ä»¶)
                   â”‚ state["final_answer"] = "LLMç”Ÿæˆçš„ç­”æ¡ˆ"
                   â”‚ state["step"] = "completed"
                   â†“
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚      END         â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

çŠ¶æ€æ•°æ®æµ:
SearchState {
    messages: [ç”¨æˆ·é—®é¢˜, AIå›å¤],
    user_query: "ç†è§£åçš„éœ€æ±‚",
    search_query: "ä¼˜åŒ–çš„æœç´¢è¯",
    search_results: "æœç´¢ç»“æœ",
    final_answer: "æœ€ç»ˆç­”æ¡ˆ",
    step: "understood" â†’ "searched" â†’ "completed"
}
```

**å…³é”®ç‚¹åˆ†æ**:

1. **èŠ‚ç‚¹èŒè´£å•ä¸€**: æ¯ä¸ªèŠ‚ç‚¹åªè´Ÿè´£ä¸€ä¸ªæ˜ç¡®çš„ä»»åŠ¡
2. **çŠ¶æ€ç´¯ç§¯**: çŠ¶æ€åœ¨èŠ‚ç‚¹é—´ä¼ é€’å¹¶ä¸æ–­ä¸°å¯Œ
3. **çº¿æ€§æµåŠ¨**: ä¿¡æ¯å•å‘æµåŠ¨ï¼Œæ— å›è·¯

---

### è§£ç­”5.2: æ·»åŠ åæ€å¾ªç¯çš„æ‰©å±•è®¾è®¡

#### ğŸ”„ å¸¦åæ€æœºåˆ¶çš„å®Œæ•´æµç¨‹å›¾

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  START  â”‚
                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
                         â”‚
                         â†“
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  ç†è§£æŸ¥è¯¢èŠ‚ç‚¹     â”‚
              â”‚ (understand)     â”‚
              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â†“
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   æœç´¢èŠ‚ç‚¹        â”‚
              â”‚  (search)        â”‚
              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â†“
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   å›ç­”èŠ‚ç‚¹        â”‚
              â”‚  (answer)        â”‚
              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â†“
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  è´¨é‡è¯„ä¼°èŠ‚ç‚¹     â”‚ â† æ–°å¢!
              â”‚ (evaluate)       â”‚
              â”‚                  â”‚
              â”‚ åŠŸèƒ½:            â”‚
              â”‚ - è¯„ä¼°ç­”æ¡ˆè´¨é‡   â”‚
              â”‚ - æ£€æŸ¥é•¿åº¦       â”‚
              â”‚ - æ£€æŸ¥ç»†èŠ‚ä¸°å¯Œåº¦ â”‚
              â”‚ - æ£€æŸ¥ç›¸å…³æ€§     â”‚
              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â”‚ æ¡ä»¶è¾¹(å…³é”®!)
                   â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                   â”‚
    è´¨é‡åˆæ ¼?           è´¨é‡ä¸è¶³?
    (score â‰¥ 0.7)       (score < 0.7)
         â”‚                   â”‚
         â”‚                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                             â”‚
         â†“                             â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   END   â”‚              â”‚   åæ€èŠ‚ç‚¹        â”‚ â† æ–°å¢!
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚ (reflect)        â”‚
                             â”‚                  â”‚
                             â”‚ åŠŸèƒ½:            â”‚
                             â”‚ - åˆ†æè´¨é‡é—®é¢˜   â”‚
                             â”‚ - å†³å®šæ”¹è¿›ç­–ç•¥   â”‚
                             â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                                  â”‚ æ¡ä»¶è¾¹(ç­–ç•¥è·¯ç”±)
                                  â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                            â”‚
              æœç´¢ç»“æœä¸è¶³?                  ç­”æ¡ˆç»„ç»‡é—®é¢˜?
              (ç¼ºå°‘å…³é”®ä¿¡æ¯)                (ä¿¡æ¯å……è¶³ä½†è¡¨è¿°å·®)
                    â”‚                            â”‚
                    â†“                            â†“
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚ é‡æ–°æœç´¢        â”‚          â”‚ é‡æ–°ç”Ÿæˆç­”æ¡ˆ     â”‚
           â”‚ (æ”¹è¿›æœç´¢è¯)    â”‚          â”‚ (æ”¹è¿›æç¤ºè¯)    â”‚
           â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚                            â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â†“
                      (å›åˆ°å¯¹åº”èŠ‚ç‚¹)

çŠ¶æ€æ‰©å±•:
SearchState {
    ...åŸæœ‰å­—æ®µ,
    quality_score: float,        # è´¨é‡è¯„åˆ†
    attempt_count: int,          # å°è¯•æ¬¡æ•°
    quality_issues: List[str],   # è´¨é‡é—®é¢˜åˆ—è¡¨
    improvement_strategy: str    # æ”¹è¿›ç­–ç•¥
}
```

---

#### ğŸ’» å®Œæ•´ä»£ç å®ç°

```python
from typing import TypedDict, Annotated, Literal
from langgraph.graph import StateGraph, END
from langgraph.graph.message import add_messages

# 1. æ‰©å±•çŠ¶æ€å®šä¹‰
class EnhancedSearchState(TypedDict):
    messages: Annotated[list, add_messages]
    user_query: str
    search_query: str
    search_results: str
    final_answer: str
    step: str

    # æ–°å¢:è´¨é‡æ§åˆ¶å­—æ®µ
    quality_score: float
    attempt_count: int
    max_attempts: int
    quality_issues: list[str]
    improvement_strategy: str

# 2. è´¨é‡è¯„ä¼°èŠ‚ç‚¹
def evaluate_quality_node(state: EnhancedSearchState) -> dict:
    """
    è¯„ä¼°ç­”æ¡ˆè´¨é‡

    è¯„åˆ†æ ‡å‡†:
    - é•¿åº¦é€‚ä¸­ (30%)
    - ä¿¡æ¯ä¸°å¯Œåº¦ (40%)
    - ç›¸å…³æ€§ (30%)
    """
    answer = state["final_answer"]
    query = state["user_query"]

    # è¯„åˆ†é€»è¾‘
    scores = {
        "length": 0.0,
        "richness": 0.0,
        "relevance": 0.0
    }
    issues = []

    # è¯„ä¼°1: é•¿åº¦ (ç†æƒ³:200-800å­—ç¬¦)
    length = len(answer)
    if length < 100:
        scores["length"] = 0.3
        issues.append("ç­”æ¡ˆè¿‡äºç®€çŸ­")
    elif length > 1000:
        scores["length"] = 0.7
        issues.append("ç­”æ¡ˆè¿‡äºå†—é•¿")
    else:
        scores["length"] = 1.0

    # è¯„ä¼°2: ä¿¡æ¯ä¸°å¯Œåº¦ (æ˜¯å¦åŒ…å«åˆ—è¡¨ã€æ•°å­—ã€ä¾‹å­ç­‰)
    has_list = any(marker in answer for marker in ["1.", "2.", "-", "â€¢"])
    has_numbers = any(char.isdigit() for char in answer)
    has_examples = any(word in answer for word in ["ä¾‹å¦‚", "æ¯”å¦‚", "ä¾‹å­"])

    richness_count = sum([has_list, has_numbers, has_examples])
    scores["richness"] = richness_count / 3.0

    if scores["richness"] < 0.5:
        issues.append("ç¼ºå°‘å…·ä½“ç»†èŠ‚å’Œä¾‹å­")

    # è¯„ä¼°3: ç›¸å…³æ€§ (ç®€åŒ–:æ£€æŸ¥æ˜¯å¦åŒ…å«æŸ¥è¯¢å…³é”®è¯)
    query_words = set(query.lower().split())
    answer_words = set(answer.lower().split())
    overlap = len(query_words & answer_words)
    scores["relevance"] = min(overlap / max(len(query_words), 1), 1.0)

    if scores["relevance"] < 0.3:
        issues.append("ç­”æ¡ˆä¸é—®é¢˜ç›¸å…³æ€§ä½")

    # è®¡ç®—æ€»åˆ†
    total_score = (
        scores["length"] * 0.3 +
        scores["richness"] * 0.4 +
        scores["relevance"] * 0.3
    )

    print(f"\nğŸ“Š è´¨é‡è¯„ä¼°:")
    print(f"   é•¿åº¦è¯„åˆ†: {scores['length']:.2f}")
    print(f"   ä¸°å¯Œåº¦è¯„åˆ†: {scores['richness']:.2f}")
    print(f"   ç›¸å…³æ€§è¯„åˆ†: {scores['relevance']:.2f}")
    print(f"   æ€»åˆ†: {total_score:.2f}")
    if issues:
        print(f"   é—®é¢˜: {', '.join(issues)}")

    return {
        "quality_score": total_score,
        "quality_issues": issues,
        "step": "evaluated"
    }

# 3. åæ€èŠ‚ç‚¹
def reflect_node(state: EnhancedSearchState) -> dict:
    """
    åˆ†æè´¨é‡é—®é¢˜å¹¶åˆ¶å®šæ”¹è¿›ç­–ç•¥
    """
    issues = state["quality_issues"]
    attempt = state["attempt_count"]

    print(f"\nğŸ¤” åæ€èŠ‚ç‚¹ (ç¬¬{attempt}æ¬¡å°è¯•)")
    print(f"   å‘ç°é—®é¢˜: {issues}")

    # å†³ç­–:åº”è¯¥é‡æ–°æœç´¢è¿˜æ˜¯é‡æ–°ç”Ÿæˆ?
    if "ç›¸å…³æ€§ä½" in issues or "ç¼ºå°‘å…·ä½“ç»†èŠ‚" in issues:
        strategy = "research"  # é‡æ–°æœç´¢
        print("   ç­–ç•¥: æœç´¢ç»“æœå¯èƒ½ä¸å¤Ÿ,éœ€è¦é‡æ–°æœç´¢")
    else:
        strategy = "regenerate"  # é‡æ–°ç”Ÿæˆ
        print("   ç­–ç•¥: ä¿¡æ¯å……è¶³,ä½†è¡¨è¿°éœ€è¦æ”¹è¿›")

    return {
        "improvement_strategy": strategy,
        "attempt_count": attempt + 1,
        "step": "reflected"
    }

# 4. æ”¹è¿›çš„æœç´¢èŠ‚ç‚¹
def improved_search_node(state: EnhancedSearchState) -> dict:
    """
    æ ¹æ®åæ€ç»“æœæ”¹è¿›æœç´¢
    """
    original_query = state["search_query"]
    issues = state["quality_issues"]

    # æ ¹æ®é—®é¢˜ä¼˜åŒ–æœç´¢è¯
    if "ç¼ºå°‘å…·ä½“ç»†èŠ‚" in issues:
        # æ·»åŠ "è¯¦ç»†""å…·ä½“"ç­‰ä¿®é¥°è¯
        improved_query = f"{original_query} è¯¦ç»†è¯´æ˜ å…·ä½“æ¡ˆä¾‹"
    else:
        # æ‰©å±•æœç´¢èŒƒå›´
        improved_query = f"{original_query} å®Œæ•´æŒ‡å—"

    print(f"ğŸ” æ”¹è¿›æœç´¢:")
    print(f"   åŸæŸ¥è¯¢: {original_query}")
    print(f"   æ–°æŸ¥è¯¢: {improved_query}")

    # æ‰§è¡Œæœç´¢ (è¿™é‡Œç®€åŒ–ä¸ºæ¨¡æ‹Ÿ)
    search_results = f"[æ”¹è¿›æœç´¢ç»“æœ] å…³äº {improved_query} çš„è¯¦ç»†ä¿¡æ¯..."

    return {
        "search_query": improved_query,
        "search_results": search_results,
        "step": "researched"
    }

# 5. æ¡ä»¶è¾¹:è´¨é‡æ£€æŸ¥è·¯ç”±
def should_continue_or_end(state: EnhancedSearchState) -> str:
    """
    å†³å®šæ˜¯ç»“æŸè¿˜æ˜¯ç»§ç»­æ”¹è¿›
    """
    score = state["quality_score"]
    attempts = state["attempt_count"]
    max_attempts = state.get("max_attempts", 3)

    # è´¨é‡åˆæ ¼æˆ–å·²è¾¾æœ€å¤§å°è¯•æ¬¡æ•°
    if score >= 0.7:
        print("âœ… è´¨é‡åˆæ ¼,ç»“æŸæµç¨‹")
        return "end"
    elif attempts >= max_attempts:
        print(f"âš ï¸  å·²è¾¾æœ€å¤§å°è¯•æ¬¡æ•°({max_attempts}),å¼ºåˆ¶ç»“æŸ")
        return "end"
    else:
        print(f"ğŸ”„ è´¨é‡ä¸è¶³(score={score:.2f}),è¿›å…¥åæ€")
        return "reflect"

# 6. æ¡ä»¶è¾¹:æ”¹è¿›ç­–ç•¥è·¯ç”±
def route_improvement_strategy(state: EnhancedSearchState) -> str:
    """
    æ ¹æ®æ”¹è¿›ç­–ç•¥è·¯ç”±åˆ°ä¸åŒèŠ‚ç‚¹
    """
    strategy = state["improvement_strategy"]

    if strategy == "research":
        return "search"  # å›åˆ°æœç´¢èŠ‚ç‚¹
    else:
        return "answer"  # å›åˆ°å›ç­”èŠ‚ç‚¹

# 7. æ„å»ºå®Œæ•´å›¾
def create_reflective_search_assistant():
    """åˆ›å»ºå¸¦åæ€æœºåˆ¶çš„æœç´¢åŠ©æ‰‹"""

    workflow = StateGraph(EnhancedSearchState)

    # æ·»åŠ æ‰€æœ‰èŠ‚ç‚¹
    workflow.add_node("understand", understand_query_node)
    workflow.add_node("search", improved_search_node)
    workflow.add_node("answer", generate_answer_node)
    workflow.add_node("evaluate", evaluate_quality_node)
    workflow.add_node("reflect", reflect_node)

    # è®¾ç½®å…¥å£
    workflow.set_entry_point("understand")

    # æ·»åŠ è¾¹
    workflow.add_edge("understand", "search")
    workflow.add_edge("search", "answer")
    workflow.add_edge("answer", "evaluate")

    # å…³é”®:æ¡ä»¶è¾¹1 (è´¨é‡æ£€æŸ¥)
    workflow.add_conditional_edges(
        "evaluate",
        should_continue_or_end,
        {
            "end": END,
            "reflect": "reflect"
        }
    )

    # å…³é”®:æ¡ä»¶è¾¹2 (æ”¹è¿›ç­–ç•¥è·¯ç”±)
    workflow.add_conditional_edges(
        "reflect",
        route_improvement_strategy,
        {
            "search": "search",   # å¾ªç¯å›æœç´¢
            "answer": "answer"    # å¾ªç¯å›å›ç­”
        }
    )

    # ç¼–è¯‘
    app = workflow.compile()
    return app

# 8. è¿è¡Œç¤ºä¾‹
def run_reflective_assistant():
    """è¿è¡Œå¸¦åæ€çš„åŠ©æ‰‹"""

    app = create_reflective_search_assistant()

    inputs = {
        "messages": [("user", "Pythonä¸­çš„è£…é¥°å™¨æ˜¯ä»€ä¹ˆ?")],
        "user_query": "",
        "search_query": "",
        "search_results": "",
        "final_answer": "",
        "step": "",
        "quality_score": 0.0,
        "attempt_count": 0,
        "max_attempts": 3,
        "quality_issues": [],
        "improvement_strategy": ""
    }

    print("ğŸš€ å¯åŠ¨åæ€å¼æœç´¢åŠ©æ‰‹\n")

    for event in app.stream(inputs):
        for node_name, node_output in event.items():
            print(f"\n[{node_name}èŠ‚ç‚¹è¾“å‡º]")
            if "step" in node_output:
                print(f"  å½“å‰é˜¶æ®µ: {node_output['step']}")
```

**è¿è¡Œæ•ˆæœç¤ºä¾‹**:

```
ğŸš€ å¯åŠ¨åæ€å¼æœç´¢åŠ©æ‰‹

[understandèŠ‚ç‚¹è¾“å‡º]
  å½“å‰é˜¶æ®µ: understood
  ç†è§£çš„æŸ¥è¯¢: Pythonè£…é¥°å™¨çš„æ¦‚å¿µå’Œç”¨æ³•

[searchèŠ‚ç‚¹è¾“å‡º]
  æœç´¢æŸ¥è¯¢: Python è£…é¥°å™¨
  å½“å‰é˜¶æ®µ: searched

[answerèŠ‚ç‚¹è¾“å‡º]
  ç”Ÿæˆç­”æ¡ˆ: è£…é¥°å™¨æ˜¯Pythonçš„ä¸€ä¸ªç‰¹æ€§...
  å½“å‰é˜¶æ®µ: answered

[evaluateèŠ‚ç‚¹è¾“å‡º]
ğŸ“Š è´¨é‡è¯„ä¼°:
   é•¿åº¦è¯„åˆ†: 0.30 (ç­”æ¡ˆè¿‡äºç®€çŸ­)
   ä¸°å¯Œåº¦è¯„åˆ†: 0.33 (ç¼ºå°‘å…·ä½“ç»†èŠ‚å’Œä¾‹å­)
   ç›¸å…³æ€§è¯„åˆ†: 0.80
   æ€»åˆ†: 0.44
   é—®é¢˜: ç­”æ¡ˆè¿‡äºç®€çŸ­, ç¼ºå°‘å…·ä½“ç»†èŠ‚å’Œä¾‹å­

ğŸ”„ è´¨é‡ä¸è¶³(score=0.44),è¿›å…¥åæ€

[reflectèŠ‚ç‚¹è¾“å‡º]
ğŸ¤” åæ€èŠ‚ç‚¹ (ç¬¬1æ¬¡å°è¯•)
   å‘ç°é—®é¢˜: ['ç­”æ¡ˆè¿‡äºç®€çŸ­', 'ç¼ºå°‘å…·ä½“ç»†èŠ‚å’Œä¾‹å­']
   ç­–ç•¥: æœç´¢ç»“æœå¯èƒ½ä¸å¤Ÿ,éœ€è¦é‡æ–°æœç´¢

[searchèŠ‚ç‚¹è¾“å‡º] (ç¬¬2æ¬¡)
ğŸ” æ”¹è¿›æœç´¢:
   åŸæŸ¥è¯¢: Python è£…é¥°å™¨
   æ–°æŸ¥è¯¢: Python è£…é¥°å™¨ è¯¦ç»†è¯´æ˜ å…·ä½“æ¡ˆä¾‹

[answerèŠ‚ç‚¹è¾“å‡º] (ç¬¬2æ¬¡)
  ç”Ÿæˆæ›´è¯¦ç»†çš„ç­”æ¡ˆ...

[evaluateèŠ‚ç‚¹è¾“å‡º] (ç¬¬2æ¬¡)
ğŸ“Š è´¨é‡è¯„ä¼°:
   é•¿åº¦è¯„åˆ†: 1.00
   ä¸°å¯Œåº¦è¯„åˆ†: 1.00
   ç›¸å…³æ€§è¯„åˆ†: 0.90
   æ€»åˆ†: 0.96

âœ… è´¨é‡åˆæ ¼,ç»“æŸæµç¨‹
```

---

### è§£ç­”5.3: å¤æ‚åº”ç”¨åœºæ™¯ - ä»£ç ç”Ÿæˆ-æµ‹è¯•-ä¿®å¤å¾ªç¯

#### ğŸ¯ åº”ç”¨åœºæ™¯:è‡ªåŠ¨åŒ–ä»£ç ç”ŸæˆåŠ©æ‰‹

**éœ€æ±‚**: æ ¹æ®ç”¨æˆ·çš„è‡ªç„¶è¯­è¨€æè¿°,ç”ŸæˆPythonä»£ç ,å¹¶è‡ªåŠ¨æµ‹è¯•ä¿®å¤ç›´åˆ°é€šè¿‡æ‰€æœ‰æµ‹è¯•

#### ğŸ“ å®Œæ•´å›¾ç»“æ„è®¾è®¡

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  START  â”‚
                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
                         â”‚
                         â†“
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  éœ€æ±‚åˆ†æèŠ‚ç‚¹         â”‚
              â”‚ (analyze_requirement)â”‚
              â”‚                      â”‚
              â”‚ è¾“å…¥: ç”¨æˆ·éœ€æ±‚æè¿°   â”‚
              â”‚ è¾“å‡º: ç»“æ„åŒ–éœ€æ±‚     â”‚
              â”‚ - åŠŸèƒ½åˆ—è¡¨           â”‚
              â”‚ - è¾“å…¥è¾“å‡ºè§„èŒƒ       â”‚
              â”‚ - è¾¹ç•Œæ¡ä»¶           â”‚
              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â†“
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  æµ‹è¯•ç”¨ä¾‹ç”ŸæˆèŠ‚ç‚¹     â”‚
              â”‚ (generate_tests)     â”‚
              â”‚                      â”‚
              â”‚ è¾“å…¥: ç»“æ„åŒ–éœ€æ±‚     â”‚
              â”‚ è¾“å‡º: å®Œæ•´æµ‹è¯•å¥—ä»¶   â”‚
              â”‚ - æ­£å¸¸ç”¨ä¾‹           â”‚
              â”‚ - è¾¹ç•Œç”¨ä¾‹           â”‚
              â”‚ - å¼‚å¸¸ç”¨ä¾‹           â”‚
              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â†“
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  ä»£ç ç”ŸæˆèŠ‚ç‚¹         â”‚
              â”‚ (generate_code)      â”‚
              â”‚                      â”‚
              â”‚ è¾“å…¥: éœ€æ±‚+æµ‹è¯•      â”‚
              â”‚ è¾“å‡º: Pythonä»£ç      â”‚
              â”‚ - å‡½æ•°å®ç°           â”‚
              â”‚ - æ³¨é‡Šæ–‡æ¡£           â”‚
              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â†“
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  è¯­æ³•æ£€æŸ¥èŠ‚ç‚¹         â”‚
              â”‚ (syntax_check)       â”‚
              â”‚                      â”‚
              â”‚ å·¥å…·: ast.parse()    â”‚
              â”‚ æ£€æŸ¥: è¯­æ³•é”™è¯¯       â”‚
              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
             â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
             â”‚           â”‚
        è¯­æ³•æ­£ç¡®?    è¯­æ³•é”™è¯¯?
             â”‚           â”‚
             â”‚           â†“
             â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚     â”‚  è¯­æ³•ä¿®å¤èŠ‚ç‚¹     â”‚
             â”‚     â”‚ (fix_syntax)     â”‚
             â”‚     â”‚                  â”‚
             â”‚     â”‚ - åˆ†æé”™è¯¯ä¿¡æ¯   â”‚
             â”‚     â”‚ - LLMä¿®å¤ä»£ç     â”‚
             â”‚     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚          â”‚
             â”‚          â”‚ (å¾ªç¯å›ä»£ç ç”Ÿæˆ)
             â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚                     â”‚
             â†“                     â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
      â”‚  è¿è¡Œæµ‹è¯•èŠ‚ç‚¹         â”‚ â†â”€â”˜
      â”‚ (run_tests)          â”‚
      â”‚                      â”‚
      â”‚ å·¥å…·: pytest         â”‚
      â”‚ è¾“å‡º: æµ‹è¯•æŠ¥å‘Š       â”‚
      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
      â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
      â”‚          â”‚
 å…¨éƒ¨é€šè¿‡?   æœ‰å¤±è´¥?
 (pass_rate  (pass_rate
  = 100%)     < 100%)
      â”‚          â”‚
      â”‚          â†“
      â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚    â”‚  å¤±è´¥åˆ†æèŠ‚ç‚¹         â”‚
      â”‚    â”‚ (analyze_failures)   â”‚
      â”‚    â”‚                      â”‚
      â”‚    â”‚ - æå–å¤±è´¥åŸå›        â”‚
      â”‚    â”‚ - åˆ†ç±»é”™è¯¯ç±»å‹       â”‚
      â”‚    â”‚ - å®šä½é—®é¢˜ä»£ç        â”‚
      â”‚    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚         â”‚
      â”‚         â†“
      â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚    â”‚  å†³ç­–èŠ‚ç‚¹             â”‚
      â”‚    â”‚ (decide_strategy)    â”‚
      â”‚    â”‚                      â”‚
      â”‚    â”‚ æ ¹æ®é”™è¯¯ç±»å‹å†³å®š:    â”‚
      â”‚    â”‚ - é€»è¾‘é”™è¯¯â†’ä»£ç ä¿®å¤  â”‚
      â”‚    â”‚ - ç†è§£åå·®â†’é‡æ–°ç”Ÿæˆ  â”‚
      â”‚    â”‚ - è¾¹ç•Œé—®é¢˜â†’å±€éƒ¨ä¿®è¡¥  â”‚
      â”‚    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚         â”‚
      â”‚    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚    â”‚                â”‚
      â”‚   é€»è¾‘é”™è¯¯?      ç†è§£é”™è¯¯?
      â”‚    â”‚                â”‚
      â”‚    â†“                â†“
      â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ â”‚ä»£ç ä¿®å¤â”‚    â”‚é‡æ–°åˆ†æéœ€æ±‚â”‚
      â”‚ â”‚èŠ‚ç‚¹    â”‚    â”‚èŠ‚ç‚¹        â”‚
      â”‚ â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
      â”‚     â”‚              â”‚
      â”‚     â”‚              â†“
      â”‚     â”‚         (å›åˆ°éœ€æ±‚åˆ†æ)
      â”‚     â”‚
      â”‚     â””â”€â”€â”€â”€â”€â”€â†’ (å›åˆ°è¿è¡Œæµ‹è¯•)
      â”‚
      â†“
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚  ä»£ç ä¼˜åŒ–èŠ‚ç‚¹         â”‚
 â”‚ (optimize_code)      â”‚
 â”‚                      â”‚
 â”‚ - æ€§èƒ½ä¼˜åŒ–           â”‚
 â”‚ - ä»£ç è§„èŒƒ           â”‚
 â”‚ - æ·»åŠ ç±»å‹æ³¨è§£       â”‚
 â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â†“
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚  æ–‡æ¡£ç”ŸæˆèŠ‚ç‚¹         â”‚
 â”‚ (generate_docs)      â”‚
 â”‚                      â”‚
 â”‚ - å‡½æ•°æ–‡æ¡£å­—ç¬¦ä¸²     â”‚
 â”‚ - ä½¿ç”¨ç¤ºä¾‹           â”‚
 â”‚ - README             â”‚
 â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â†“
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚   END    â”‚
 â”‚          â”‚
 â”‚ è¾“å‡º:     â”‚
 â”‚ - ä»£ç     â”‚
 â”‚ - æµ‹è¯•    â”‚
 â”‚ - æ–‡æ¡£    â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

çŠ¶æ€æ•°æ®ç»“æ„:
CodeGenState {
    requirement: str,           # åŸå§‹éœ€æ±‚
    parsed_requirement: dict,   # ç»“æ„åŒ–éœ€æ±‚
    test_cases: list,          # æµ‹è¯•ç”¨ä¾‹
    generated_code: str,        # ç”Ÿæˆçš„ä»£ç 
    syntax_errors: list,        # è¯­æ³•é”™è¯¯åˆ—è¡¨
    test_results: dict,         # æµ‹è¯•ç»“æœ
    failed_tests: list,         # å¤±è´¥çš„æµ‹è¯•
    failure_analysis: dict,     # å¤±è´¥åˆ†æ
    fix_strategy: str,          # ä¿®å¤ç­–ç•¥
    iteration_count: int,       # è¿­ä»£æ¬¡æ•°
    max_iterations: int,        # æœ€å¤§è¿­ä»£æ¬¡æ•°
    final_code: str,            # æœ€ç»ˆä»£ç 
    documentation: str          # æ–‡æ¡£
}
```

---

#### ğŸ’» å…³é”®èŠ‚ç‚¹å®ç°

```python
from typing import TypedDict
from langgraph.graph import StateGraph, END
import ast
import subprocess

class CodeGenState(TypedDict):
    requirement: str
    parsed_requirement: dict
    test_cases: list
    generated_code: str
    syntax_errors: list
    test_results: dict
    failed_tests: list
    failure_analysis: dict
    fix_strategy: str
    iteration_count: int
    max_iterations: int
    final_code: str
    documentation: str

# èŠ‚ç‚¹1: éœ€æ±‚åˆ†æ
def analyze_requirement_node(state: CodeGenState) -> dict:
    """åˆ†æç”¨æˆ·éœ€æ±‚,ç”Ÿæˆç»“æ„åŒ–è§„èŒƒ"""
    requirement = state["requirement"]

    # ä½¿ç”¨LLMåˆ†æéœ€æ±‚
    prompt = f"""åˆ†æä»¥ä¸‹ç¼–ç¨‹éœ€æ±‚,æå–å…³é”®ä¿¡æ¯:

éœ€æ±‚: {requirement}

è¯·è¾“å‡ºJSONæ ¼å¼:
{{
    "function_name": "å‡½æ•°å",
    "description": "åŠŸèƒ½æè¿°",
    "inputs": [{{"name": "å‚æ•°å", "type": "ç±»å‹", "description": "è¯´æ˜"}}],
    "output": {{"type": "è¿”å›ç±»å‹", "description": "è¯´æ˜"}},
    "edge_cases": ["è¾¹ç•Œæƒ…å†µ1", "è¾¹ç•Œæƒ…å†µ2"]
}}
"""

    # è¿™é‡Œç®€åŒ–,å®é™…åº”è°ƒç”¨LLM
    parsed = {
        "function_name": "calculate_fibonacci",
        "description": "è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—ç¬¬né¡¹",
        "inputs": [{"name": "n", "type": "int", "description": "é¡¹æ•°"}],
        "output": {"type": "int", "description": "ç¬¬né¡¹çš„å€¼"},
        "edge_cases": ["n=0", "n=1", "n<0", "n>100"]
    }

    print(f"âœ… éœ€æ±‚åˆ†æå®Œæˆ: {parsed['function_name']}")
    return {"parsed_requirement": parsed}

# èŠ‚ç‚¹2: ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹
def generate_tests_node(state: CodeGenState) -> dict:
    """åŸºäºéœ€æ±‚ç”Ÿæˆå®Œæ•´æµ‹è¯•å¥—ä»¶"""
    spec = state["parsed_requirement"]

    test_template = f"""
import pytest
from solution import {spec['function_name']}

class Test{spec['function_name'].title()}:
    def test_normal_case(self):
        assert {spec['function_name']}(5) == 5
        assert {spec['function_name']}(10) == 55

    def test_edge_case_zero(self):
        assert {spec['function_name']}(0) == 0

    def test_edge_case_one(self):
        assert {spec['function_name']}(1) == 1

    def test_negative_input(self):
        with pytest.raises(ValueError):
            {spec['function_name']}(-1)
"""

    print("âœ… æµ‹è¯•ç”¨ä¾‹ç”Ÿæˆå®Œæˆ")
    return {"test_cases": [test_template]}

# èŠ‚ç‚¹3: ä»£ç ç”Ÿæˆ
def generate_code_node(state: CodeGenState) -> dict:
    """ç”ŸæˆPythonä»£ç å®ç°"""
    spec = state["parsed_requirement"]
    iteration = state.get("iteration_count", 0)

    # å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡ç”Ÿæˆ
    if iteration == 0:
        code = f"""
def {spec['function_name']}(n: int) -> int:
    \"\"\"
    {spec['description']}

    Args:
        n: {spec['inputs'][0]['description']}

    Returns:
        {spec['output']['description']}
    \"\"\"
    if n < 0:
        raise ValueError("n must be non-negative")
    if n == 0:
        return 0
    if n == 1:
        return 1

    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b
"""
    else:
        # åŸºäºå¤±è´¥åˆ†æä¿®å¤ä»£ç 
        failure_info = state.get("failure_analysis", {})
        code = f"# ä¿®å¤åçš„ä»£ç ,ç¬¬{iteration}æ¬¡è¿­ä»£\n"  + state["generated_code"]

    print(f"âœ… ä»£ç ç”Ÿæˆå®Œæˆ (è¿­ä»£{iteration})")
    return {
        "generated_code": code,
        "iteration_count": iteration + 1
    }

# èŠ‚ç‚¹4: è¯­æ³•æ£€æŸ¥
def syntax_check_node(state: CodeGenState) -> dict:
    """æ£€æŸ¥ä»£ç è¯­æ³•"""
    code = state["generated_code"]

    try:
        ast.parse(code)
        print("âœ… è¯­æ³•æ£€æŸ¥é€šè¿‡")
        return {"syntax_errors": []}
    except SyntaxError as e:
        error_msg = f"ç¬¬{e.lineno}è¡Œ: {e.msg}"
        print(f"âŒ è¯­æ³•é”™è¯¯: {error_msg}")
        return {"syntax_errors": [error_msg]}

# èŠ‚ç‚¹5: è¿è¡Œæµ‹è¯•
def run_tests_node(state: CodeGenState) -> dict:
    """è¿è¡Œpytestæµ‹è¯•"""
    code = state["generated_code"]
    tests = state["test_cases"][0]

    # å†™å…¥ä¸´æ—¶æ–‡ä»¶
    with open("/tmp/solution.py", "w") as f:
        f.write(code)
    with open("/tmp/test_solution.py", "w") as f:
        f.write(tests)

    # è¿è¡Œpytest
    result = subprocess.run(
        ["pytest", "/tmp/test_solution.py", "-v"],
        capture_output=True,
        text=True
    )

    # è§£æç»“æœ
    passed = result.returncode == 0
    output = result.stdout + result.stderr

    if passed:
        print("âœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡!")
        return {
            "test_results": {"passed": True, "output": output},
            "failed_tests": []
        }
    else:
        print(f"âŒ æµ‹è¯•å¤±è´¥:\n{output}")
        return {
            "test_results": {"passed": False, "output": output},
            "failed_tests": ["è¯¦ç»†å¤±è´¥ä¿¡æ¯"]
        }

# æ¡ä»¶è¾¹: è¯­æ³•æ£€æŸ¥è·¯ç”±
def route_after_syntax_check(state: CodeGenState) -> str:
    """æ ¹æ®è¯­æ³•æ£€æŸ¥ç»“æœè·¯ç”±"""
    if state["syntax_errors"]:
        return "fix_syntax"
    else:
        return "run_tests"

# æ¡ä»¶è¾¹: æµ‹è¯•ç»“æœè·¯ç”±
def route_after_tests(state: CodeGenState) -> str:
    """æ ¹æ®æµ‹è¯•ç»“æœè·¯ç”±"""
    if state["test_results"]["passed"]:
        return "optimize"  # é€šè¿‡â†’ä¼˜åŒ–
    elif state["iteration_count"] >= state["max_iterations"]:
        return "end"  # è¶…è¿‡æœ€å¤§è¿­ä»£â†’å¼ºåˆ¶ç»“æŸ
    else:
        return "analyze_failures"  # å¤±è´¥â†’åˆ†æ

# æ„å»ºå®Œæ•´å›¾
def create_code_gen_workflow():
    """åˆ›å»ºä»£ç ç”Ÿæˆå·¥ä½œæµ"""

    workflow = StateGraph(CodeGenState)

    # æ·»åŠ æ‰€æœ‰èŠ‚ç‚¹
    workflow.add_node("analyze", analyze_requirement_node)
    workflow.add_node("gen_tests", generate_tests_node)
    workflow.add_node("gen_code", generate_code_node)
    workflow.add_node("syntax_check", syntax_check_node)
    workflow.add_node("run_tests", run_tests_node)

    # è®¾ç½®å…¥å£
    workflow.set_entry_point("analyze")

    # çº¿æ€§æµç¨‹
    workflow.add_edge("analyze", "gen_tests")
    workflow.add_edge("gen_tests", "gen_code")
    workflow.add_edge("gen_code", "syntax_check")

    # æ¡ä»¶è¾¹:è¯­æ³•æ£€æŸ¥
    workflow.add_conditional_edges(
        "syntax_check",
        route_after_syntax_check,
        {
            "fix_syntax": "gen_code",  # å¾ªç¯ä¿®å¤
            "run_tests": "run_tests"
        }
    )

    # æ¡ä»¶è¾¹:æµ‹è¯•ç»“æœ
    workflow.add_conditional_edges(
        "run_tests",
        route_after_tests,
        {
            "optimize": END,
            "analyze_failures": "gen_code",  # å¾ªç¯ä¿®å¤
            "end": END
        }
    )

    return workflow.compile()
```

---

#### ğŸ¯ åº”ç”¨ä»·å€¼

è¿™ä¸ª"ä»£ç ç”Ÿæˆ-æµ‹è¯•-ä¿®å¤"å¾ªç¯å……åˆ†å±•ç¤ºäº†LangGraphçš„ä¼˜åŠ¿:

1. **å¤šå±‚å¾ªç¯**: è¯­æ³•ä¿®å¤å¾ªç¯ + åŠŸèƒ½ä¿®å¤å¾ªç¯
2. **æ™ºèƒ½è·¯ç”±**: æ ¹æ®é”™è¯¯ç±»å‹é€‰æ‹©ä¸åŒçš„ä¿®å¤ç­–ç•¥
3. **çŠ¶æ€ç´¯ç§¯**: è¿­ä»£æ¬¡æ•°ã€é”™è¯¯å†å²ç­‰çŠ¶æ€åœ¨å¾ªç¯ä¸­ä¸æ–­ç§¯ç´¯
4. **ç»ˆæ­¢ä¿éšœ**: é€šè¿‡max_iterationsé˜²æ­¢æ— é™å¾ªç¯

**å®é™…åº”ç”¨åœºæ™¯**:
- åœ¨çº¿ç¼–ç¨‹æ•™è‚²å¹³å°çš„è‡ªåŠ¨ä½œä¸šæ‰¹æ”¹
- ä»£ç å®¡æŸ¥ç³»ç»Ÿçš„è‡ªåŠ¨ä¿®å¤å»ºè®®
- IDEä¸­çš„æ™ºèƒ½ä»£ç è¡¥å…¨å’Œä¿®å¤

---

è¿™å°±æ˜¯ç¬¬5é¢˜çš„å®Œæ•´è§£ç­”!åŒ…å«:
1. ä¸‰æ­¥é—®ç­”åŠ©æ‰‹çš„å›¾ç»“æ„åˆ†æ
2. å¸¦åæ€å¾ªç¯çš„æ‰©å±•è®¾è®¡å’Œå®Œæ•´å®ç°
3. å¤æ‚åœºæ™¯:ä»£ç ç”Ÿæˆ-æµ‹è¯•-ä¿®å¤å¾ªç¯çš„è¯¦ç»†è®¾è®¡

---

## ç¬¬6é¢˜:æ¡†æ¶é€‰æ‹©å®æˆ˜

### é¢˜ç›®

ä½ ç°åœ¨è¦ä¸ºä¸‰ä¸ªä¸åŒçš„AIåº”ç”¨é€‰æ‹©åˆé€‚çš„æ¡†æ¶(AutoGen/AgentScope/CAMEL/LangGraphæˆ–è‡ªç ”),è¯·æ ¹æ®ä»¥ä¸‹åœºæ™¯åˆ†æå¹¶è¯´æ˜é€‰æ‹©ç†ç”±:

**åº”ç”¨A**: æ™ºèƒ½å®¢æœç³»ç»Ÿ
- éœ€è¦åŒæ—¶å¤„ç†å¤§é‡ç”¨æˆ·è¯·æ±‚
- å¯¹å“åº”æ—¶é—´è¦æ±‚é«˜(< 3ç§’)
- éœ€è¦ä¸ä¼ä¸šå†…éƒ¨å¤šä¸ªç³»ç»Ÿé›†æˆ(å·¥å•ç³»ç»Ÿã€CRMã€çŸ¥è¯†åº“ç­‰)
- éœ€è¦æ”¯æŒå¤šè½®å¯¹è¯å’Œä¸Šä¸‹æ–‡è®°å¿†

**åº”ç”¨B**: ç§‘ç ”è®ºæ–‡å†™ä½œåŠ©æ‰‹
- éœ€è¦å¤šä¸ªæ™ºèƒ½ä½“åä½œ(æ–‡çŒ®æ£€ç´¢ã€å¤§çº²ç”Ÿæˆã€å†…å®¹æ’°å†™ã€æ ¼å¼å®¡æŸ¥ç­‰)
- å¯¹ç»“æœè´¨é‡è¦æ±‚é«˜,éœ€è¦å¤šè½®è¿­ä»£ä¼˜åŒ–
- ç”¨æˆ·å¹¶å‘é‡å°,ä½†å•ä¸ªä»»åŠ¡æ‰§è¡Œæ—¶é—´é•¿(å¯èƒ½æ•°å°æ—¶)
- éœ€è¦äººå·¥ä»‹å…¥å®¡æ ¸å…³é”®æ­¥éª¤

**åº”ç”¨C**: é‡‘èé£æ§å®¡æ‰¹ç³»ç»Ÿ
- éœ€è¦å¤šä¸ªä¸“å®¶æ™ºèƒ½ä½“(åˆè§„å®¡æŸ¥ã€é£é™©è¯„ä¼°ã€é¢åº¦è®¡ç®—ç­‰)ç‹¬ç«‹è¯„ä¼°
- å¯¹ç³»ç»Ÿç¨³å®šæ€§å’Œå¯è¿½æº¯æ€§è¦æ±‚æé«˜
- éœ€è¦è¯¦ç»†çš„å†³ç­–æ—¥å¿—å’Œå®¡è®¡è¿½è¸ª
- éœ€è¦æ”¯æŒè§„åˆ™å¼•æ“å’Œäººå·¥å¤æ ¸

è¯·ä¸ºæ¯ä¸ªåº”ç”¨é€‰æ‹©æœ€åˆé€‚çš„æ¡†æ¶,å¹¶è¯´æ˜:
1. é€‰æ‹©è¯¥æ¡†æ¶çš„æ ¸å¿ƒç†ç”±
2. è¯¥æ¡†æ¶å¦‚ä½•æ»¡è¶³åº”ç”¨çš„å…³é”®éœ€æ±‚
3. å¯èƒ½éœ€è¦çš„é¢å¤–å¼€å‘å·¥ä½œ

---

### è§£ç­”

#### åº”ç”¨A: æ™ºèƒ½å®¢æœç³»ç»Ÿ - æ¨èé€‰æ‹© **AgentScope**

##### 1. é€‰æ‹©æ ¸å¿ƒç†ç”±

AgentScopeæœ€é€‚åˆæ™ºèƒ½å®¢æœåœºæ™¯çš„ä¸‰å¤§æ ¸å¿ƒåŸå› :

**é«˜å¹¶å‘å¤„ç†èƒ½åŠ›**
```
AgentScopeçš„æ¶ˆæ¯é©±åŠ¨æ¶æ„å¤©ç„¶æ”¯æŒé«˜å¹¶å‘:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      è´Ÿè½½å‡è¡¡å±‚ (Nginx/HAProxy)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
       â”‚               â”‚
   â”Œâ”€â”€â”€â–¼â”€â”€â”€â”      â”Œâ”€â”€â”€â–¼â”€â”€â”€â”
   â”‚ Agent â”‚      â”‚ Agent â”‚  å¤šå®ä¾‹éƒ¨ç½²
   â”‚ Pool1 â”‚      â”‚ Pool2 â”‚
   â””â”€â”€â”€â”¬â”€â”€â”€â”˜      â””â”€â”€â”€â”¬â”€â”€â”€â”˜
       â”‚               â”‚
   â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”
   â”‚   MsgHub (Redis)      â”‚  å…±äº«æ¶ˆæ¯æ€»çº¿
   â”‚   - ç”¨æˆ·ä¼šè¯çŠ¶æ€       â”‚
   â”‚   - æ¶ˆæ¯é˜Ÿåˆ—          â”‚
   â”‚   - ä¸Šä¸‹æ–‡ç¼“å­˜        â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**åŸç”Ÿåˆ†å¸ƒå¼æ¶æ„**
- AgentScopeçš„`MsgHub`æ”¯æŒåˆ†å¸ƒå¼éƒ¨ç½²,å¯è½»æ¾æ‰©å±•åˆ°å¤šå°æœåŠ¡å™¨
- æ¶ˆæ¯é©±åŠ¨æ¨¡å¼è§£è€¦äº†æ™ºèƒ½ä½“ä¹‹é—´çš„ä¾èµ–,æé«˜äº†ç³»ç»Ÿå¼¹æ€§
- æ”¯æŒRedis/Kafkaç­‰æˆç†Ÿçš„æ¶ˆæ¯ä¸­é—´ä»¶,è¿ç»´æˆç†Ÿåº¦é«˜

**å¿«é€Ÿå“åº”æ—¶é—´**
- å¼‚æ­¥æ¶ˆæ¯å¤„ç†é¿å…äº†åŒæ­¥è°ƒç”¨çš„é˜»å¡
- å¯ä»¥é¢„åŠ è½½å¸¸ç”¨æ™ºèƒ½ä½“å®ä¾‹,å‡å°‘å†·å¯åŠ¨æ—¶é—´
- æ”¯æŒæµå¼å“åº”,æå‡ç”¨æˆ·ä½“éªŒ

##### 2. æ»¡è¶³å…³é”®éœ€æ±‚çš„æŠ€æœ¯æ–¹æ¡ˆ

**éœ€æ±‚1: åŒæ—¶å¤„ç†å¤§é‡ç”¨æˆ·è¯·æ±‚**

```python
from agentscope.agents import DialogAgent
from agentscope.message import Msg
from agentscope.msghub import msghub
import agentscope
from typing import Dict
import asyncio

# é…ç½®åˆ†å¸ƒå¼MsgHub
agentscope.init(
    model_configs={
        "my_model": {
            "config_name": "my_model",
            "model_type": "openai_chat",
            "model_name": "gpt-4",
            "api_key": "YOUR_API_KEY",
        }
    },
    agent_configs=[
        {
            "name": "customer_service_agent",
            "class": "DialogAgent",
            "args": {
                "model_config_name": "my_model",
                "sys_prompt": "ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å®¢æœåŠ©æ‰‹..."
            }
        }
    ],
    runtime_config={
        "msghub": {
            "type": "redis",
            "host": "redis.example.com",
            "port": 6379,
            "db": 0
        }
    }
)

class CustomerServiceCoordinator:
    """å®¢æœåè°ƒå™¨ - è´Ÿè´£ä¼šè¯ç®¡ç†å’Œæ™ºèƒ½ä½“è°ƒåº¦"""

    def __init__(self, agent_pool_size: int = 10):
        # é¢„åˆ›å»ºæ™ºèƒ½ä½“æ± 
        self.agent_pool = [
            DialogAgent(
                name=f"cs_agent_{i}",
                model_config_name="my_model",
                sys_prompt=self.get_cs_prompt()
            )
            for i in range(agent_pool_size)
        ]
        self.session_map: Dict[str, int] = {}  # ç”¨æˆ·ID -> Agentç´¢å¼•

    def get_cs_prompt(self) -> str:
        return """ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å®¢æœåŠ©æ‰‹,è´Ÿè´£:
1. å›ç­”ç”¨æˆ·å…³äºäº§å“å’ŒæœåŠ¡çš„é—®é¢˜
2. å¤„ç†ç”¨æˆ·æŠ•è¯‰å’Œå»ºè®®
3. å¿…è¦æ—¶åˆ›å»ºå·¥å•å¹¶è½¬æ¥äººå·¥å®¢æœ
4. ä¿æŒç¤¼è²Œã€è€å¿ƒå’Œä¸“ä¸šçš„æ€åº¦
"""

    async def handle_user_message(
        self,
        user_id: str,
        message: str,
        context: dict = None
    ) -> str:
        """å¤„ç†ç”¨æˆ·æ¶ˆæ¯ - å¼‚æ­¥éé˜»å¡"""

        # è·å–æˆ–åˆ†é…æ™ºèƒ½ä½“
        agent_idx = self._get_agent_for_user(user_id)
        agent = self.agent_pool[agent_idx]

        # æ„å»ºæ¶ˆæ¯(åŒ…å«ä¸Šä¸‹æ–‡)
        msg = Msg(
            name=user_id,
            content=message,
            role="user",
            metadata={
                "session_id": user_id,
                "context": context or {},
                "timestamp": agentscope.utils.get_timestamp()
            }
        )

        # å¼‚æ­¥è°ƒç”¨æ™ºèƒ½ä½“å¤„ç†
        response = await asyncio.to_thread(agent, msg)

        # æ£€æŸ¥æ˜¯å¦éœ€è¦è°ƒç”¨å¤–éƒ¨ç³»ç»Ÿ
        if self._should_create_ticket(response):
            await self._create_ticket(user_id, message, response)

        return response.content

    def _get_agent_for_user(self, user_id: str) -> int:
        """ä¸ºç”¨æˆ·åˆ†é…æ™ºèƒ½ä½“(ä¼šè¯ä¿æŒ)"""
        if user_id not in self.session_map:
            # ä½¿ç”¨å“ˆå¸Œåˆ†é…,ä¿è¯åŒä¸€ç”¨æˆ·æ€»æ˜¯åˆ†é…åˆ°åŒä¸€æ™ºèƒ½ä½“
            self.session_map[user_id] = hash(user_id) % len(self.agent_pool)
        return self.session_map[user_id]

    def _should_create_ticket(self, response: Msg) -> bool:
        """åˆ¤æ–­æ˜¯å¦éœ€è¦åˆ›å»ºå·¥å•"""
        # æ£€æŸ¥å“åº”ä¸­çš„å…ƒæ•°æ®æ ‡è®°
        return response.metadata.get("create_ticket", False)

    async def _create_ticket(self, user_id: str, question: str, response: Msg):
        """åˆ›å»ºå·¥å•å¹¶æ¨é€åˆ°å·¥å•ç³»ç»Ÿ"""
        # è¿™é‡Œé›†æˆä¼ä¸šå·¥å•ç³»ç»ŸAPI
        pass

# ä½¿ç”¨ç¤ºä¾‹:é«˜å¹¶å‘åœºæ™¯
async def main():
    coordinator = CustomerServiceCoordinator(agent_pool_size=20)

    # æ¨¡æ‹Ÿ100ä¸ªå¹¶å‘ç”¨æˆ·è¯·æ±‚
    tasks = [
        coordinator.handle_user_message(
            user_id=f"user_{i}",
            message="æˆ‘æƒ³äº†è§£é€€è´§æ”¿ç­–",
            context={"source": "mobile_app"}
        )
        for i in range(100)
    ]

    # å¹¶å‘å¤„ç†æ‰€æœ‰è¯·æ±‚
    responses = await asyncio.gather(*tasks)

    # å¹³å‡å“åº”æ—¶é—´ < 3ç§’
    for i, resp in enumerate(responses):
        print(f"User {i}: {resp}")

if __name__ == "__main__":
    asyncio.run(main())
```

**éœ€æ±‚2: ä¼ä¸šç³»ç»Ÿé›†æˆ**

```python
from agentscope.agents import AgentBase
from agentscope.service import ServiceResponse
import requests

class EnterpriseIntegrationAgent(AgentBase):
    """ä¼ä¸šç³»ç»Ÿé›†æˆæ™ºèƒ½ä½“"""

    def __init__(
        self,
        name: str,
        crm_api_url: str,
        ticket_api_url: str,
        knowledge_base_url: str,
        **kwargs
    ):
        super().__init__(name=name, **kwargs)
        self.crm_api = crm_api_url
        self.ticket_api = ticket_api_url
        self.kb_api = knowledge_base_url

    def query_customer_info(self, user_id: str) -> dict:
        """æŸ¥è¯¢CRMç³»ç»Ÿè·å–å®¢æˆ·ä¿¡æ¯"""
        try:
            response = requests.get(
                f"{self.crm_api}/customers/{user_id}",
                timeout=2  # å¿«é€Ÿå¤±è´¥,é¿å…é˜»å¡
            )
            if response.status_code == 200:
                return response.json()
        except Exception as e:
            self.logger.warning(f"CRMæŸ¥è¯¢å¤±è´¥: {e}")
        return {}

    def search_knowledge_base(self, query: str, top_k: int = 3) -> list:
        """ä»çŸ¥è¯†åº“æ£€ç´¢ç›¸å…³æ–‡æ¡£"""
        try:
            response = requests.post(
                f"{self.kb_api}/search",
                json={"query": query, "top_k": top_k},
                timeout=2
            )
            if response.status_code == 200:
                return response.json()["results"]
        except Exception as e:
            self.logger.warning(f"çŸ¥è¯†åº“æ£€ç´¢å¤±è´¥: {e}")
        return []

    def create_ticket(self, user_id: str, issue: str, priority: str) -> str:
        """åˆ›å»ºå·¥å•"""
        try:
            response = requests.post(
                f"{self.ticket_api}/tickets",
                json={
                    "user_id": user_id,
                    "issue": issue,
                    "priority": priority,
                    "source": "ai_agent"
                },
                timeout=3
            )
            if response.status_code == 201:
                return response.json()["ticket_id"]
        except Exception as e:
            self.logger.error(f"å·¥å•åˆ›å»ºå¤±è´¥: {e}")
        return None

    def reply(self, x: Msg) -> Msg:
        """å¤„ç†æ¶ˆæ¯å¹¶é›†æˆä¼ä¸šç³»ç»Ÿ"""

        user_id = x.metadata.get("session_id")

        # 1. æŸ¥è¯¢å®¢æˆ·ä¿¡æ¯
        customer_info = self.query_customer_info(user_id)
        vip_level = customer_info.get("vip_level", "normal")

        # 2. ä»çŸ¥è¯†åº“æ£€ç´¢ç›¸å…³ç­”æ¡ˆ
        kb_results = self.search_knowledge_base(x.content)

        # 3. æ„å»ºå¢å¼ºçš„æç¤ºè¯
        enhanced_prompt = f"""
ç”¨æˆ·ä¿¡æ¯:
- ç”¨æˆ·ID: {user_id}
- VIPç­‰çº§: {vip_level}
- å†å²è®¢å•æ•°: {customer_info.get('order_count', 0)}

çŸ¥è¯†åº“ç›¸å…³ä¿¡æ¯:
{self._format_kb_results(kb_results)}

ç”¨æˆ·é—®é¢˜: {x.content}

è¯·æ ¹æ®ä»¥ä¸Šä¿¡æ¯æä¾›ä¸“ä¸šçš„å®¢æœå›å¤ã€‚
"""

        # 4. è°ƒç”¨LLMç”Ÿæˆå›å¤
        response = self.model(enhanced_prompt)

        # 5. åˆ¤æ–­æ˜¯å¦éœ€è¦åˆ›å»ºå·¥å•
        if self._needs_human_intervention(response.text):
            ticket_id = self.create_ticket(
                user_id=user_id,
                issue=x.content,
                priority="high" if vip_level == "gold" else "normal"
            )
            response.text += f"\n\nå·²ä¸ºæ‚¨åˆ›å»ºå·¥å• {ticket_id},å°†æœ‰äººå·¥å®¢æœè·Ÿè¿›å¤„ç†ã€‚"

        return Msg(
            name=self.name,
            content=response.text,
            role="assistant"
        )

    def _format_kb_results(self, results: list) -> str:
        """æ ¼å¼åŒ–çŸ¥è¯†åº“æ£€ç´¢ç»“æœ"""
        if not results:
            return "æš‚æ— ç›¸å…³çŸ¥è¯†åº“æ–‡æ¡£"
        return "\n".join([
            f"- {r['title']}: {r['summary']}"
            for r in results
        ])

    def _needs_human_intervention(self, response: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦éœ€è¦äººå·¥ä»‹å…¥"""
        # ç®€å•çš„è§„åˆ™åˆ¤æ–­,å®é™…å¯ä»¥ç”¨åˆ†ç±»æ¨¡å‹
        keywords = ["é€€æ¬¾", "æŠ•è¯‰", "ä¸æ»¡æ„", "è¦æ±‚èµ”å¿"]
        return any(kw in response for kw in keywords)
```

**éœ€æ±‚3: å¤šè½®å¯¹è¯å’Œä¸Šä¸‹æ–‡è®°å¿†**

```python
from agentscope.memory import TemporaryMemory
from agentscope.agents import DialogAgent

class ConversationalCSAgent(DialogAgent):
    """æ”¯æŒä¸Šä¸‹æ–‡è®°å¿†çš„å¯¹è¯å‹å®¢æœæ™ºèƒ½ä½“"""

    def __init__(self, name: str, **kwargs):
        super().__init__(name=name, **kwargs)
        # ä½¿ç”¨AgentScopeçš„å†…å­˜ç®¡ç†
        self.memory = TemporaryMemory()

    def reply(self, x: Msg) -> Msg:
        """å¸¦ä¸Šä¸‹æ–‡è®°å¿†çš„å›å¤"""

        # 1. æ·»åŠ å½“å‰æ¶ˆæ¯åˆ°è®°å¿†
        self.memory.add(x)

        # 2. è·å–æœ€è¿‘Nè½®å¯¹è¯å†å²
        recent_history = self.memory.get_memory(
            recent_n=5,  # æœ€è¿‘5è½®å¯¹è¯
            filter_func=lambda m: m.role in ["user", "assistant"]
        )

        # 3. æ„å»ºåŒ…å«ä¸Šä¸‹æ–‡çš„æç¤ºè¯
        context_prompt = self._build_context_prompt(recent_history)

        # 4. è°ƒç”¨æ¨¡å‹ç”Ÿæˆå›å¤
        response = self.model(context_prompt + "\n\n" + x.content)

        # 5. å°†å›å¤ä¹ŸåŠ å…¥è®°å¿†
        response_msg = Msg(
            name=self.name,
            content=response.text,
            role="assistant"
        )
        self.memory.add(response_msg)

        return response_msg

    def _build_context_prompt(self, history: list) -> str:
        """æ„å»ºä¸Šä¸‹æ–‡æç¤ºè¯"""
        if not history:
            return ""

        context = "å¯¹è¯å†å²:\n"
        for msg in history:
            role = "ç”¨æˆ·" if msg.role == "user" else "å®¢æœ"
            context += f"{role}: {msg.content}\n"

        return context
```

##### 3. éœ€è¦çš„é¢å¤–å¼€å‘å·¥ä½œ

| å¼€å‘é¡¹ | å·¥ä½œå†…å®¹ | å·¥ä½œé‡ä¼°è®¡ |
|--------|---------|-----------|
| **ç›‘æ§å’Œå‘Šè­¦** | - æ¥å…¥Prometheus/Grafanaç›‘æ§Agentæ€§èƒ½<br>- è®¾ç½®å“åº”æ—¶é—´ã€é”™è¯¯ç‡å‘Šè­¦<br>- ç›‘æ§MsgHubæ¶ˆæ¯å †ç§¯æƒ…å†µ | 3-5å¤© |
| **ä¼šè¯æŒä¹…åŒ–** | - å°†å¯¹è¯å†å²æŒä¹…åŒ–åˆ°æ•°æ®åº“<br>- å®ç°ä¼šè¯æ¢å¤æœºåˆ¶<br>- å®šæœŸæ¸…ç†è¿‡æœŸä¼šè¯ | 2-3å¤© |
| **é™çº§å’Œç†”æ–­** | - å®ç°æœåŠ¡é™çº§ç­–ç•¥(LLMæ•…éšœæ—¶è¿”å›é¢„è®¾å›å¤)<br>- æ¥å…¥ç†”æ–­å™¨(Hystrix/Sentinel)<br>- è®¾è®¡ç¦»çº¿é—®ç­”åº“ä½œä¸ºå¤‡ä»½ | 3-4å¤© |
| **A/Bæµ‹è¯•æ¡†æ¶** | - æ”¯æŒå¤šç‰ˆæœ¬Agentå¹¶è¡Œè¿è¡Œ<br>- æŒ‰æ¯”ä¾‹åˆ†æµç”¨æˆ·è¯·æ±‚<br>- æ”¶é›†æ•ˆæœæ•°æ®å¯¹æ¯” | 5-7å¤© |
| **å®‰å…¨å’Œåˆè§„** | - æ•æ„Ÿä¿¡æ¯è„±æ•<br>- å¯¹è¯å†…å®¹å®¡è®¡æ—¥å¿—<br>- æ¥å…¥ä¼ä¸šèº«ä»½è®¤è¯ç³»ç»Ÿ | 5-7å¤© |

---

#### åº”ç”¨B: ç§‘ç ”è®ºæ–‡å†™ä½œåŠ©æ‰‹ - æ¨èé€‰æ‹© **LangGraph**

##### 1. é€‰æ‹©æ ¸å¿ƒç†ç”±

LangGraphæœ€é€‚åˆç§‘ç ”è®ºæ–‡å†™ä½œåœºæ™¯çš„ä¸‰å¤§æ ¸å¿ƒåŸå› :

**å¤æ‚å·¥ä½œæµå»ºæ¨¡èƒ½åŠ›**
```
è®ºæ–‡å†™ä½œæ˜¯å…¸å‹çš„å¤šæ­¥éª¤è¿­ä»£æµç¨‹,LangGraphçš„çŠ¶æ€å›¾èƒ½å®Œç¾å»ºæ¨¡:

                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚  å¼€å§‹å†™ä½œ    â”‚
                 â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                 â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚ æ–‡çŒ®æ£€ç´¢     â”‚
                 â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                 â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚ å¤§çº²ç”Ÿæˆ     â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
                        â”‚                 â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
              â”‚  äººå·¥å®¡æ ¸å¤§çº²      â”‚       â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
                        â”‚                 â”‚
                  [é€šè¿‡?]                â”‚
                   â•±    â•²                â”‚
                 æ˜¯      å¦               â”‚
                â•±          â•²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â•±
         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
         â”‚ ç« èŠ‚å†™ä½œ  â”‚
         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
              â”‚
         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
         â”‚ æ ¼å¼å®¡æŸ¥  â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”
         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜         â”‚
              â”‚               â”‚
        [è´¨é‡è¾¾æ ‡?]            â”‚
           â•±    â•²            â”‚
         æ˜¯      å¦           â”‚
        â•±          â•²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â•±
  â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”
  â”‚ å®Œæˆ   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**äººå·¥ä»‹å…¥æ”¯æŒ**
- LangGraphçš„`interrupt`æœºåˆ¶å¤©ç„¶æ”¯æŒäººå·¥å®¡æ ¸èŠ‚ç‚¹
- å¯ä»¥åœ¨å…³é”®æ­¥éª¤(å¦‚å¤§çº²ç¡®è®¤ã€åˆç¨¿å®¡é˜…)æš‚åœç­‰å¾…äººå·¥å†³ç­–
- æ”¯æŒäººå·¥ä¿®æ”¹çŠ¶æ€åç»§ç»­æ‰§è¡Œ

**è¿­ä»£ä¼˜åŒ–èƒ½åŠ›**
- çŠ¶æ€å›¾çš„å¾ªç¯è¾¹æ”¯æŒå¤šè½®è¿­ä»£ä¼˜åŒ–
- å¯ä»¥è®¾ç½®è´¨é‡è¯„ä¼°èŠ‚ç‚¹,ä¸è¾¾æ ‡è‡ªåŠ¨è¿”å›é‡å†™
- å®Œæ•´çš„çŠ¶æ€å†å²ä¾¿äºè¿½è¸ªè¿­ä»£è¿‡ç¨‹

##### 2. æ»¡è¶³å…³é”®éœ€æ±‚çš„æŠ€æœ¯æ–¹æ¡ˆ

**éœ€æ±‚1: å¤šæ™ºèƒ½ä½“åä½œ + è¿­ä»£ä¼˜åŒ–**

```python
from typing import TypedDict, Annotated, Literal
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.memory import MemorySaver
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, AIMessage
import operator

# å®šä¹‰è®ºæ–‡å†™ä½œçŠ¶æ€
class PaperWritingState(TypedDict):
    topic: str  # è®ºæ–‡ä¸»é¢˜
    keywords: list[str]  # å…³é”®è¯
    literature: list[dict]  # æ£€ç´¢åˆ°çš„æ–‡çŒ®
    outline: str  # å¤§çº²
    outline_approved: bool  # å¤§çº²æ˜¯å¦é€šè¿‡äººå·¥å®¡æ ¸
    outline_feedback: str  # äººå·¥åé¦ˆæ„è§
    sections: dict[str, str]  # å„ç« èŠ‚å†…å®¹
    draft: str  # å®Œæ•´åˆç¨¿
    quality_score: float  # è´¨é‡è¯„åˆ†
    quality_issues: list[str]  # è´¨é‡é—®é¢˜åˆ—è¡¨
    revision_count: int  # ä¿®è®¢æ¬¡æ•°
    final_paper: str  # æœ€ç»ˆè®ºæ–‡
    messages: Annotated[list, operator.add]  # æ¶ˆæ¯å†å²

# åˆå§‹åŒ–LLM
llm = ChatOpenAI(model="gpt-4", temperature=0.7)

# 1. æ–‡çŒ®æ£€ç´¢èŠ‚ç‚¹
def literature_search_node(state: PaperWritingState) -> dict:
    """æ£€ç´¢ç›¸å…³æ–‡çŒ®"""

    topic = state["topic"]
    keywords = state["keywords"]

    # æ¨¡æ‹Ÿè°ƒç”¨å­¦æœ¯æœç´¢API (å®é™…å¯æ¥å…¥Semantic Scholar, arXivç­‰)
    prompt = f"""
è¯·ä¸ºä»¥ä¸‹ç ”ç©¶ä¸»é¢˜æ£€ç´¢æœ€ç›¸å…³çš„10ç¯‡é«˜è´¨é‡è®ºæ–‡:

ä¸»é¢˜: {topic}
å…³é”®è¯: {', '.join(keywords)}

å¯¹æ¯ç¯‡è®ºæ–‡,è¯·æä¾›:
1. æ ‡é¢˜
2. ä½œè€…
3. å‘è¡¨å¹´ä»½
4. æ ¸å¿ƒè§‚ç‚¹æ‘˜è¦
5. ç ”ç©¶æ–¹æ³•
6. ä¸»è¦ç»“è®º

è¯·ä»¥JSONæ ¼å¼è¿”å›ã€‚
"""

    response = llm.invoke([HumanMessage(content=prompt)])

    # è§£ææ–‡çŒ®ä¿¡æ¯ (è¿™é‡Œç®€åŒ–å¤„ç†)
    import json
    try:
        literature = json.loads(response.content)
    except:
        literature = []

    return {
        "literature": literature,
        "messages": [HumanMessage(content=f"æ£€ç´¢åˆ° {len(literature)} ç¯‡ç›¸å…³æ–‡çŒ®")]
    }

# 2. å¤§çº²ç”ŸæˆèŠ‚ç‚¹
def outline_generation_node(state: PaperWritingState) -> dict:
    """åŸºäºæ–‡çŒ®ç”Ÿæˆè®ºæ–‡å¤§çº²"""

    topic = state["topic"]
    literature = state["literature"]

    lit_summary = "\n".join([
        f"- {lit.get('title', '')}: {lit.get('summary', '')}"
        for lit in literature[:5]  # ä½¿ç”¨å‰5ç¯‡
    ])

    prompt = f"""
åŸºäºä»¥ä¸‹æ–‡çŒ®,ä¸ºç ”ç©¶ä¸»é¢˜ç”Ÿæˆè¯¦ç»†çš„è®ºæ–‡å¤§çº²:

ä¸»é¢˜: {topic}

ç›¸å…³æ–‡çŒ®:
{lit_summary}

è¯·ç”ŸæˆåŒ…å«ä»¥ä¸‹éƒ¨åˆ†çš„å¤§çº²:
1. æ‘˜è¦ (Abstract)
2. å¼•è¨€ (Introduction)
3. æ–‡çŒ®ç»¼è¿° (Literature Review)
4. ç ”ç©¶æ–¹æ³• (Methodology)
5. å®éªŒ/åˆ†æ (Experiments/Analysis)
6. ç»“æœä¸è®¨è®º (Results and Discussion)
7. ç»“è®ºä¸æœªæ¥å·¥ä½œ (Conclusion and Future Work)
8. å‚è€ƒæ–‡çŒ® (References)

æ¯ä¸ªéƒ¨åˆ†è¯·åˆ—å‡º2-3ä¸ªå­èŠ‚,å¹¶ç®€è¦è¯´æ˜å†…å®¹è¦ç‚¹ã€‚
"""

    response = llm.invoke([HumanMessage(content=prompt)])

    return {
        "outline": response.content,
        "outline_approved": False,
        "messages": [HumanMessage(content="å¤§çº²ç”Ÿæˆå®Œæˆ,ç­‰å¾…äººå·¥å®¡æ ¸")]
    }

# 3. äººå·¥å®¡æ ¸èŠ‚ç‚¹ (è¿™æ˜¯ä¸€ä¸ªä¸­æ–­ç‚¹)
def human_review_node(state: PaperWritingState) -> dict:
    """ç­‰å¾…äººå·¥å®¡æ ¸å¤§çº²"""

    # LangGraphä¼šåœ¨è¿™é‡Œä¸­æ–­,ç­‰å¾…å¤–éƒ¨è¾“å…¥
    # äººå·¥å®¡æ ¸åä¼šæ›´æ–° outline_approved å’Œ outline_feedback

    return {
        "messages": [HumanMessage(content="ç­‰å¾…äººå·¥å®¡æ ¸å¤§çº²...")]
    }

# 4. ç« èŠ‚å†™ä½œèŠ‚ç‚¹
def section_writing_node(state: PaperWritingState) -> dict:
    """ä¸ºæ¯ä¸ªç« èŠ‚ç”Ÿæˆè¯¦ç»†å†…å®¹"""

    outline = state["outline"]
    literature = state["literature"]
    feedback = state.get("outline_feedback", "")

    sections = {}
    section_names = [
        "Abstract", "Introduction", "Literature Review",
        "Methodology", "Experiments", "Results", "Conclusion"
    ]

    for section_name in section_names:
        prompt = f"""
è¯·æ ¹æ®ä»¥ä¸‹å¤§çº²å’Œäººå·¥åé¦ˆ,æ’°å†™è®ºæ–‡çš„ã€{section_name}ã€‘éƒ¨åˆ†:

å¤§çº²:
{outline}

äººå·¥åé¦ˆ:
{feedback}

è¦æ±‚:
1. å†…å®¹å……å®,é€»è¾‘ä¸¥å¯†
2. é€‚å½“å¼•ç”¨ç›¸å…³æ–‡çŒ®
3. å­¦æœ¯è¯­è¨€è§„èŒƒ
4. å­—æ•°: 500-800å­—

è¯·å¼€å§‹æ’°å†™:
"""

        response = llm.invoke([HumanMessage(content=prompt)])
        sections[section_name] = response.content

    # åˆå¹¶æ‰€æœ‰ç« èŠ‚
    draft = "\n\n".join([
        f"## {name}\n\n{content}"
        for name, content in sections.items()
    ])

    return {
        "sections": sections,
        "draft": draft,
        "messages": [HumanMessage(content="åˆç¨¿æ’°å†™å®Œæˆ")]
    }

# 5. æ ¼å¼å’Œè´¨é‡å®¡æŸ¥èŠ‚ç‚¹
def quality_review_node(state: PaperWritingState) -> dict:
    """å®¡æŸ¥è®ºæ–‡è´¨é‡å¹¶è¯„åˆ†"""

    draft = state["draft"]

    prompt = f"""
è¯·å®¡æŸ¥ä»¥ä¸‹è®ºæ–‡åˆç¨¿çš„è´¨é‡,ä»ä»¥ä¸‹ç»´åº¦è¯„åˆ†(æ¯é¡¹10åˆ†):

1. ç»“æ„å®Œæ•´æ€§: å„ç« èŠ‚æ˜¯å¦é½å…¨ã€é€»è¾‘æ˜¯å¦è¿è´¯
2. å†…å®¹æ·±åº¦: ç ”ç©¶æ˜¯å¦æ·±å…¥ã€è®ºè¿°æ˜¯å¦å……åˆ†
3. å­¦æœ¯è§„èŒƒ: è¯­è¨€ã€å¼•ç”¨ã€æ ¼å¼æ˜¯å¦ç¬¦åˆå­¦æœ¯æ ‡å‡†
4. åˆ›æ–°æ€§: æ˜¯å¦æœ‰æ–°çš„è§‚ç‚¹æˆ–æ–¹æ³•
5. å¯è¯»æ€§: è¡¨è¾¾æ˜¯å¦æ¸…æ™°æ˜“æ‡‚

è®ºæ–‡åˆç¨¿:
{draft}

è¯·è¿”å›JSONæ ¼å¼:
{{
    "scores": {{
        "structure": <åˆ†æ•°>,
        "depth": <åˆ†æ•°>,
        "academic": <åˆ†æ•°>,
        "novelty": <åˆ†æ•°>,
        "readability": <åˆ†æ•°>
    }},
    "total_score": <æ€»åˆ†>,
    "issues": [<é—®é¢˜åˆ—è¡¨>],
    "suggestions": [<æ”¹è¿›å»ºè®®>]
}}
"""

    response = llm.invoke([HumanMessage(content=prompt)])

    import json
    try:
        review = json.loads(response.content)
        total_score = review.get("total_score", 0)
        issues = review.get("issues", [])
    except:
        total_score = 0
        issues = ["å®¡æŸ¥è§£æå¤±è´¥"]

    return {
        "quality_score": total_score,
        "quality_issues": issues,
        "revision_count": state.get("revision_count", 0) + 1,
        "messages": [HumanMessage(content=f"è´¨é‡è¯„åˆ†: {total_score}/50")]
    }

# 6. ä¿®è®¢èŠ‚ç‚¹
def revision_node(state: PaperWritingState) -> dict:
    """æ ¹æ®è´¨é‡é—®é¢˜ä¿®è®¢è®ºæ–‡"""

    draft = state["draft"]
    issues = state["quality_issues"]

    prompt = f"""
è¯·æ ¹æ®ä»¥ä¸‹è´¨é‡é—®é¢˜ä¿®è®¢è®ºæ–‡:

è´¨é‡é—®é¢˜:
{chr(10).join([f"{i+1}. {issue}" for i, issue in enumerate(issues)])}

åŸå§‹è‰ç¨¿:
{draft}

è¯·è¾“å‡ºä¿®è®¢åçš„å®Œæ•´è®ºæ–‡ã€‚
"""

    response = llm.invoke([HumanMessage(content=prompt)])

    return {
        "draft": response.content,
        "messages": [HumanMessage(content=f"ç¬¬ {state['revision_count']} æ¬¡ä¿®è®¢å®Œæˆ")]
    }

# 7. å®ŒæˆèŠ‚ç‚¹
def finalize_node(state: PaperWritingState) -> dict:
    """æœ€ç»ˆç¡®è®¤è®ºæ–‡"""

    return {
        "final_paper": state["draft"],
        "messages": [HumanMessage(content="è®ºæ–‡å†™ä½œå®Œæˆ!")]
    }

# æ„å»ºçŠ¶æ€å›¾
def create_paper_writing_graph():
    graph = StateGraph(PaperWritingState)

    # æ·»åŠ æ‰€æœ‰èŠ‚ç‚¹
    graph.add_node("search_literature", literature_search_node)
    graph.add_node("generate_outline", outline_generation_node)
    graph.add_node("human_review", human_review_node)
    graph.add_node("write_sections", section_writing_node)
    graph.add_node("quality_review", quality_review_node)
    graph.add_node("revise", revision_node)
    graph.add_node("finalize", finalize_node)

    # å®šä¹‰è¾¹
    graph.set_entry_point("search_literature")
    graph.add_edge("search_literature", "generate_outline")
    graph.add_edge("generate_outline", "human_review")

    # æ¡ä»¶è¾¹: å¤§çº²å®¡æ ¸
    def check_outline_approval(state: PaperWritingState) -> Literal["write_sections", "generate_outline"]:
        if state.get("outline_approved", False):
            return "write_sections"
        else:
            return "generate_outline"  # é‡æ–°ç”Ÿæˆå¤§çº²

    graph.add_conditional_edges(
        "human_review",
        check_outline_approval,
        {
            "write_sections": "write_sections",
            "generate_outline": "generate_outline"
        }
    )

    graph.add_edge("write_sections", "quality_review")

    # æ¡ä»¶è¾¹: è´¨é‡æ£€æŸ¥
    def check_quality(state: PaperWritingState) -> Literal["finalize", "revise"]:
        score = state.get("quality_score", 0)
        revision_count = state.get("revision_count", 0)

        # è¯„åˆ†è¾¾åˆ°40åˆ†æˆ–å·²ä¿®è®¢3æ¬¡,åˆ™å®Œæˆ
        if score >= 40 or revision_count >= 3:
            return "finalize"
        else:
            return "revise"

    graph.add_conditional_edges(
        "quality_review",
        check_quality,
        {
            "finalize": "finalize",
            "revise": "revise"
        }
    )

    # ä¿®è®¢åé‡æ–°è´¨é‡å®¡æŸ¥
    graph.add_edge("revise", "quality_review")

    graph.add_edge("finalize", END)

    # ä½¿ç”¨å†…å­˜æ£€æŸ¥ç‚¹æ”¯æŒä¸­æ–­å’Œæ¢å¤
    memory = MemorySaver()
    app = graph.compile(checkpointer=memory, interrupt_before=["human_review"])

    return app

# ä½¿ç”¨ç¤ºä¾‹
async def write_paper_with_human_in_loop():
    app = create_paper_writing_graph()

    # åˆå§‹åŒ–çŠ¶æ€
    initial_state = {
        "topic": "å¤§è¯­è¨€æ¨¡å‹åœ¨ä»£ç ç”Ÿæˆä¸­çš„åº”ç”¨",
        "keywords": ["LLM", "Code Generation", "AI-assisted Programming"],
        "literature": [],
        "outline": "",
        "outline_approved": False,
        "sections": {},
        "draft": "",
        "quality_score": 0,
        "quality_issues": [],
        "revision_count": 0,
        "final_paper": "",
        "messages": []
    }

    # é…ç½®(ä½¿ç”¨çº¿ç¨‹IDæ”¯æŒå¤šä¼šè¯)
    config = {"configurable": {"thread_id": "paper_001"}}

    # ç¬¬ä¸€é˜¶æ®µ: è¿è¡Œåˆ°äººå·¥å®¡æ ¸ç‚¹
    print("=== é˜¶æ®µ1: æ–‡çŒ®æ£€ç´¢å’Œå¤§çº²ç”Ÿæˆ ===")
    result = await app.ainvoke(initial_state, config)

    print(f"å¤§çº²:\n{result['outline']}\n")

    # æ¨¡æ‹Ÿäººå·¥å®¡æ ¸
    print("=== äººå·¥å®¡æ ¸å¤§çº² ===")
    human_feedback = input("è¯·å®¡æ ¸å¤§çº²å¹¶æä¾›åé¦ˆ (è¾“å…¥'approve'é€šè¿‡): ")

    if human_feedback.lower() == "approve":
        result["outline_approved"] = True
        result["outline_feedback"] = "å¤§çº²é€šè¿‡,å¯ä»¥å¼€å§‹æ’°å†™ã€‚"
    else:
        result["outline_approved"] = False
        result["outline_feedback"] = human_feedback

    # ç¬¬äºŒé˜¶æ®µ: ç»§ç»­æ‰§è¡Œåˆ°å®Œæˆ
    print("\n=== é˜¶æ®µ2: ç« èŠ‚å†™ä½œå’Œè´¨é‡å®¡æŸ¥ ===")
    final_result = await app.ainvoke(result, config)

    print(f"\næœ€ç»ˆè®ºæ–‡:\n{final_result['final_paper']}")
    print(f"\nè´¨é‡è¯„åˆ†: {final_result['quality_score']}/50")
    print(f"ä¿®è®¢æ¬¡æ•°: {final_result['revision_count']}")

# è¿è¡Œ
# asyncio.run(write_paper_with_human_in_loop())
```

**éœ€æ±‚2: é•¿æ—¶é—´ä»»åŠ¡å’Œæ£€æŸ¥ç‚¹**

```python
from langgraph.checkpoint.sqlite import SqliteSaver

# ä½¿ç”¨SQLiteæŒä¹…åŒ–æ£€æŸ¥ç‚¹,æ”¯æŒä»»åŠ¡ä¸­æ–­å’Œæ¢å¤
def create_persistent_paper_writing_graph():
    graph = StateGraph(PaperWritingState)

    # ... (æ·»åŠ æ‰€æœ‰èŠ‚ç‚¹,åŒä¸Š)

    # ä½¿ç”¨SQLiteä¿å­˜æ£€æŸ¥ç‚¹
    checkpointer = SqliteSaver.from_conn_string("paper_writing_checkpoints.db")

    app = graph.compile(
        checkpointer=checkpointer,
        interrupt_before=["human_review"],  # åœ¨äººå·¥å®¡æ ¸å‰ä¸­æ–­
        interrupt_after=["quality_review"]  # è´¨é‡å®¡æŸ¥åä¹Ÿå¯ä»¥ä¸­æ–­,è®©äººå·¥å†³å®šæ˜¯å¦ç»§ç»­
    )

    return app

# ä»»åŠ¡æ¢å¤ç¤ºä¾‹
async def resume_paper_writing(thread_id: str):
    """æ¢å¤ä¹‹å‰ä¸­æ–­çš„å†™ä½œä»»åŠ¡"""

    app = create_persistent_paper_writing_graph()
    config = {"configurable": {"thread_id": thread_id}}

    # è·å–å½“å‰çŠ¶æ€
    state = await app.aget_state(config)

    print(f"æ¢å¤ä»»åŠ¡: {thread_id}")
    print(f"å½“å‰èŠ‚ç‚¹: {state.next}")
    print(f"å·²å®Œæˆä¿®è®¢: {state.values.get('revision_count', 0)} æ¬¡")

    # ç»§ç»­æ‰§è¡Œ
    result = await app.ainvoke(None, config)

    return result
```

##### 3. éœ€è¦çš„é¢å¤–å¼€å‘å·¥ä½œ

| å¼€å‘é¡¹ | å·¥ä½œå†…å®¹ | å·¥ä½œé‡ä¼°è®¡ |
|--------|---------|-----------|
| **å­¦æœ¯APIé›†æˆ** | - æ¥å…¥Semantic Scholar/arXiv/Google Scholar API<br>- å®ç°æ–‡çŒ®å»é‡å’Œæ’åºç®—æ³•<br>- ç¼“å­˜æ–‡çŒ®æ£€ç´¢ç»“æœ | 5-7å¤© |
| **å‰ç«¯ç•Œé¢** | - å¼€å‘Webç•Œé¢ä¾›ç”¨æˆ·æäº¤ä¸»é¢˜<br>- å®æ—¶æ˜¾ç¤ºå†™ä½œè¿›åº¦<br>- äººå·¥å®¡æ ¸äº¤äº’ç•Œé¢(å¤§çº²ç¡®è®¤ã€ä¿®æ”¹å»ºè®®ç­‰) | 10-15å¤© |
| **ç‰ˆæœ¬ç®¡ç†** | - ä¿å­˜æ¯æ¬¡ä¿®è®¢çš„ç‰ˆæœ¬<br>- æ”¯æŒç‰ˆæœ¬å¯¹æ¯”å’Œå›æ»š<br>- å¯¼å‡ºç‰ˆæœ¬å†å²æŠ¥å‘Š | 3-5å¤© |
| **å¼•ç”¨ç®¡ç†** | - è‡ªåŠ¨ç”Ÿæˆå‚è€ƒæ–‡çŒ®åˆ—è¡¨<br>- æ”¯æŒå¤šç§å¼•ç”¨æ ¼å¼(APA/MLA/Chicagoç­‰)<br>- æ–‡å†…å¼•ç”¨è‡ªåŠ¨æ ‡æ³¨ | 5-7å¤© |
| **å¯¼å‡ºåŠŸèƒ½** | - æ”¯æŒå¯¼å‡ºä¸ºWord/LaTeX/PDFæ ¼å¼<br>- ä¿ç•™æ ¼å¼å’Œæ ·å¼<br>- ç”Ÿæˆç¬¦åˆæœŸåˆŠæ¨¡æ¿çš„ç‰ˆæœ¬ | 3-5å¤© |

---

#### åº”ç”¨C: é‡‘èé£æ§å®¡æ‰¹ç³»ç»Ÿ - æ¨èé€‰æ‹© **è‡ªç ”æ¡†æ¶ + AutoGen**

##### 1. é€‰æ‹©æ ¸å¿ƒç†ç”±

**ä¸ºä»€ä¹ˆä¸å®Œå…¨ä½¿ç”¨ç°æœ‰æ¡†æ¶?**

é‡‘èé£æ§ç³»ç»Ÿæœ‰æå…¶ä¸¥æ ¼çš„ç‰¹æ®Šè¦æ±‚,ç°æœ‰é€šç”¨æ¡†æ¶éš¾ä»¥å®Œå…¨æ»¡è¶³:

```
é£æ§ç³»ç»Ÿçš„ç‰¹æ®Šè¦æ±‚:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. ç¡®å®šæ€§å’Œå¯è§£é‡Šæ€§                              â”‚
â”‚     - æ¯ä¸ªå†³ç­–å¿…é¡»æœ‰å®Œæ•´çš„æ¨ç†é“¾                   â”‚
â”‚     - ä¸èƒ½æœ‰"é»‘ç›’"å†³ç­–                           â”‚
â”‚     - LLMçš„éšæœºæ€§å¿…é¡»è¢«ä¸¥æ ¼æ§åˆ¶                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. å®¡è®¡è¿½è¸ª                                     â”‚
â”‚     - å®Œæ•´è®°å½•æ¯ä¸ªæ™ºèƒ½ä½“çš„è¾“å…¥è¾“å‡º                 â”‚
â”‚     - è®°å½•å†³ç­–æ—¶é—´ã€è§¦å‘è§„åˆ™ã€ä½¿ç”¨çš„æ•°æ®æº          â”‚
â”‚     - ä¸å¯ç¯¡æ”¹çš„æ—¥å¿—å­˜å‚¨                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. è§„åˆ™å¼•æ“é›†æˆ                                  â”‚
â”‚     - å¿…é¡»å…ˆæ‰§è¡Œç¡¬æ€§è§„åˆ™(ç›‘ç®¡è¦æ±‚ã€å…¬å¸æ”¿ç­–)        â”‚
â”‚     - LLMåªèƒ½åœ¨è§„åˆ™å…è®¸çš„èŒƒå›´å†…æä¾›å»ºè®®            â”‚
â”‚     - è§„åˆ™ä¼˜å…ˆçº§é«˜äºAIåˆ¤æ–­                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. äººå·¥å¤æ ¸                                     â”‚
â”‚     - é«˜é£é™©æ¡ˆä¾‹å¿…é¡»äººå·¥å¤æ ¸                       â”‚
â”‚     - æ”¯æŒå¤šçº§å®¡æ‰¹æµç¨‹                            â”‚
â”‚     - AIå»ºè®®å¯è¢«äººå·¥å¦å†³                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ¨èæ–¹æ¡ˆ: è‡ªç ”æ¡†æ¶ + AutoGen**

- **è‡ªç ”éƒ¨åˆ†**: è§„åˆ™å¼•æ“ã€å®¡è®¡æ—¥å¿—ã€å®¡æ‰¹æµç¨‹æ§åˆ¶
- **AutoGenéƒ¨åˆ†**: å¤šä¸“å®¶æ™ºèƒ½ä½“åå•†å’Œè¯„ä¼°

è¿™ç§æ··åˆæ¶æ„èƒ½å…¼é¡¾åˆè§„æ€§å’Œæ™ºèƒ½åŒ–ã€‚

##### 2. ç³»ç»Ÿæ¶æ„è®¾è®¡

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   å®¡æ‰¹è¯·æ±‚å…¥å£    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  è§„åˆ™å¼•æ“é¢„å®¡     â”‚ â—„â”€â”€â”€ ç¡¬æ€§è§„åˆ™åº“
                    â”‚  (è‡ªç ”)          â”‚      - ç›‘ç®¡è§„åˆ™
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      - é»‘åå•
                             â”‚                - é™é¢è§„åˆ™
                      [é€šè¿‡è§„åˆ™?]
                       â•±          â•²
                    å¦               æ˜¯
                   â•±                  â•²
          â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚ è‡ªåŠ¨æ‹’ç»    â”‚         â”‚ å¤šä¸“å®¶è¯„ä¼°    â”‚
          â”‚ (è®°å½•åŸå› )  â”‚         â”‚ (AutoGen)    â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â”‚            â”‚            â”‚
                   â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
                   â”‚åˆè§„ä¸“å®¶   â”‚ â”‚é£é™©ä¸“å®¶  â”‚ â”‚é¢åº¦ä¸“å®¶   â”‚
                   â”‚Agent     â”‚ â”‚Agent    â”‚ â”‚Agent     â”‚
                   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                         â”‚            â”‚            â”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚  å†³ç­–æ±‡æ€»å’Œä»²è£ â”‚
                              â”‚  (è‡ªç ”)        â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                               [é£é™©è¯„åˆ†]
                                â•±     â”‚    â•²
                            ä½       ä¸­      é«˜
                           â•±         â”‚        â•²
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”  â”Œâ”€â”€â”€â–¼â”€â”€â”€â”  â”Œâ”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
                  â”‚ è‡ªåŠ¨é€šè¿‡  â”‚  â”‚äººå·¥å¤æ ¸â”‚  â”‚é«˜çº§å®¡æ‰¹  â”‚
                  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”€â”˜  â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                          â”‚         â”‚          â”‚
                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                            â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                            â”‚   å®¡è®¡æ—¥å¿—è®°å½•  â”‚
                            â”‚   (ä¸å¯ç¯¡æ”¹)   â”‚
                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

##### 3. æ ¸å¿ƒä»£ç å®ç°

**è§„åˆ™å¼•æ“ (è‡ªç ”)**

```python
from dataclasses import dataclass
from typing import List, Dict, Optional, Literal
from enum import Enum
import json
from datetime import datetime
import hashlib

class RiskLevel(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    REJECTED = "rejected"

@dataclass
class ApprovalRequest:
    """å®¡æ‰¹è¯·æ±‚"""
    request_id: str
    customer_id: str
    product_type: str  # loan, credit_card, investmentç­‰
    amount: float
    customer_info: dict
    financial_data: dict
    timestamp: datetime

@dataclass
class RuleResult:
    """è§„åˆ™æ‰§è¡Œç»“æœ"""
    rule_id: str
    rule_name: str
    passed: bool
    reason: str
    details: dict

class RuleEngine:
    """é‡‘èé£æ§è§„åˆ™å¼•æ“"""

    def __init__(self, rules_config_path: str):
        with open(rules_config_path, 'r') as f:
            self.rules = json.load(f)
        self.execution_log = []

    def evaluate(self, request: ApprovalRequest) -> tuple[bool, List[RuleResult]]:
        """
        æ‰§è¡Œæ‰€æœ‰è§„åˆ™
        è¿”å›: (æ˜¯å¦é€šè¿‡, è§„åˆ™ç»“æœåˆ—è¡¨)
        """
        results = []

        # 1. ç›‘ç®¡åˆè§„æ€§è§„åˆ™ (æœ€é«˜ä¼˜å…ˆçº§)
        regulatory_pass, regulatory_results = self._check_regulatory_rules(request)
        results.extend(regulatory_results)

        if not regulatory_pass:
            return False, results

        # 2. é»‘åå•è§„åˆ™
        blacklist_pass, blacklist_results = self._check_blacklist(request)
        results.extend(blacklist_results)

        if not blacklist_pass:
            return False, results

        # 3. é™é¢è§„åˆ™
        limit_pass, limit_results = self._check_limits(request)
        results.extend(limit_results)

        if not limit_pass:
            return False, results

        # 4. ä¸šåŠ¡è§„åˆ™
        business_pass, business_results = self._check_business_rules(request)
        results.extend(business_results)

        return business_pass, results

    def _check_regulatory_rules(self, request: ApprovalRequest) -> tuple[bool, List[RuleResult]]:
        """ç›‘ç®¡è§„åˆ™æ£€æŸ¥"""
        results = []

        # ç¤ºä¾‹è§„åˆ™1: å¹´é¾„é™åˆ¶
        age = request.customer_info.get("age", 0)
        age_rule = RuleResult(
            rule_id="REG_001",
            rule_name="å¹´é¾„åˆè§„æ£€æŸ¥",
            passed=18 <= age <= 70,
            reason=f"å®¢æˆ·å¹´é¾„ {age} å²" + ("ç¬¦åˆ" if 18 <= age <= 70 else "ä¸ç¬¦åˆ") + "ç›‘ç®¡è¦æ±‚(18-70å²)",
            details={"age": age, "min_age": 18, "max_age": 70}
        )
        results.append(age_rule)

        # ç¤ºä¾‹è§„åˆ™2: åæ´—é’±æ£€æŸ¥
        suspicious_flag = request.customer_info.get("aml_suspicious", False)
        aml_rule = RuleResult(
            rule_id="REG_002",
            rule_name="åæ´—é’±æ£€æŸ¥",
            passed=not suspicious_flag,
            reason="å®¢æˆ·" + ("æœª" if not suspicious_flag else "") + "æ ‡è®°ä¸ºå¯ç–‘",
            details={"suspicious_flag": suspicious_flag}
        )
        results.append(aml_rule)

        all_passed = all(r.passed for r in results)
        return all_passed, results

    def _check_blacklist(self, request: ApprovalRequest) -> tuple[bool, List[RuleResult]]:
        """é»‘åå•æ£€æŸ¥"""
        results = []

        # æ£€æŸ¥å®¢æˆ·æ˜¯å¦åœ¨é»‘åå•
        is_blacklisted = request.customer_info.get("blacklisted", False)

        blacklist_rule = RuleResult(
            rule_id="BL_001",
            rule_name="é»‘åå•æ£€æŸ¥",
            passed=not is_blacklisted,
            reason="å®¢æˆ·" + ("ä¸" if not is_blacklisted else "") + "åœ¨é»‘åå•ä¸­",
            details={"blacklisted": is_blacklisted}
        )
        results.append(blacklist_rule)

        return not is_blacklisted, results

    def _check_limits(self, request: ApprovalRequest) -> tuple[bool, List[RuleResult]]:
        """é™é¢æ£€æŸ¥"""
        results = []

        # è·å–å®¢æˆ·ç­‰çº§å¯¹åº”çš„é™é¢
        customer_level = request.customer_info.get("level", "standard")
        limits = self.rules.get("limits", {}).get(customer_level, {})
        max_amount = limits.get(request.product_type, 0)

        limit_rule = RuleResult(
            rule_id="LMT_001",
            rule_name="é¢åº¦é™åˆ¶æ£€æŸ¥",
            passed=request.amount <= max_amount,
            reason=f"ç”³è¯·é‡‘é¢ {request.amount} " + ("æœª" if request.amount <= max_amount else "") +
                   f"è¶…è¿‡è¯¥å®¢æˆ·ç­‰çº§({customer_level})é™é¢ {max_amount}",
            details={
                "request_amount": request.amount,
                "max_amount": max_amount,
                "customer_level": customer_level
            }
        )
        results.append(limit_rule)

        return request.amount <= max_amount, results

    def _check_business_rules(self, request: ApprovalRequest) -> tuple[bool, List[RuleResult]]:
        """ä¸šåŠ¡è§„åˆ™æ£€æŸ¥"""
        results = []

        # ç¤ºä¾‹: æ”¶å…¥å€ºåŠ¡æ¯”æ£€æŸ¥
        monthly_income = request.financial_data.get("monthly_income", 0)
        existing_debt = request.financial_data.get("existing_debt", 0)
        monthly_payment = request.amount / 36  # å‡è®¾3å¹´è¿˜æ¬¾

        debt_to_income = (existing_debt + monthly_payment) / monthly_income if monthly_income > 0 else float('inf')

        dti_rule = RuleResult(
            rule_id="BIZ_001",
            rule_name="å€ºåŠ¡æ”¶å…¥æ¯”æ£€æŸ¥",
            passed=debt_to_income <= 0.5,  # DTIä¸è¶…è¿‡50%
            reason=f"å€ºåŠ¡æ”¶å…¥æ¯” {debt_to_income:.2%} " + ("ç¬¦åˆ" if debt_to_income <= 0.5 else "è¶…è¿‡") + "è¦æ±‚(<50%)",
            details={
                "dti_ratio": debt_to_income,
                "monthly_income": monthly_income,
                "existing_debt": existing_debt,
                "new_payment": monthly_payment
            }
        )
        results.append(dti_rule)

        return debt_to_income <= 0.5, results

# è§„åˆ™é…ç½®æ–‡ä»¶ç¤ºä¾‹ (rules.json)
"""
{
    "limits": {
        "standard": {
            "loan": 100000,
            "credit_card": 50000
        },
        "premium": {
            "loan": 500000,
            "credit_card": 200000
        },
        "vip": {
            "loan": 2000000,
            "credit_card": 1000000
        }
    }
}
"""
```

**å¤šä¸“å®¶è¯„ä¼° (AutoGen)**

```python
from autogen import AssistantAgent, UserProxyAgent, GroupChat, GroupChatManager
from typing import List, Dict

class FinancialRiskAssessment:
    """åŸºäºAutoGençš„å¤šä¸“å®¶é£é™©è¯„ä¼°"""

    def __init__(self, llm_config: dict):
        self.llm_config = llm_config
        self._setup_agents()

    def _setup_agents(self):
        """è®¾ç½®ä¸“å®¶æ™ºèƒ½ä½“"""

        # 1. åˆè§„ä¸“å®¶
        self.compliance_expert = AssistantAgent(
            name="ComplianceExpert",
            system_message="""ä½ æ˜¯é‡‘èåˆè§„ä¸“å®¶,è´Ÿè´£è¯„ä¼°:
1. æ˜¯å¦ç¬¦åˆç›‘ç®¡è¦æ±‚
2. æ˜¯å¦å­˜åœ¨åˆè§„é£é™©
3. æ˜¯å¦éœ€è¦é¢å¤–çš„åˆè§„æ–‡ä»¶

è¯„ä¼°å®Œæˆå,è¯·ç»™å‡º:
- åˆè§„é£é™©ç­‰çº§: ä½/ä¸­/é«˜
- ä¸»è¦åˆè§„å…³æ³¨ç‚¹
- å»ºè®®æªæ–½

è¯·ä»¥JSONæ ¼å¼è¾“å‡ºç»“æœã€‚
""",
            llm_config=self.llm_config
        )

        # 2. ä¿¡ç”¨é£é™©ä¸“å®¶
        self.credit_expert = AssistantAgent(
            name="CreditExpert",
            system_message="""ä½ æ˜¯ä¿¡ç”¨é£é™©ä¸“å®¶,è´Ÿè´£è¯„ä¼°:
1. å®¢æˆ·çš„è¿˜æ¬¾èƒ½åŠ›
2. å†å²ä¿¡ç”¨è®°å½•
3. è¿çº¦æ¦‚ç‡

è¯„ä¼°å®Œæˆå,è¯·ç»™å‡º:
- ä¿¡ç”¨é£é™©ç­‰çº§: ä½/ä¸­/é«˜
- è¿çº¦æ¦‚ç‡ä¼°è®¡
- å»ºè®®çš„é£é™©ç¼“é‡Šæªæ–½

è¯·ä»¥JSONæ ¼å¼è¾“å‡ºç»“æœã€‚
""",
            llm_config=self.llm_config
        )

        # 3. é¢åº¦ä¸“å®¶
        self.limit_expert = AssistantAgent(
            name="LimitExpert",
            system_message="""ä½ æ˜¯é¢åº¦ç®¡ç†ä¸“å®¶,è´Ÿè´£è¯„ä¼°:
1. åˆç†çš„æˆä¿¡é¢åº¦
2. å®šä»·å»ºè®®(åˆ©ç‡/è´¹ç‡)
3. è¿˜æ¬¾æœŸé™å»ºè®®

è¯„ä¼°å®Œæˆå,è¯·ç»™å‡º:
- å»ºè®®æˆä¿¡é¢åº¦
- å»ºè®®åˆ©ç‡
- å»ºè®®æœŸé™
- é¢åº¦è°ƒæ•´çš„ç†ç”±

è¯·ä»¥JSONæ ¼å¼è¾“å‡ºç»“æœã€‚
""",
            llm_config=self.llm_config
        )

        # ç”¨æˆ·ä»£ç†(ç”¨äºå¯åŠ¨å’Œæ±‡æ€»)
        self.user_proxy = UserProxyAgent(
            name="Coordinator",
            human_input_mode="NEVER",
            max_consecutive_auto_reply=0,
            code_execution_config=False
        )

    def assess(self, request: ApprovalRequest, rule_results: List[RuleResult]) -> Dict:
        """å¤šä¸“å®¶ååŒè¯„ä¼°"""

        # æ„å»ºè¯„ä¼°æç¤º
        prompt = self._build_assessment_prompt(request, rule_results)

        # åˆ›å»ºç¾¤èŠ
        group_chat = GroupChat(
            agents=[
                self.compliance_expert,
                self.credit_expert,
                self.limit_expert,
                self.user_proxy
            ],
            messages=[],
            max_round=6,  # æ¯ä¸ªä¸“å®¶å‘è¨€2æ¬¡
            speaker_selection_method="round_robin"  # è½®æµå‘è¨€
        )

        manager = GroupChatManager(groupchat=group_chat, llm_config=self.llm_config)

        # å¯åŠ¨è¯„ä¼°
        self.user_proxy.initiate_chat(
            manager,
            message=prompt
        )

        # æ”¶é›†å„ä¸“å®¶çš„è¯„ä¼°ç»“æœ
        assessment_results = self._parse_expert_opinions(group_chat.messages)

        # ç»¼åˆå†³ç­–
        final_decision = self._make_final_decision(assessment_results)

        return final_decision

    def _build_assessment_prompt(
        self,
        request: ApprovalRequest,
        rule_results: List[RuleResult]
    ) -> str:
        """æ„å»ºè¯„ä¼°æç¤º"""

        # æ±‡æ€»è§„åˆ™æ£€æŸ¥ç»“æœ
        rule_summary = "\n".join([
            f"- {r.rule_name}: {'é€šè¿‡' if r.passed else 'æœªé€šè¿‡'} - {r.reason}"
            for r in rule_results
        ])

        prompt = f"""
è¯·å„ä½ä¸“å®¶å¯¹ä»¥ä¸‹é‡‘èå®¡æ‰¹ç”³è¯·è¿›è¡Œè¯„ä¼°:

## ç”³è¯·ä¿¡æ¯
- ç”³è¯·ID: {request.request_id}
- å®¢æˆ·ID: {request.customer_id}
- äº§å“ç±»å‹: {request.product_type}
- ç”³è¯·é‡‘é¢: {request.amount}

## å®¢æˆ·ä¿¡æ¯
- å¹´é¾„: {request.customer_info.get('age')}
- å®¢æˆ·ç­‰çº§: {request.customer_info.get('level')}
- ä¿¡ç”¨è¯„åˆ†: {request.customer_info.get('credit_score')}

## è´¢åŠ¡æ•°æ®
- æœˆæ”¶å…¥: {request.financial_data.get('monthly_income')}
- ç°æœ‰å€ºåŠ¡: {request.financial_data.get('existing_debt')}
- èµ„äº§æ€»é¢: {request.financial_data.get('total_assets')}

## è§„åˆ™å¼•æ“æ£€æŸ¥ç»“æœ
{rule_summary}

è¯·å„ä½ä¸“å®¶ä»å„è‡ªçš„ä¸“ä¸šè§’åº¦ç»™å‡ºè¯„ä¼°æ„è§å’Œå»ºè®®ã€‚
"""
        return prompt

    def _parse_expert_opinions(self, messages: List) -> Dict:
        """è§£æä¸“å®¶æ„è§"""

        opinions = {
            "compliance": {},
            "credit": {},
            "limit": {}
        }

        for msg in messages:
            if msg.get("name") == "ComplianceExpert":
                # è§£æåˆè§„ä¸“å®¶æ„è§
                try:
                    opinions["compliance"] = json.loads(msg.get("content", "{}"))
                except:
                    pass
            elif msg.get("name") == "CreditExpert":
                try:
                    opinions["credit"] = json.loads(msg.get("content", "{}"))
                except:
                    pass
            elif msg.get("name") == "LimitExpert":
                try:
                    opinions["limit"] = json.loads(msg.get("content", "{}"))
                except:
                    pass

        return opinions

    def _make_final_decision(self, opinions: Dict) -> Dict:
        """ç»¼åˆå†³ç­–"""

        # æå–å„ä¸“å®¶çš„é£é™©ç­‰çº§
        compliance_risk = opinions.get("compliance", {}).get("risk_level", "high")
        credit_risk = opinions.get("credit", {}).get("risk_level", "high")

        # å†³ç­–é€»è¾‘: ä»»ä¸€ä¸“å®¶è¯„ä¼°ä¸ºé«˜é£é™©åˆ™ä¸ºé«˜é£é™©
        if "high" in [compliance_risk, credit_risk]:
            final_risk = RiskLevel.HIGH
        elif "medium" in [compliance_risk, credit_risk]:
            final_risk = RiskLevel.MEDIUM
        else:
            final_risk = RiskLevel.LOW

        # ç»¼åˆå»ºè®®é¢åº¦
        suggested_amount = opinions.get("limit", {}).get("suggested_amount", 0)

        return {
            "risk_level": final_risk,
            "suggested_amount": suggested_amount,
            "expert_opinions": opinions,
            "decision": self._risk_to_decision(final_risk),
            "requires_human_review": final_risk in [RiskLevel.MEDIUM, RiskLevel.HIGH]
        }

    def _risk_to_decision(self, risk: RiskLevel) -> str:
        """é£é™©ç­‰çº§è½¬å†³ç­–"""
        if risk == RiskLevel.LOW:
            return "auto_approve"
        elif risk == RiskLevel.MEDIUM:
            return "manual_review"
        else:
            return "senior_review"
```

**å®¡è®¡æ—¥å¿— (è‡ªç ”)**

```python
import sqlite3
from datetime import datetime
import hashlib
import json

class AuditLogger:
    """ä¸å¯ç¯¡æ”¹çš„å®¡è®¡æ—¥å¿—ç³»ç»Ÿ"""

    def __init__(self, db_path: str = "audit_log.db"):
        self.db_path = db_path
        self._init_db()

    def _init_db(self):
        """åˆå§‹åŒ–æ•°æ®åº“"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute("""
        CREATE TABLE IF NOT EXISTS audit_logs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            request_id TEXT NOT NULL,
            timestamp TEXT NOT NULL,
            event_type TEXT NOT NULL,
            actor TEXT NOT NULL,
            action TEXT NOT NULL,
            details TEXT NOT NULL,
            previous_hash TEXT,
            current_hash TEXT NOT NULL,
            UNIQUE(current_hash)
        )
        """)

        cursor.execute("""
        CREATE INDEX IF NOT EXISTS idx_request_id ON audit_logs(request_id)
        """)

        conn.commit()
        conn.close()

    def log(
        self,
        request_id: str,
        event_type: str,
        actor: str,
        action: str,
        details: dict
    ) -> str:
        """è®°å½•å®¡è®¡æ—¥å¿—"""

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # è·å–ä¸Šä¸€æ¡è®°å½•çš„å“ˆå¸Œ(ä¿è¯é“¾å¼å®Œæ•´æ€§)
        cursor.execute(
            "SELECT current_hash FROM audit_logs ORDER BY id DESC LIMIT 1"
        )
        result = cursor.fetchone()
        previous_hash = result[0] if result else "GENESIS"

        # æ„å»ºå½“å‰è®°å½•
        timestamp = datetime.now().isoformat()
        details_json = json.dumps(details, ensure_ascii=False, sort_keys=True)

        # è®¡ç®—å½“å‰å“ˆå¸Œ
        hash_content = f"{request_id}|{timestamp}|{event_type}|{actor}|{action}|{details_json}|{previous_hash}"
        current_hash = hashlib.sha256(hash_content.encode()).hexdigest()

        # æ’å…¥è®°å½•
        cursor.execute("""
        INSERT INTO audit_logs
        (request_id, timestamp, event_type, actor, action, details, previous_hash, current_hash)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        """, (request_id, timestamp, event_type, actor, action, details_json, previous_hash, current_hash))

        conn.commit()
        conn.close()

        return current_hash

    def get_request_history(self, request_id: str) -> List[Dict]:
        """è·å–æŸä¸ªè¯·æ±‚çš„å®Œæ•´å®¡è®¡å†å²"""

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute("""
        SELECT timestamp, event_type, actor, action, details, current_hash
        FROM audit_logs
        WHERE request_id = ?
        ORDER BY id ASC
        """, (request_id,))

        rows = cursor.fetchall()
        conn.close()

        history = []
        for row in rows:
            history.append({
                "timestamp": row[0],
                "event_type": row[1],
                "actor": row[2],
                "action": row[3],
                "details": json.loads(row[4]),
                "hash": row[5]
            })

        return history

    def verify_integrity(self) -> bool:
        """éªŒè¯æ—¥å¿—é“¾å®Œæ•´æ€§"""

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute("""
        SELECT id, request_id, timestamp, event_type, actor, action, details, previous_hash, current_hash
        FROM audit_logs
        ORDER BY id ASC
        """)

        rows = cursor.fetchall()
        conn.close()

        previous_hash = "GENESIS"

        for row in rows:
            # é‡æ–°è®¡ç®—å“ˆå¸Œ
            hash_content = f"{row[1]}|{row[2]}|{row[3]}|{row[4]}|{row[5]}|{row[6]}|{previous_hash}"
            computed_hash = hashlib.sha256(hash_content.encode()).hexdigest()

            # éªŒè¯
            if computed_hash != row[8]:
                print(f"å®Œæ•´æ€§éªŒè¯å¤±è´¥: è®°å½• ID {row[0]}")
                return False

            if row[7] != previous_hash:
                print(f"é“¾å¼éªŒè¯å¤±è´¥: è®°å½• ID {row[0]}")
                return False

            previous_hash = row[8]

        return True
```

**å®Œæ•´å®¡æ‰¹æµç¨‹**

```python
class FinancialApprovalSystem:
    """å®Œæ•´çš„é‡‘èé£æ§å®¡æ‰¹ç³»ç»Ÿ"""

    def __init__(
        self,
        rule_engine: RuleEngine,
        risk_assessment: FinancialRiskAssessment,
        audit_logger: AuditLogger
    ):
        self.rule_engine = rule_engine
        self.risk_assessment = risk_assessment
        self.audit_logger = audit_logger

    def process_request(self, request: ApprovalRequest) -> Dict:
        """å¤„ç†å®¡æ‰¹è¯·æ±‚"""

        request_id = request.request_id

        # 1. è®°å½•è¯·æ±‚å¼€å§‹
        self.audit_logger.log(
            request_id=request_id,
            event_type="request_received",
            actor="system",
            action="start_processing",
            details={
                "customer_id": request.customer_id,
                "product_type": request.product_type,
                "amount": request.amount
            }
        )

        # 2. è§„åˆ™å¼•æ“é¢„å®¡
        rule_passed, rule_results = self.rule_engine.evaluate(request)

        self.audit_logger.log(
            request_id=request_id,
            event_type="rule_check",
            actor="rule_engine",
            action="evaluate_rules",
            details={
                "passed": rule_passed,
                "results": [
                    {
                        "rule_id": r.rule_id,
                        "rule_name": r.rule_name,
                        "passed": r.passed,
                        "reason": r.reason
                    }
                    for r in rule_results
                ]
            }
        )

        if not rule_passed:
            # è§„åˆ™æœªé€šè¿‡,ç›´æ¥æ‹’ç»
            self.audit_logger.log(
                request_id=request_id,
                event_type="decision",
                actor="rule_engine",
                action="auto_reject",
                details={"reason": "è§„åˆ™æ£€æŸ¥æœªé€šè¿‡"}
            )

            return {
                "request_id": request_id,
                "decision": "rejected",
                "reason": "è§„åˆ™æ£€æŸ¥æœªé€šè¿‡",
                "rule_results": rule_results
            }

        # 3. å¤šä¸“å®¶è¯„ä¼°
        assessment_result = self.risk_assessment.assess(request, rule_results)

        self.audit_logger.log(
            request_id=request_id,
            event_type="expert_assessment",
            actor="multi_agent_system",
            action="risk_assessment",
            details=assessment_result
        )

        # 4. æ ¹æ®é£é™©ç­‰çº§å†³ç­–
        risk_level = assessment_result["risk_level"]

        if risk_level == RiskLevel.LOW:
            # ä½é£é™©,è‡ªåŠ¨é€šè¿‡
            decision = "approved"
            self.audit_logger.log(
                request_id=request_id,
                event_type="decision",
                actor="system",
                action="auto_approve",
                details={
                    "risk_level": "low",
                    "approved_amount": assessment_result["suggested_amount"]
                }
            )

        elif risk_level == RiskLevel.MEDIUM:
            # ä¸­é£é™©,éœ€è¦äººå·¥å¤æ ¸
            decision = "pending_manual_review"
            self.audit_logger.log(
                request_id=request_id,
                event_type="decision",
                actor="system",
                action="request_manual_review",
                details={"risk_level": "medium"}
            )

        else:
            # é«˜é£é™©,éœ€è¦é«˜çº§å®¡æ‰¹
            decision = "pending_senior_review"
            self.audit_logger.log(
                request_id=request_id,
                event_type="decision",
                actor="system",
                action="request_senior_review",
                details={"risk_level": "high"}
            )

        return {
            "request_id": request_id,
            "decision": decision,
            "risk_level": risk_level.value,
            "assessment_result": assessment_result,
            "rule_results": rule_results
        }

    def manual_review(
        self,
        request_id: str,
        reviewer: str,
        decision: Literal["approve", "reject"],
        comments: str
    ):
        """äººå·¥å¤æ ¸"""

        self.audit_logger.log(
            request_id=request_id,
            event_type="manual_review",
            actor=reviewer,
            action=decision,
            details={"comments": comments}
        )

        return {
            "request_id": request_id,
            "final_decision": decision,
            "reviewed_by": reviewer
        }

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # åˆå§‹åŒ–ç³»ç»Ÿ
    rule_engine = RuleEngine("rules.json")
    risk_assessment = FinancialRiskAssessment(llm_config={"model": "gpt-4"})
    audit_logger = AuditLogger()

    system = FinancialApprovalSystem(rule_engine, risk_assessment, audit_logger)

    # åˆ›å»ºå®¡æ‰¹è¯·æ±‚
    request = ApprovalRequest(
        request_id="REQ_20250122_001",
        customer_id="CUST_12345",
        product_type="loan",
        amount=300000,
        customer_info={
            "age": 35,
            "level": "premium",
            "credit_score": 750,
            "blacklisted": False
        },
        financial_data={
            "monthly_income": 50000,
            "existing_debt": 10000,
            "total_assets": 1000000
        },
        timestamp=datetime.now()
    )

    # å¤„ç†è¯·æ±‚
    result = system.process_request(request)

    print(f"å†³ç­–ç»“æœ: {result['decision']}")
    print(f"é£é™©ç­‰çº§: {result['risk_level']}")

    # å¦‚æœéœ€è¦äººå·¥å¤æ ¸
    if result["decision"] == "pending_manual_review":
        system.manual_review(
            request_id=request.request_id,
            reviewer="å¼ ä¸‰(é£æ§ç»ç†)",
            decision="approve",
            comments="å®¢æˆ·èµ„è´¨è‰¯å¥½,å†å²è®°å½•ä¼˜ç§€,åŒæ„é€šè¿‡"
        )

    # æŸ¥çœ‹å®Œæ•´å®¡è®¡å†å²
    history = audit_logger.get_request_history(request.request_id)
    print("\nå®¡è®¡å†å²:")
    for event in history:
        print(f"- {event['timestamp']}: {event['actor']} {event['action']}")

    # éªŒè¯æ—¥å¿—å®Œæ•´æ€§
    integrity_ok = audit_logger.verify_integrity()
    print(f"\næ—¥å¿—å®Œæ•´æ€§éªŒè¯: {'é€šè¿‡' if integrity_ok else 'å¤±è´¥'}")

# main()
```

##### 3. éœ€è¦çš„é¢å¤–å¼€å‘å·¥ä½œ

| å¼€å‘é¡¹ | å·¥ä½œå†…å®¹ | å·¥ä½œé‡ä¼°è®¡ |
|--------|---------|-----------|
| **è§„åˆ™å¼•æ“æ‰©å±•** | - æ”¯æŒåŠ¨æ€è§„åˆ™åŠ è½½å’Œçƒ­æ›´æ–°<br>- è§„åˆ™ç‰ˆæœ¬ç®¡ç†<br>- å¯è§†åŒ–è§„åˆ™ç¼–è¾‘å™¨ | 10-15å¤© |
| **å®¡æ‰¹å·¥ä½œæµ** | - å¤šçº§å®¡æ‰¹æµç¨‹å¼•æ“<br>- å·¥ä½œæµçŠ¶æ€æœº<br>- å®¡æ‰¹è¶…æ—¶æé†’ | 7-10å¤© |
| **æŠ¥è¡¨å’Œç›‘æ§** | - å®¡æ‰¹æ•ˆç‡åˆ†ææŠ¥è¡¨<br>- é£é™©åˆ†å¸ƒå¯è§†åŒ–<br>- å®æ—¶ç›‘æ§å¤§å± | 5-7å¤© |
| **æ¨¡å‹ç®¡ç†** | - é£é™©è¯„ä¼°æ¨¡å‹ç‰ˆæœ¬ç®¡ç†<br>- A/Bæµ‹è¯•æ¡†æ¶<br>- æ¨¡å‹æ•ˆæœè¯„ä¼° | 10-15å¤© |
| **é›†æˆæ¥å£** | - å¯¹æ¥å¾ä¿¡ç³»ç»ŸAPI<br>- å¯¹æ¥åæ¬ºè¯ˆç³»ç»Ÿ<br>- å¯¹æ¥æ ¸å¿ƒä¸šåŠ¡ç³»ç»Ÿ | 15-20å¤© |

---

### æ€»ç»“å¯¹æ¯”

| ç»´åº¦ | åº”ç”¨A (æ™ºèƒ½å®¢æœ) | åº”ç”¨B (è®ºæ–‡åŠ©æ‰‹) | åº”ç”¨C (é£æ§å®¡æ‰¹) |
|------|-----------------|-----------------|-----------------|
| **æ¨èæ¡†æ¶** | AgentScope | LangGraph | è‡ªç ” + AutoGen |
| **æ ¸å¿ƒä¼˜åŠ¿** | åˆ†å¸ƒå¼+é«˜å¹¶å‘ | å¤æ‚æµç¨‹+äººå·¥ä»‹å…¥ | åˆè§„æ€§+å¯å®¡è®¡ |
| **å…³é”®ç‰¹æ€§** | MsgHubæ¶ˆæ¯æ€»çº¿ | çŠ¶æ€å›¾+ä¸­æ–­æœºåˆ¶ | è§„åˆ™å¼•æ“+å®¡è®¡æ—¥å¿— |
| **å¹¶å‘å¤„ç†** | â­â­â­â­â­ | â­â­ | â­â­â­ |
| **æµç¨‹å¤æ‚åº¦** | â­â­ | â­â­â­â­â­ | â­â­â­â­ |
| **åˆè§„è¦æ±‚** | â­â­ | â­â­â­ | â­â­â­â­â­ |
| **å¼€å‘æˆæœ¬** | ä¸­ | ä¸­ | é«˜ |
| **è¿ç»´å¤æ‚åº¦** | ä¸­ | ä½ | é«˜ |
| **å¯æ‰©å±•æ€§** | â­â­â­â­â­ | â­â­â­ | â­â­â­â­ |

---

è¿™å°±æ˜¯ç¬¬6é¢˜çš„å®Œæ•´è§£ç­”!æ¶µç›–:
1. ä¸‰ä¸ªåº”ç”¨åœºæ™¯çš„æ·±å…¥åˆ†æ
2. æ¡†æ¶é€‰æ‹©çš„è¯¦ç»†ç†ç”±å’ŒæŠ€æœ¯æ–¹æ¡ˆ
3. å®Œæ•´çš„ä»£ç å®ç°ç¤ºä¾‹
4. é¢å¤–å¼€å‘å·¥ä½œé‡ä¼°ç®—